<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

<!-- If you make edits to any FAQ documents, please start each sentence
     on a new line, and try to keep the general formatting consistent
     with the rest of the pages -->

<title>OpenBSD FAQ: Networking</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "copyright"     content= "This document copyright 1998-2016
                                      by OpenBSD.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../openbsd.css">
<link rel="canonical" href="https://www.openbsd.org/faq/faq6.html">
</head>

<body bgcolor="#ffffff" text="#000000">

<h2>
<a href="../index.html">
<font color="#0000ff"><i>Open</i></font><font color="#000084">BSD</font></a>
<font color="#e00000">FAQ - Networking</font>
<small>
<a href="index.html" style="font-weight:normal; float:right">[FAQ Index]</a>
</small>
</h2>
<hr>

<ul>
<li><a href="#Intro"           >Background</a>
<li><a href="#Setup"           >Network configuration</a>
<ul>
  <li><a href="#Setup.if"      >Identifying and setting up your
                                network interfaces</a>
  <li><a href="#Setup.gateway" >Default hostname and gateway</a>
  <li><a href="#Setup.resolver">DNS resolution</a>
  <li><a href="#Setup.activate">Activating the changes</a>
  <li><a href="#Setup.chkroute">Checking routes</a>
  <li><a href="#Setup.aliases" >Setting up aliases on interfaces</a>
  <li><a href="#Setup.replace" >Adding and replacing NICs</a>
</ul>
<li><a href= "#PF"             >Firewalling</a>
<li><a href= "#DHCP"           >Dynamic Host Configuration Protocol</a>
<ul>
  <li><a href="#DHCPclient"    >DHCP client</a>
  <li><a href="#DHCPserver"    >DHCP server</a>
</ul>
<li><a href="#NFS"             >Using NFS</a>
<li><a href="#Bridge"          >Setting up a network bridge</a>
<li><a href="#PXE"             >PXE booting</a>
<li><a href="#OpenNTPD"        >Using OpenNTPD</a>
<li><a href="#Wireless"        >Wireless networking</a>
<li><a href="#Multipath"       >Equal-cost multipath routing</a>
</ul>

<hr>

<h2 id="Intro">Background</h2>

For the bulk of this document, it helps if you have read and at least partially
understand the <a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> and
<a href="http://man.openbsd.org/netstat">netstat(1)</a> man pages.

<p>
If you are a network administrator, setting up routing protocols, using
your OpenBSD box as a router or want to go in-depth into IP networking,
it is recommended that you read the chapter on
<a href="http://www.tcpipguide.com/free/t_IPAddressing.htm">IP addressing</a>
in the TCP/IP guide.
It contains fundamental knowledge to build upon when working with IP networks,
especially when you deal with or are responsible for more than one network.

<p>
If you are working with applications such as web servers, ftp servers
and mail servers, you may benefit greatly by reading
<a href="http://www.rfc-editor.org/rfc.html">the RFCs</a>.
Pick some topics that you are interested in or that you use in your
network environment.
The RFCs define many (thousands of) standards for protocols on the
internet and how they are supposed to work.

<h2 id="Setup">Network configuration</h2>

Normally, OpenBSD's network settings are initially configured by the
<a href="faq4.html">installation process</a>.
All network configuration is done using text files in <tt>/etc</tt>.

<h3 id="Setup.if">Identifying and setting up your network interfaces</h3>

In OpenBSD, interfaces are named for the type of card, not for the type of
connection.
For example, here is the part of the
<a href="http://man.openbsd.org/dmesg">dmesg(8)</a> for an Intel Fast Ethernet
network card, which uses the device name <tt>fxp</tt>.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

This device uses the <a href="http://man.openbsd.org/fxp">fxp(4)</a> driver, and
is assigned the number 0 here.

<p>
You can find out what network interfaces have been identified by using the
<a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> utility.
The following command will show all network interfaces on a system.
This sample output shows us only one physical Ethernet interface, an
<a href="http://man.openbsd.org/fxp">fxp(4)</a>.

<blockquote><pre>
$ <b>ifconfig</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33200
        index 3 priority 0 llprio 3
        groups: lo
        inet 127.0.0.1 netmask 0xff000000
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        lladdr 00:04:ac:dd:39:6a
        index 1 priority 0 llprio 3
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
enc0: flags=0&lt;&gt;
        index 2 priority 0 llprio 3
        groups: enc
        status: active
pflog0: flags=141&lt;UP,RUNNING,PROMISC&gt; mtu 33200
        index 4 priority 0 llprio 3
        groups: pflog
</pre></blockquote>

As you can see here, <a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a>
gives us a lot more information than we need at this point.
In the above example, an IP network is configured on <tt>fxp0</tt>, hence the
values <tt>inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255</tt>.
Also, the <tt>UP</tt> and <tt>RUNNING</tt> flags are set.

<p>
Interfaces are configured at boot time using
<a href="http://man.openbsd.org/hostname.if">hostname.if(5)</a> files, where
"if" is replaced by the full name of each interface.
The example above would use the file <tt>/etc/hostname.fxp0</tt>:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
inet 10.0.0.38 255.255.255.0
</pre></blockquote>

Finally, you will notice several other interfaces come enabled by default.
These are virtual interfaces that serve various functions.
The following manual pages describe them:

<ul>
  <li><a href="http://man.openbsd.org/lo">lo</a>
    - loopback interface
  <li><a href="http://man.openbsd.org/pflog">pflog</a>
    - Packet Filter logging interface
  <li><a href="http://man.openbsd.org/enc">enc</a>
    - encapsulating interface
</ul>

Other virtual interfaces can be added with the
<a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> <tt>create</tt>
command.
These include, but are not limited to:

<ul>
  <li><a href="http://man.openbsd.org/ppp">ppp</a>
    - Point-to-Point Protocol interface
  <li><a href="http://man.openbsd.org/tun">tun</a>
    - Tunnel network interface
  <li><a href="http://man.openbsd.org/bridge">bridge</a>
    - Ethernet bridge interface
  <li><a href="http://man.openbsd.org/vlan">vlan</a>
    - IEEE 802.1Q encapsulation interface
  <li><a href="http://man.openbsd.org/svlan">svlan</a>
    - IEEE 802.1AD provider bridges (QinQ)
  <li><a href="http://man.openbsd.org/gre">gre</a>
    - GRE/MobileIP encapsulation interface
  <li><a href="http://man.openbsd.org/gif">gif</a>
    - Generic IPv4/IPv6 tunnel interface
  <li><a href="http://man.openbsd.org/carp.4">carp</a>
    - Common Address Redundancy Protocol interface
  <li><a href="http://man.openbsd.org/mpe">mpe</a>
    - MPLS Provider Edge
  <li><a href="http://man.openbsd.org/vether">vether</a>
    - Virtual Ethernet interface
  <li><a href="http://man.openbsd.org/trunk">trunk</a>
    - Link aggregation and link failover interface
  <li><a href="http://man.openbsd.org/vxlan">vxlan</a>
    - Virtual eXtensible Local Area Network tunnel Interface
</ul>

For a complete listing of virtual interfaces, refer to the
<a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> man page.

<h3 id="Setup.gateway">Default hostname and gateway</h3>

The <tt>/etc/myname</tt> and <tt>/etc/mygate</tt> files are read by the
<a href="http://man.openbsd.org/netstart">netstart(8)</a> script.
Both of these files consist of a single line, specifying the fully qualified
domain name of the system and the address of the gateway host, respectively.
The <tt>/etc/mygate</tt> file need not exist on all systems.
See <a href="http://man.openbsd.org/myname">myname(5)</a> for more details.

<h3 id="Setup.resolver">DNS resolution</h3>

DNS resolution is controlled by
<a href="http://man.openbsd.org/resolv.conf">resolv.conf(5)</a>.

<blockquote><pre>
$ <b>cat /etc/resolv.conf</b>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

Here, the default domain name will be <tt>example.com</tt>, there will be two
DNS resolvers, <tt>125.2.3.4</tt> and <tt>125.2.3.5</tt>, and the
<a href="http://man.openbsd.org/hosts">hosts(5)</a> file will be consulted
before the DNS resolvers are.

<p>
If you are using DHCP, you'll want to read <a href="#DHCP">DHCP</a>, taking note
of <a href="http://man.openbsd.org/resolv.conf.tail">resolv.conf.tail(5)</a>.

<h3 id="Setup.activate">Activating the changes</h3>

From here, you can either reboot or run the
<a href="http://man.openbsd.org/netstart">netstart(8)</a> script:

<blockquote><pre>
# <b>sh /etc/netstart</b>
</pre></blockquote>

Note that a few warnings may be produced when running this script if you are
reconfiguring interfaces that have already been configured.
Use <a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> to make sure that
your interfaces were set up correctly.

<p>
Even though you can completely reconfigure networking on a running OpenBSD
system, a reboot is recommended after any significant reconfiguration.
The reason for this is that the environment at boot is somewhat different than
it is when the system is up and running.
For example, if you had specified a DNS-resolved symbolic name in any of the
files, you would probably find it worked as expected after reconfiguring.
On initial boot, however, your external resolver may not be available, so the
configuration will fail.

<h3 id="Setup.chkroute">Checking routes</h3>

You can check your routes via
<a href="http://man.openbsd.org/netstat">netstat(1)</a> or
<a href="http://man.openbsd.org/route">route(8)</a>.
If you are having routing problems, you may want to use the <tt>-n</tt> flag
to route(8), which prints the IP addresses rather than doing a DNS lookup
and displaying the hostname.
Here is an example of viewing your routing tables using both programs.

<blockquote><pre>
$ <b>netstat -rn</b>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <b>route show</b>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<h3 id="Setup.aliases">Setting up aliases on an interface</h3>

OpenBSD has a simple mechanism for setting up IP aliases on an
interface.
To do this, simply edit the file <tt>/etc/hostname.<i>if</i></tt>.
This file is read upon boot by the
<a href="http://man.openbsd.org/netstart">netstart(8)</a>
script, which is part of the <a href="faq10.html#rc">rc startup hierarchy</a>.
For the example, we assume that the user has an
interface <tt>dc0</tt> and is on the network 192.168.0.0.
The IP address for <tt>dc0</tt> is 192.168.0.2 and the netmask is 255.255.255.0.

<p>
A few side notes about aliases.
In OpenBSD, you only use the interface name.
There is no difference between the first alias and the second alias.
Unlike some other operating systems, OpenBSD doesn't refer to them as
<tt>dc0:0</tt>, <tt>dc0:1</tt>.
If you are referring to a specific aliased IP address with <tt>ifconfig</tt>,
or adding an alias, be sure to use <tt>ifconfig int alias</tt> instead of
just <tt>ifconfig int</tt> at the command line.
You can delete aliases with <tt>ifconfig int delete</tt>.

<p>
Assuming you are using multiple IP addresses which are in the same IP
subnet with aliases, your netmask setting for each alias becomes
255.255.255.255.
They do not need to follow the netmask of the first IP bound to the interface.
In this example, <tt>/etc/hostname.dc0</tt>, two aliases are added to the
device <tt>dc0</tt>, which was configured as 192.168.0.2 netmask 255.255.255.0.

<blockquote><pre>
$ <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 NONE media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

Once you've created this file, a reboot is required for it to take effect.
You can, however, bring up the aliases by hand using the
<a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> utility.
To bring up the first alias, you would use the command:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

(but again, a reboot is recommended to make sure you entered everything
as you expected it to be!)

<p>
To view these aliases, you must use the command:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>

<h3 id="Setup.replace">Adding and replacing NICs</h3>

You may have to replace or add a network adapter on an OpenBSD system,
maybe upgrading the capabilities of the system or repairing failed
hardware.
This will require some reconfiguration.
The good news is that it's relatively easy, though there are some things
to be aware of.

<p>
The key is understanding how OpenBSD names NICs.
Unlike some OSs that try to remember any network adapter the installed
OS has ever seen, OpenBSD does not remember a NIC's identification
between boots -- it names them in the order that they are found.
In most cases, this is far simpler for you, as the system will always
identify a NIC the same way in the same hardware configuration, and
when configurations change, the results are easily understood.

<p>
Here are some cases:

<ul>
  <li><b>Replace a NIC with an identical device:</b>
    This would be the case when you move the disk system from a failed machine
    to another identical machine, or install an image or full backup to
    identical hardware.
    In this case, things are easy -- no change in configuration will be needed,
    other than perhaps changing the IP address in the <tt>hostname.if</tt> file
    if needed.

  <li><b>Replace a NIC with a different device:</b>
    This would also be the case when one moves a disk system to a non-identical
    machine.
    In this case, simply rename the old <tt>hostname.<i>if</i></tt> file to
    match the new device.
    For example, if you replace an
    <a href="http://man.openbsd.org/fxp">fxp(4)</a> device which was
    <tt>fxp0</tt> with a <a href="http://man.openbsd.org/re">re(4)</a> device,
    which would end up as <tt>re0</tt>, you could rename
    <tt>/etc/hostname.fxp0</tt> to <tt>/etc/hostname.re0</tt> and your new
    device would take over the configuration of the old device.
    If you might someday restore the original configuration, you may prefer to
    make the new file a hard link to the original, rather than renaming it.

  <li><b>Replacing one of several similar cards with a different type:</b>
    Let's assume you have a machine with <tt>fxp0</tt>, <tt>fxp1</tt> and
    <tt>fxp2</tt>, and <tt>fxp0</tt> fails.
    Unfortunately, you don't have a spare similar fxp card, so you need to
    replace it with an <a href="http://man.openbsd.org/em">em(4)</a> card.
    This gets a little ugly, as <tt>fxp1</tt> and <tt>fxp2</tt> will rename
    themselves:

    <blockquote><pre>
    <b>old  -> new</b>
    fxp0 -> em0
    fxp1 -> fxp0
    fxp2 -> fxp1
    </pre></blockquote>

    Again, rename your <tt>/etc/hostname.<i>if</i></tt> files accordingly:

    <blockquote><pre>
    # <b>cd /etc</b>
    # <b>mv hostname.fxp0 hostname.em0</b>
    # <b>mv hostname.fxp1 hostname.fxp0</b>
    # <b>mv hostname.fxp2 hostname.fxp1</b>
    </pre></blockquote>

  <li><b>Adding a new NIC to an existing system:</b>
    If your added NIC is of a different type, it will be the "0" device of
    whatever driver it is.
    For example, if you are adding a
    <a href="http://man.openbsd.org/bge">bge(4)</a> device to a machine with
    only an <a href="http://man.openbsd.org/rl">rl(4)</a> device, life is easy
    -- the new device will be <tt>bge0</tt>, so create an appropriate
    <tt>/etc/hostname.bge0</tt>.

    <p>
    The more difficult variation is when you are adding a new card of the same
    type as another in the machine.
    Most add-on NICs will have their MAC address written somewhere on the card.
    Make note of this, insert the card, and look at the dmesg.
    Note the identifier of the new NIC and its relationship to the earlier NICs.
    You may find that ALL the existing NICs have changed number.
    You may be able to put the new NIC in a different slot to change the
    identifier as desired, but if the earlier devices were onboard, you may have
    no option but to adjust the <tt>hostname.<i>if</i></tt> files.

  <li><b>Total Confusion:</b>
    Sometimes, things get totally confused.
    Maybe your new machine has lots of multi-port NICs, or several onboard NICs
    and you aren't quite sure how they are identified.
    Or perhaps changes were made with less care than might be hoped for, and now
    you aren't sure what is what.

    <p>
    The first thing to note is that
    <a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> will tell you both
    the MAC address and the link status of each port.
    So the first trick might be to mark add-in cards with their MAC addresses.
    Another trick in a confused situation can be to simply attach ONE unknown
    NIC to a switch port at a time, and look for which NIC in
    <a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> is now showing a
    link.
    Once you have a few ports identified, you will often figure out the rest
    quickly.
</ul>

In addition to the <tt>hostname.<i>if</i></tt> files, any other file that deals
with hardware interfaces will have to be adjusted.
Some likely candidates might include:

<ul>
  <li>PF configuration (<tt>/etc/pf.conf</tt>)
  <li>CARP configuration (<tt>/etc/hostname.carp*</tt>)
  <li>Bridge configuration (<tt>/etc/hostname.bridge*</tt>)
  <li>Trunk configuration (<tt>/etc/hostname.trunk*</tt>)
</ul>

<h2 id="PF">Firewalling</h2>

Packet Filter (from here on referred to as PF) is OpenBSD's system for
filtering IP traffic and doing Network Address Translation.
PF is also capable of normalizing and conditioning IP traffic,
providing bandwidth control and packet prioritization, and can be used
to create powerful and flexible firewalls.
It is described in the <a href="pf/index.html">PF User's Guide</a>.

<h2 id="DHCP">Dynamic Host Configuration Protocol</h2>

Dynamic Host Configuration Protocol is a way to configure network
interfaces "automatically."
OpenBSD can be a DHCP server (configuring other machines), a DHCP client
(configured by another machine) or, in some cases, both.

<h3 id="DHCPclient">DHCP client</h3>

To use the DHCP client included with OpenBSD,
<a href="http://man.openbsd.org/dhclient">dhclient(8)</a>, edit
<tt>/etc/hostname.xl0</tt>.
This is assuming your main Ethernet interface is <tt>xl0</tt>.
Yours might be <tt>em0</tt> or <tt>fxp0</tt> or something else.

<blockquote><pre>
# <b>echo dhcp > /etc/hostname.xl0</b>
</pre></blockquote>

This will cause OpenBSD to automatically start the DHCP client on boot.
OpenBSD will gather its IP address, default gateway, and DNS servers
from the DHCP server.

<p>
If you want to start a DHCP client from the command line, make sure
<tt>/etc/dhclient.conf</tt> exists, then run:

<blockquote><pre>
# <b>dhclient xl0</b>
</pre></blockquote>

where <tt>xl0</tt> is the interface on which you want to receive DHCP.

<p>
No matter how you start the DHCP client, you can edit the
<tt>/etc/dhclient.conf</tt> file to <b>not</b> update your DNS according to the
DHCP server's idea of DNS by first uncommenting the "request" lines in it.
They are examples of the default settings, but you need to uncomment
them to override dhclient's defaults.

<blockquote><pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre></blockquote>

Then remove <tt>domain-name-servers</tt>.
Of course, you may want to remove <tt>host-name</tt>, or other settings too.

<p>
By changing options in your
<a href="http://man.openbsd.org/dhclient.conf">dhclient.conf(5)</a>
file, you're telling the DHCP client how to build your
<a href="http://man.openbsd.org/resolv.conf">resolv.conf(5)</a> file.
The DHCP client overrides any information you already have in
resolv.conf with the information it retrieves from the DHCP server.
Therefore, you'll lose any changes you made manually to resolv.conf.

<p>
There are two mechanisms available to prevent this:

<ul>
  <li>Option modifiers (<tt>default</tt>, <tt>supersede</tt>, <tt>prepend</tt>
    and <tt>append</tt>) allow you to override any of the options in
    <a href="http://man.openbsd.org/dhclient.conf">dhclient.conf(5)</a>.
  <li>The
    <a href="http://man.openbsd.org/resolv.conf.tail">resolv.conf.tail(5)</a>
    file allows you to append anything you want to the resolv.conf file created
    by dhclient.
</ul>

An example would be if you're using DHCP but want to append
<tt>lookup file bind</tt> to the resolv.conf created by dhclient.
There is no option for this in <tt>dhclient.conf</tt>, so you must use
<tt>resolv.conf.tail</tt> to preserve this.

<blockquote><pre>
# <b>echo "lookup file bind" > /etc/resolv.conf.tail</b>
</pre></blockquote>

Now your resolv.conf should include "lookup file bind" at the end.

<blockquote><pre>
$ <b>cat /etc/resolv.conf</b>
nameserver 192.168.1.1
nameserver 192.168.1.2
lookup file bind
</pre></blockquote>

<h3 id="DHCPserver">DHCP server</h3>

If you want to use OpenBSD as a DHCP server, enable the
<a href="http://man.openbsd.org/dhcpd">dhcpd(8)</a> daemon at startup.
For example:

<blockquote><pre>
# <b>rcctl enable dhcpd</b>
</pre></blockquote>

This will run dhcpd and attach to all NICs which have valid configurations
in <a href="http://man.openbsd.org/dhcpd.conf">dhcpd.conf(5)</a>.
You may specify individual interfaces instead by naming them explicitly.
For example:

<blockquote><pre>
# <b>rcctl set dhcpd flags xl1 xl2 xl3</b>
</pre></blockquote>

Then edit <tt>/etc/dhcpd.conf</tt>.
The options are pretty self-explanatory.

<blockquote><pre>
option  domain-name "example.com";
option  domain-name-servers 192.168.1.3, 192.168.1.5;
subnet 192.168.1.0 netmask 255.255.255.0 {
        option routers 192.168.1.1;
        range 192.168.1.32 192.168.1.127;
}
</pre></blockquote>

This will tell your DHCP clients that the domain to append to DNS
requests is example.com (so, if the user types in 'telnet joe' then it
will send them to joe.example.com).
It will point them to DNS servers 192.168.1.3 and 192.168.1.5.
For hosts that are on the same network as an Ethernet interface on the
OpenBSD machine, which is in the 192.168.1.0/24 range, it will assign
them an IP address between 192.168.1.32 and 192.168.1.127.
It will set their default gateway as 192.168.1.1.

<p>
If you want to start dhcpd(8) from the command line after editing
<tt>/etc/dhcpd.conf</tt>, run:

<blockquote><pre>
# <b>rcctl start dhcpd</b>
</pre></blockquote>

If there were fatal configuration errors, it will exit and let you know
that it failed to start.
You can usually see why in <tt>/var/log/messages</tt> or
<tt>/var/log/daemon</tt>.

<p>
If you are serving DHCP to a Windows box, you may want dhcpd(8) to give
the client a 'WINS' server address.
To make this happen, just add the following line to your
<tt>/etc/dhcpd.conf</tt>:

<blockquote><pre>
option    netbios-name-servers    192.168.92.55;
</pre></blockquote>

where <tt>192.168.92.55</tt> is the IP of your Windows or Samba server.
See <a href="http://man.openbsd.org/dhcp-options">dhcp-options(5)</a>
for more options that your DHCP clients may want.

<h2 id="NFS">Using NFS</h2>

NFS, or the Network File System, is used to share a filesystem over the
network.

<p>
This section will go through the steps for a simple setup of NFS.
This example details a server on a LAN, with clients accessing NFS on the LAN.
It does not cover securing NFS.
We presume you have already set up packet filtering or other firewalling
protection to prevent outside access.
If you are allowing outside access to your NFS server, and you have any kind of
sensitive data stored on it, we strongly recommend that you employ IPsec.
Otherwise, people can potentially see your NFS traffic.
Someone could also pretend to be the IP address which you are allowing into your
NFS server.
There are several attacks that can result.
When properly configured, IPsec protects against these types of attacks.

<h3>Setting up an NFS server</h3>

These services must be enabled and running on the server:

<ul>
  <li><a href="http://man.openbsd.org/portmap">portmap(8)</a>
  <li><a href="http://man.openbsd.org/mountd">mountd(8)</a>
  <li><a href="http://man.openbsd.org/nfsd">nfsd(8)</a>
</ul>

By default, each of these is disabled in OpenBSD.
If you want them enabled, run the following commands:

<blockquote><pre>
# <b>rcctl enable portmap mountd nfsd</b>
# <b>rcctl set nfsd flags -tun 4</b>
</pre></blockquote>

The next step is to configure the list of filesystems that will be made
available for clients to mount.

<p>
In this example, we have a server with IP address 10.0.0.1.
This server will be serving NFS only to clients within its own subnet.
All of this is configured in the <tt>/etc/exports</tt> file.
This file lists which filesystems you wish to have accessible via NFS
and defines who is able to access them.
There are many options that you can use in <tt>/etc/exports</tt>; it is
best that you read the <a href="http://man.openbsd.org/exports">exports(5)</a>
man page.
For our example server, we've set up an exports file that looks like this:

<blockquote><pre>
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network=10.0.0 -mask=255.255.255.0
</pre></blockquote>

This means that the local filesystem <tt>/work</tt> will be made available via
NFS.
The <tt>-alldirs</tt> option specifies that clients will be able to mount at any
point under <tt>/work</tt> as well as <tt>/work</tt> itself.
For example, if there was a directory called <tt>/work/monday</tt>, clients
could mount <tt>/work</tt> (and have access to all files/directories underneath
that directory) or they could mount <tt>/work/monday</tt> and have access to
just the files/directories contained there.
The <tt>-ro</tt> option specifies that clients will only be granted read-only
access.
The last two arguments specify that only clients within the 10.0.0.0 network
using a netmask of 255.255.255.0 will be authorized to mount this filesystem.
This is important for some servers that are accessible by different networks.

<p>
Another important security note: don't just add a filesystem to
<tt>/etc/exports</tt> without some kind of list of allowed host(s).
Without a list of hosts which can mount a particular directory, anyone who can
reach your server will be able to mount your NFS exported directories.

<p>
Now you can start the server services.
You can either reboot (after enabling them as per the instructions above) or
start them manually.

<blockquote><pre>
# <b>rcctl start portmap mountd nfsd</b>
</pre></blockquote>

The <tt>nfsd_flags</tt> enable TCP (<tt>-t</tt>) and UDP (<tt>-u</tt>)
connections and enable 4 instances (<tt>-n</tt>) of nfsd to run.
You should set an appropriate number of NFS server instances to handle the
maximum number of concurrent client requests that you want to service by
adjusting the flags nfsd is started with.

<p>
You're now ready to mount the exported filesystems from the client(s).

<p>
Remember: If you make changes to <tt>/etc/exports</tt> while NFS is already
running, you need to make mountd aware of this!
Just HUP mountd and the changes will take affect.

<blockquote><pre>
# <b>rcctl reload mountd</b>
</pre></blockquote>

<h3>Mounting NFS Filesystems</h3>

NFS filesystems can be mounted from a client without needing to enable any
services or daemons.
They can be mounted just like any other filesystem.

<p>
NFS filesystems should be mounted via mount(8), or more specifically,
<a href="http://man.openbsd.org/mount_nfs">mount_nfs(8)</a>.
To mount the <tt>/work</tt> filesystem on host 10.0.0.1 to local filesystem
<tt>/mnt</tt>, do this (note that you don't need to use an IP address;
mount will resolve host names):

<blockquote><pre>
# <b>mount -t nfs 10.0.0.1:/work /mnt</b>
</pre></blockquote>

To have that filesystem mounted at boot, add something like this to
<a href="http://man.openbsd.org/fstab">fstab(5)</a>:

<blockquote><pre>
# <b>echo '10.0.0.1:/work /mnt nfs rw 0 0' >> /etc/fstab</b>
</pre></blockquote>

It is important that you use <tt>0 0</tt> at the end of this line so that your
computer does not try to fsck the NFS filesystem on boot.
The other standard security options, such as <tt>noexec</tt>, <tt>nodev</tt>,
and <tt>nosuid</tt>, should also be used where applicable.
For example:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

This way, no devices or setuid programs on the NFS server can subvert security
measures on the NFS client.
If you are not mounting programs that you expect to run on the NFS client, add
<tt>noexec</tt> to this list.

<p>
When accessing an NFS mount as the root user, the server automatically maps
root's access to username "nobody" and group "nobody."
This is important to know when considering file permissions.
For example, take a file with these permissions:

<blockquote><pre>
-rw-------    1 root     wheel           0 Dec 31 03:00 _daily.B20143
</pre></blockquote>

If this file was on an NFS share and the root user tried to access this file
from the NFS client, access would be denied.
This is because the server uses the credentials of the user "nobody" when root
tries to access the file.
Since the user nobody doesn't have permissions to access the file, access is
denied.

<p>
The user and group that root are mapped to are configurable via the
<a href="http://man.openbsd.org/export">exports(5)</a> file on the NFS server.

<h3>Checking Stats on NFS</h3>

One thing to check to ensure NFS is operating properly is that all the daemons
have properly registered with RPC.
To do this, use <a href="http://man.openbsd.org/rpcinfo">rpcinfo(8)</a>.

<blockquote><pre>
$ <b>rpcinfo -p 10.0.0.1</b>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

During normal usage, there are a few other utilities that allow you to see what
is happening with NFS.
One is <a href="http://man.openbsd.org/showmount">showmount(8)</a>, which allows
you to view what is currently mounted and who is mounting it.
There is also <a href="http://man.openbsd.org/nfsstat">nfsstat(1)</a>, which
shows much more verbose statistics.
To use showmount(8), try <tt>/usr/bin/showmount -a host</tt>.
For example:

<blockquote><pre>
$ <b>showmount -a 10.0.0.1</b>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

This output shows that the client 10.0.0.37 has mounted the <tt>/work</tt>
export being served from the server at 10.0.0.1.

<h2 id="Bridge">Setting up a network bridge</h2>

A <a href="http://man.openbsd.org/bridge">bridge(4)</a> is a link between two or
more separate networks.
Unlike a router, packets transfer through the bridge "invisibly" -- logically,
the two network segments appear to be one segment to nodes on either side of the
bridge.
Bridges will only forward packets that have to pass from one segment to the
other.
They provide, among other things, an easy way to reduce traffic in a complex
network and yet allow any node to access any other node when needed.

<p>
Note that because of this "invisible" nature, an interface in a bridge may or
may not have an IP address of its own.
If it does, the interface has effectively two modes of operation, one as part
of a bridge, the other as a normal, stand-alone NIC.
If neither interface has an IP address, the bridge will pass network data,
but will not be externally maintainable (which can be a feature).

<h3>A simple example of a bridge application</h3>

One of my computer racks has a number of older systems, none of which have a
built-in 10BASE-TX NIC.
While they all have an AUI or AAUI connector, my supply of transceivers is
limited to coax.
One of the machines on this rack is an OpenBSD-based terminal server which is
always on and connected to the high-speed network.
Adding a second NIC with a coax port will allow me to use this machine as a
bridge to the coax network.

<p>
This system has two NICs in it now, an Intel EtherExpress/100 <tt>fxp0</tt> and
a 3c590-Combo card <tt>ep0</tt> for the coax port.
<tt>fxp0</tt> is the link to the rest of my network and will thus have an IP
address, while <tt>ep0</tt> is going to be for bridging only, and will have no
IP address.
Machines attached to the coax segment will communicate as if they were on the
rest of my network.
So, how do we make this happen?

<p>
The file <tt>hostname.fxp0</tt> contains the configuration info for the
<tt>fxp0</tt> card.
This machine is set up using DHCP, so its file looks like this:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp
</pre></blockquote>

The <tt>ep0</tt> card is a bit different, as you might guess:

<blockquote><pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre></blockquote>

Here, we are instructing the system to activate this interface using
<a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> and setting it to
10BASE-2 (coax).
No IP address or similar information needs to be specified for this interface.
The options the <tt>ep</tt> card accepts are detailed in its
<a href="http://man.openbsd.org/ep">man page</a>.

<p>
Now, we need to set up the bridge.
Bridges are initialized by the existence of a file named something like
<a href="http://man.openbsd.org/hostname.if"><tt>hostname.bridge0</tt></a>.
Here is an example for my situation here:

<blockquote><pre>
$ <b>cat /etc/hostname.bridge0</b>
add fxp0
add ep0
up
</pre></blockquote>

This is saying "set up a bridge consisting of the two NICs, <tt>fxp0</tt> and
<tt>ep0</tt>, and activate it."
Does the order in which the cards are listed matter?
No; remember, a bridge is symmetrical -- packets flow in and out in both
directions.

<p>
That's it!
Reboot and you now have a functioning bridge.

<h3>A bridge acting as a DHCP server</h3>

Let's say we have a small system which has four
<a href="http://man.openbsd.org/vr">vr(4)</a> interfaces, <tt>vr0</tt> through
<tt>vr3</tt>.
We want to bridge <tt>vr1</tt>, <tt>vr2</tt> and <tt>vr3</tt> together, leaving
out <tt>vr0</tt> for an uplink (a cable modem for instance).
We also want to serve IP addresses through DHCP over the bridged interfaces.
Being a DHCP server and an uplink router, the box needs to have an IP address
on the bridged network (contrary to the previous example in which the bridging
box was not visible on the network).

<p>
It is not possible to assign an IP address directly to a bridge interface.
The IP address should be added to one of the member interfaces, but we cannot
use a physical interface as the link might be down, in which case the address
would not be reachable.
Fortunately, there is the <a href="http://man.openbsd.org/vether">vether(4)</a>
virtual Ethernet interface driver that can be used for this purpose.
We will add it to the bridge, assign the IP address to it and make
<a href="http://man.openbsd.org/dhcpd">dhcpd(8)</a> listen there.

<p>
Notes:

<ul>
  <li>The <a href="#DHCPserver">DHCP server configuration</a> is not described
    yet again in this section, but the addressing scheme used here is the same.
  <li>This will also be the uplink router for your bridged network, so we will
    use IP address 192.168.1.1 to match the DHCP server configuration.
  <li>We will not cover the uplink, routing or firewalling configuration here.
</ul>

First, mark the <tt>vr1</tt>, <tt>vr2</tt> and <tt>vr3</tt> interfaces as up:

<blockquote><pre>
# <b>echo up > /etc/hostname.vr1</b>
# <b>echo up > /etc/hostname.vr2</b>
# <b>echo up > /etc/hostname.vr3</b>
</pre></blockquote>

Then create the <tt>vether0</tt> configuration:

<blockquote><pre>
# <b>echo 'inet 192.168.1.1 255.255.255.0 192.168.1.255' > /etc/hostname.vether0</b>
</pre></blockquote>

We configure the bridge interface to contain all the above interfaces:

<blockquote><pre>
$ <b>cat /etc/hostname.bridge0</b>
add vether0
add vr1
add vr2
add vr3
up
</pre></blockquote>

And finally we make dhcpd(8) listen on the vether0 interface:

<blockquote><pre>
# <b>rcctl set dhcpd flags vether0</b>
</pre></blockquote>

Reboot, and voil&agrave;!

<h3>Filtering on a bridge</h3>

While there are certainly uses for a simple bridge like this, it is likely you
might want to DO something with the packets as they go through your bridge.
As you might expect, <a href="#PF">Packet Filter</a> can be used to restrict
what traffic goes through your bridge.

<p>
Keep in mind, by the nature of a bridge, the same data flows through both
interfaces, so you only need to filter on one interface.
Your default "pass all" statements would look something like this:

<blockquote><pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre></blockquote>

Now, let's say I wish to filter traffic hitting these old machines.
I want only web and SSH traffic to reach them.
In this case, we are going to let all traffic in and out of the <tt>ep0</tt>
interface, but filter on the <tt>fxp0</tt> interface.

<blockquote><pre>
# Pass all traffic through ep0
pass in  quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port { 22 80 }
</pre></blockquote>

Note that this rule set will prevent anything but incoming HTTP and SSH traffic
from reaching either the bridge machine or any of the other nodes "behind" it.
Other results could be had by filtering the other interface.

<p>
To monitor and control the bridge you have created, use the
<a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> command, which can
also be used to create a bridge after boot.

<h3>Tips on bridging</h3>

<ul>
  <li>It is <b>highly</b> recommended that you filter on only one interface.
    While it is possible to filter on both, you really need to understand this
    very well to do it right.

  <li>By using the <tt>blocknonip</tt> option of
    <a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> or in
    <a href="http://man.openbsd.org/hostname.if">hostname.bridge0</a>, you can
    prevent non-IP traffic (such as IPX or NETBEUI) from slipping around your
    filters.
    This may be important in some situations, but you should be aware that
    bridges work for all kinds of traffic, not just IP.

  <li>Bridging requires that the NICs be in a "promiscuous mode" -- they listen
    to ALL network traffic, not just that directed at the interface.
    This will put a higher load on the processor and bus than one might expect.
    Some NICs don't work properly in this mode -- the TI ThunderLAN chip is an
    example of a chip that won't work as part of a bridge.
</ul>

<h2 id="PXE">PXE booting (i386, amd64)</h2>

The Preboot Execution Environment, or PXE, is a way to boot a computer from the
network.
It is supported by most major network card manufacturers.
Traditionally, PXE booting is done using ROMs on the NIC or mainboard of the
system.

<p>
Familiarize yourself with OpenBSD's
<a href="faq14.html#BootAmd64">bootstrap procedure</a> first.
Upon starting the boot process, the PXE-capable NIC broadcasts a DHCP request
over the network.
The DHCP server will assign the adapter an IP address.
Then it will specify the name of a file to be retrieved from the tftp server
<a href="http://man.openbsd.org/tftpd">tftpd(8)</a> and then execute it.
This file then conducts the rest of the boot process.
On OpenBSD, this file is known as
<a href="http://man.openbsd.org/pxeboot">pxeboot(8)</a>, and it takes the
place of the standard <a href="http://man.openbsd.org/boot">boot(8)</a> file.
pxeboot(8) is then able to load and execute a kernel from the same TFTP server.

<p>
Details on how to set up PXE booting can be found in the
<a href="http://man.openbsd.org/pxeboot">pxeboot(8)</a> manual.
See also <a href="http://man.openbsd.org/tftpd">tftpd(8)</a>.

<h2 id="OpenNTPD">Using OpenNTPD</h2>

<a href="http://www.openntpd.org">OpenNTPD</a> is a trivial-to-administer, safe
and simple NTP-compatible way to have accurate time on your computer.
OpenBSD's <a href="http://man.openbsd.org/ntpd">ntpd(8)</a> is controlled with a
simple configuration file,
<a href="http://man.openbsd.org/ntpd.conf">ntpd.conf(5)</a>.

<p>
The OpenNTPD daemon is enabled by default at install time, which results in your
computer's clock slowly moving into synchronization with the
<a href="http://www.pool.ntp.org">pool.ntp.org</a> time servers.
Once your clock is accurately set, <tt>ntpd</tt> will hold it at a high degree
of accuracy.
However, if your clock is more than a few minutes off, it is recommended that
you bring it close to accurate initially, as it may take days or weeks to bring
a very-off clock to sync.
You can do this using the <tt>-s</tt> option of ntpd(8) or any other way to
accurately set your system clock.

<h3 id="OpenNTPDNoServe">Why can't my other machines synchronize to ntpd?</h3>

OpenNTPD does not listen on any address by default.
In order to use it as a server, you have to add a <tt>listen on *</tt> line to
<a href="http://man.openbsd.org/ntpd.conf">/etc/ntpd.conf</a> and restart the
daemon.
Of course, if you want it to listen on a particular IP address rather than all
available addresses and interfaces, replace the "*" with the desired address.

<p>
When you have ntpd(8) listening, it may happen that other machines still can't
synchronize to it!
A freshly started ntpd(8) daemon (for example, if you just restarted it after
modifying ntpd.conf) refuses to serve time information to other clients until
it adjusts its own clock to a reasonable level of stability first.
When ntpd(8) considers its own time information stable, it announces it by a
"clock now synced" message in <tt>/var/log/daemon</tt>.
Even if the system clock is pretty accurate in the beginning, it can take up to
10 minutes to get in sync, and hours or days if the clock is not accurately set
at the start.

<h2 id="Wireless">Wireless networking</h2>

OpenBSD has support for
<a href="http://man.openbsd.org/?query=wireless&amp;apropos=1">
a number of wireless chipsets</a>.
Further supported devices can be found in the
<a href="http://man.openbsd.org/usb">usb(4)</a> and
<a href="http://man.openbsd.org/pci">pci(4)</a> man pages.
Please see the man pages for precise details.
The following cards support "host-based access point" mode.
This permits them to be made into the wireless access point.
<ul>
  <li><a href="http://man.openbsd.org/acx">acx(4)</a>
    TI ACX100/ACX111
  <li><a href="http://man.openbsd.org/ath">ath(4)</a>
    Atheros 802.11a/b/g
  <li><a href="http://man.openbsd.org/athn">athn(4)</a>
    Atheros 802.11/a/g/n devices
  <li><a href="http://man.openbsd.org/pgt">pgt(4)</a>
    Conexant/Intersil Prism GT Full-MAC 802.11a/b/g
  <li><a href="http://man.openbsd.org/ral">ral(4)</a>
    and <a href="http://man.openbsd.org/ural">ural(4)</a>
    Ralink Technology RT25x0 802.11a/b/g
  <li><a href="http://man.openbsd.org/rtw">rtw(4)</a>
    Realtek 8180 802.11b
  <li><a href="http://man.openbsd.org/rum">rum(4)</a>
    Ralink Technology RT2501USB
  <li><a href="http://man.openbsd.org/wi">wi(4)</a>
    Prism2/2.5/3
</ul>

The <a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> <tt>media</tt>
subcommand shows media capabilities of network interfaces.
For wireless devices, it displays supported 802.11a/b/g/n media modes and the
supported operating modes (hostap, ibss, monitor).
For example, to see media capabilities of interface <tt>ath0</tt>, type:

<blockquote><pre>
$ <b>ifconfig ath0 media</b>
</pre></blockquote>

Adapters based on supported chips can be used much like any other network
adapter.
To connect an OpenBSD system to an existing wireless network, use the
<a href="http://man.openbsd.org/ifconfig">ifconfig(8)</a> utility.

<p>
Note that in order to use some of these cards, you will need to acquire the
firmware files, which the manufacturers refuse to allow
<a href="faq1.html#ReallyFree">free</a> distribution of, so they can not be
included with OpenBSD.
When possible, the man pages linked above include contact information so you can
contact the right people at the manufacturers to let them know what you feel
about this, or to let them know what other product you have purchased instead.

<p>
Another option to consider for using your OpenBSD-based firewall to provide
wireless access is to use a conventional NIC and an external bridging access
point.
This has the added advantage of letting you easily position the antenna where it
is most effective, which is often not directly on the back of your firewall.

<h3>Configuring your wireless adapter</h3>

Your wireless adapter can be configured through a
<a href="http://man.openbsd.org/hostname.if">hostname.if(5)</a> file as other
network adapters are.

<p>
An example of a wireless hostname file might be:

<blockquote><pre>
nwid puffyuberalles
wpakey puffyguffy
dhcp
</pre></blockquote>

or

<blockquote><pre>
inet 10.0.0.157 255.255.255.0
nwid puffyuberalles
wpakey puffyguffy
</pre></blockquote>

Note that the <tt>dhcp</tt> should be AFTER the other configuration lines, as
the network adapter will not be able to request the DHCP until it is configured.

<h3>trunk(4)ing your wireless adapter</h3>

Many laptops have both a wireless and a hard-wired adapter.
Sometimes, you may be directly connected to your high speed network and want the
full performance of the wire, other times, you will be using the wireless.
You probably don't want to reconfigure your machine each time you switch
locations.

<p>
You could set up both interfaces with DHCP, but then you would have to wait for
the unused interface to time out while booting, plus things would be a little
confusing if you had both resources available, and switching between the two
resources would be a bit annoying.

<p>
Using a <a href="http://man.openbsd.org/trunk">trunk(4)</a> device may simplify
your life.
Trunks are virtual interfaces made up of one or more other network interfaces.
In this case, we will use a laptop with a wired
<a href="http://man.openbsd.org/bge">bge0</a> and a wireless
<a href="http://man.openbsd.org/iwn">iwn0</a> interface.
Using these two interfaces we will build an interface, <tt>trunk0</tt>, then use
DHCP to get an IP address for this virtual interface.
If we have a cable available, we want to use it, but if not we want to use the
wireless interface.

<p>
To do this, we first configure the two physical ports.
As we are just assigning them to a combined trunk0 interface, we won't do much
of anything with the wired interface other than activate it:

<blockquote><pre>
# <b>echo up > /etc/hostname.bge0</b>
</pre></blockquote>

The wireless interface, however, needs a bit more configuration.
It will need to attach to our wireless WPA-protected network:

<blockquote><pre>
$ <b>cat /etc/hostname.iwn0</b>
nwid puffynet
wpakey mysecretkey
up
</pre></blockquote>

Now, our trunk interface is defined like this:

<blockquote><pre>
$ <b>cat /etc/hostname.trunk0</b>
trunkproto failover trunkport bge0
trunkport iwn0
dhcp
</pre></blockquote>

The trunk is set up to be in "failover" mode, so either interface can be used.
If both are available, it will prefer the <tt>bge0</tt> port, since that is the
first one added to the trunk device.

<h2 id="Multipath">Equal-cost multipath routing</h2>

Equal-cost multipath routing refers to having multiple routes in the routing
table for the same network, such as the default route, 0.0.0.0/0.
When the kernel is doing a route lookup to determine where to send packets
destined to that network, it can choose from any of the equal-cost routes.
In most scenarios, multipath routing is used to provide redundant uplink
connections, e.g., redundant connections to the internet.

<p>
The <a href="http://man.openbsd.org/route">route(8)</a> command is used to
add/change/delete routes in the routing table.
The <tt>-mpath</tt> argument is used when adding multipath routes.

<blockquote><pre>
# <b>route add -mpath default 10.130.128.1</b>
# <b>route add -mpath default 10.132.0.1</b>
</pre></blockquote>

Verify the routes:

<blockquote><pre>
# <b>netstat -rnf inet | grep default</b>
default     10.130.128.1      UGS       2      134      -     fxp1
default     10.132.0.1        UGS       0      172      -     fxp2
</pre></blockquote>

In this example we can see that one default route points to 10.130.128.1, which
is accessible via the <tt>fxp1</tt> interface, and the other points to
10.132.0.1, which is accessible via <tt>fxp2</tt>.

<p>
Since the <a href="http://man.openbsd.org/mygate">mygate(5)</a> file does not
yet support multipath default routes, the above commands should be added to the
bottom of the <a href="http://man.openbsd.org/hostname.if">hostname.if(5)</a>
files for the <tt>fxp1</tt> and <tt>fxp2</tt> interfaces.
The <tt>/etc/mygate</tt> file should then be deleted.

<blockquote><pre>
$ <b>tail -1 /etc/hostname.fxp1</b>
!route add -mpath default 10.130.128.1
$ <b>tail -1 /etc/hostname.fxp2</b>
!route add -mpath default 10.132.0.1
</pre></blockquote>

Lastly, don't forget to activate the use of multipath routes by enabling the
proper sysctl(3) variable.

<blockquote><pre>
# <b>sysctl net.inet.ip.multipath=1</b>
# <b>sysctl net.inet6.ip6.multipath=1</b>
</pre></blockquote>

Be sure to edit <a href="http://man.openbsd.org/sysctl.conf">sysctl.conf(5)</a>
to make the changes permanent.

<p>
Now try a traceroute to different destinations.
The kernel will load balance the traffic over each multipath route.

<blockquote><pre>
# <b>traceroute -n 154.11.0.4</b>
traceroute to 154.11.0.4 (154.11.0.4), 64 hops max, 60 byte packets
 1  10.130.128.1  19.337 ms  18.194 ms  18.849 ms
 2  154.11.95.170  17.642 ms  18.176 ms  17.731 ms
 3  154.11.5.33  110.486 ms  19.478 ms  100.949 ms
 4  154.11.0.4  32.772 ms  33.534 ms  32.835 ms

# <b>traceroute -n 154.11.0.5</b>
traceroute to 154.11.0.5 (154.11.0.5), 64 hops max, 60 byte packets
 1  10.132.0.1  14.175 ms  14.503 ms  14.58 ms
 2  154.11.95.38  13.664 ms  13.962 ms  13.445 ms
 3  208.38.16.151  13.964 ms  13.347 ms  13.788 ms
 4  154.11.0.5  30.177 ms  30.95 ms  30.593 ms
</pre></blockquote>

For more information about how the route is chosen, please refer to
<a href="http://www.ietf.org/rfc/rfc2992.txt">RFC2992</a>, "Analysis of an
Equal-Cost Multi-Path Algorithm".

<p>
It's worth noting that if an interface used by a multipath route goes down
(i.e., loses carrier), the kernel will still try to forward packets using the
route that points to that interface.
This traffic will of course be blackholed and end up going nowhere.
It's highly recommended to use
<a href="http://man.openbsd.org/ifstated">ifstated(8)</a> to check for
unavailable interfaces and adjust the routing table accordingly.

<p>
</body>
</html>
