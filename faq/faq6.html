<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Networking</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "description"   content= "OpenBSD FAQ 6 - Networking">
<meta name= "copyright"     content= "This document copyright 1998-2016 by OpenBSD.">
<link rel="canonical" href="http://www.openbsd.org/faq/faq6.html">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<a href="../index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif" border="0">
</a>
<p>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[To Section 5 - Building the System from Source]</a>
<a href="faq7.html">[To Section 7 - Keyboard and Display Controls]</a>
</font>

<h1><font color="#e00000">6 - Networking</font></h1>
<hr>

<p>
<h3>Table of Contents</h3>
<ul>
<li><a href= "#Intro"          >6.1 - Background</a>
<li><a href= "#Setup"          >6.2 - Network configuration</a>
<ul>
  <li><a href="#Setup.if"      >6.2.1 - Identifying and setting up your
                                network interfaces</a>
  <li><a href="#Setup.gateway" >6.2.2 - Default gateway</a>
  <li><a href="#Setup.resolver">6.2.3 - DNS resolution</a>
  <li><a href="#Setup.myname"  >6.2.4 - Host name</a>
  <li><a href="#Setup.activate">6.2.5 - Activating the changes</a>
  <li><a href="#Setup.chkroute">6.2.6 - Checking routes</a>
  <li><a href="#Setup.forward" >6.2.7 - Setting up your OpenBSD box as
                                a gateway</a>
  <li><a href="#Setup.aliases" >6.2.8 - Setting up aliases on interfaces</a>
  <li><a href="#Setup.replace" >6.2.9 - Adding and replacing NICs</a>
</ul>
<li><a href= "#PF"             >6.3 - How do I filter and firewall with
                                OpenBSD?</a>
<li><a href= "#DHCP"           >6.4 - Dynamic Host Configuration Protocol
                                (DHCP)</a>
<ul>
  <li><a href="#DHCPclient"    >6.4.1 - DHCP client</a>
  <li><a href="#DHCPserver"    >6.4.2 - DHCP server</a>
</ul>
<li><a href= "#Tuning"         >6.6 - Tuning networking parameters</a>
<li><a href= "#NFS"            >6.7 - Using NFS</a>
<li><a href= "#Bridge"         >6.9 - Setting up a bridge with OpenBSD</a>
<li><a href= "#PXE"            >6.10 - How do I boot using PXE?</a>
<li><a href= "#CARP"           >6.11 - Common Address Redundancy Protocol
                                (CARP)</a>
<li><a href="#OpenNTPD"        >6.12 - Using OpenNTPD</a>
<li><a href="#Wireless"        >6.13 - What are my wireless networking
                                options?</a>
<li><a href="#Multipath"       >6.14 - How can I do equal-cost multipath
                                routing?</a>
</ul>

<hr>

<h2 id="Intro">6.1 - Background</h2>

For the bulk of this document, it helps if you have read and at least partially
understand the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a>
and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat">netstat(1)</a>
man pages.

<p>
If you are a network administrator, setting up routing protocols, using
your OpenBSD box as a router or want to go in-depth into IP networking,
you really need to read
<a href="http://www.scribd.com/doc/52483921/3Com-Understanding-IP-Addressing">
Understanding IP Addressing</a>.
This is an excellent document.  "Understanding IP Addressing" contains
fundamental knowledge to build upon when working with IP networks,
especially when you deal with or are responsible for more than one
network.

<p>
If you are working with applications such as web servers, ftp servers
and mail servers, you may benefit greatly by reading
<a href="http://www.rfc-editor.org/rfc.html">the RFCs</a>.
Most likely, you can't read all of them.  Pick some topics that you are
interested in or that you use in your network environment.  Look them
up, find out how they are intended to work.  The RFCs define many
(thousands of) standards for protocols on the Internet and how they are
supposed to work.

<h2 id="Setup">6.2 - Network configuration</h2>

Normally, OpenBSD's network settings are initially configured by the 
<a href="faq4.html">installation</a> process.
However, it is good to understand what is happening in this process and
how it works.
All network configuration is done using simple text files in the
<tt>/etc</tt> directory.

<h3 id="Setup.if">6.2.1 - Identifying and setting up your network interfaces
</h3>

<p>
In OpenBSD, interfaces are named for the type of card, not for the type of
connection. You can see your network card get initialized during the
booting process, or after the booting process using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg">dmesg(8)</a>
command.
For example, here is the part of dmesg for a Intel Fast Ethernet
network card, which uses the device name <tt>fxp</tt>.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

This device uses the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp">fxp(4)</a>
driver, and is assigned the number 0 here.
The number is assigned based on various criteria, depending upon the
card and other details of the system.
In most cases with today's common hardware, cards are assigned by the order
they are found during bus probing. The first fxp found will be <tt>fxp0</tt>,
second will be <tt>fxp1</tt> and so on.
Users of unusual or very old hardware (ISA) may find devices numbered by
hardware resource settings (ISA ne2 is I/O 280 IRQ 9 even if there is no
ne1 or ne0), or MAC address.

<p>
You can find out what network interfaces have been identified by using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a>
utility. The following command will show all network interfaces on a
system.  This sample output shows us only one physical Ethernet interface,
an <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp">fxp(4)</a>.

<blockquote><pre>
$ <b>ifconfig</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33200
        priority: 0
        groups: lo
        inet 127.0.0.1 netmask 0xff000000
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        lladdr 00:04:ac:dd:39:6a
        priority: 0
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
enc0: flags=0&lt;&gt;
        priority: 0
        groups: enc
        status: active
pflog0: flags=141&lt;UP,RUNNING,PROMISC&gt; mtu 33200
        priority: 0
        groups: pflog
</pre></blockquote>

<p>
As you can see here, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a> 
gives us a lot more information than we need at this point. But, it
still allows us to see our interface. In the above example, the
interface card is already configured. This is obvious because an IP
network is already configured on fxp0, hence the values &quot;inet
10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;.  Also, the
<b>UP</b> and <b>RUNNING</b> flags are set.

<p>
Finally, you will notice several other interfaces come enabled by
default.  These are virtual interfaces that serve various functions.
The following manual pages describe them:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo">lo</a>
 - loopback interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog">pflog</a>
 - Packet Filter logging interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc">enc</a>
 - encapsulating interface
</ul>

Other virtual interfaces are automatically created on demand, including:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl">sl</a>
 - SLIP network interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp">ppp</a>
 - Point-to-Point Protocol interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun">tun</a>
 - Tunnel network interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge">bridge</a>
 - Ethernet bridge interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan">vlan</a>
 - IEEE 802.1Q encapsulation interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=svlan">svlan</a>
 - IEEE 802.1AD provider bridges (QinQ)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre">gre</a>
 - GRE/MobileIP encapsulation interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif">gif</a>
 - Generic IPv4/IPv6 tunnel interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp">carp</a>
 - Common Address Redundancy Protocol interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mpe">mpe</a>
 - MPLS Provider Edge
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vether">vether</a>
 - Virtual Ethernet interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=trunk">trunk</a>
 - Link aggregation and link failover interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vxlan">vxlan</a>
 - Virtual eXtensible Local Area Network tunnel Interface
</ul>

<p>
Interfaces are configured at boot time using /etc/hostname.<i>if</i> files,
where <i>if</i> is replaced by the full name of each interface.
Each interface has its own file.
The example above would use the file <tt>/etc/hostname.fxp0</tt>.

<p>
The layout of this file is simple:

<blockquote><pre>
address_family address netmask broadcast [other options]
</pre></blockquote>

Much more detail about the format of this file can be found in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if">
hostname.if(5)</a> man page.
You will need to read this for less trivial configurations.

<p>
A typical interface configuration file, configured for an IPv4 address,
would look like this:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
In this case, we have defined an IPv4 (inet) address, with an IP address of 
10.0.0.38, a subnet mask of 255.255.255.0 and no specific broadcast address
(which will default to 10.0.0.255 in this case).

<p>
You could also specify media types for Ethernet, say, if you wanted to
force 100baseTX full-duplex mode.

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
Of course, you should never force full duplex mode unless both sides of
the connection are set to do this! In the absence of special needs,
media settings should be excluded. 
A more likely case might be to force 10base-T or half duplex when your
infrastructure requires it.

<p>
You may also want to use special flags specific to a certain interface.
The format of the hostname file doesn't change much.

<blockquote><pre>
$ <b>cat /etc/hostname.vlan0</b>
inet 172.21.0.31 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<h3 id="Setup.gateway">6.2.2 - Default gateway</h3>

Put the IP of your gateway in the file <tt>/etc/mygate</tt>.
This will allow for your gateway to be set upon boot.
This file consists of one line, with just the address of this machine's
gateway address.

<p>
It is possible to use a symbolic name there, but be careful. You can't
assume things like the resolver are fully configured (or even reachable)
until AFTER the default gateway is configured.
In other words, it had better be an IP address or something that is
defined in the <tt>/etc/hosts</tt> file.

<h3 id="Setup.resolver">6.2.3 - DNS Resolution</h3>

DNS resolution is controlled by the file
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf">
resolv.conf(5)</a>.
Here is an example of the <tt>/etc/resolv.conf</tt> file:

<blockquote><pre>
$ <b>cat /etc/resolv.conf</b>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

In this case, the default domain name will be <tt>example.com</tt>,
there are two DNS resolvers, <tt>125.2.3.4</tt> and <tt>125.2.3.5</tt>
specified, and the <tt>/etc/hosts</tt> file will be consulted before the
DNS resolvers are.

<p>
As with virtually all Unix (and many non-Unix) systems, there is a 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts">hosts(5)</a>
file that can be used to specify systems that are not in (or if used
with the above "lookup" priority, not as desired in) the formal DNS
system.

<p>
If you are using DHCP, you'll want to read <a href="#DHCP">6.4 - DHCP</a>,
taking note of
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail">
resolv.conf.tail(5)</a>.

<h3 id="Setup.myname">6.2.4 - Host name</h3>

Every Unix machine has a name.
In OpenBSD, the name is specified as a "Fully Qualified Domain Name" (FQDN)
on one line in the file <tt>/etc/myname</tt>.
If this machine is named "puffy" and in the domain example.com, the
file would contain:

<blockquote><pre>
$ <b>cat /etc/myname</b>
puffy.example.com
</pre></blockquote>

<h3 id="Setup.activate">6.2.5 - Activating the changes</h3>

From here, you can either reboot or run the <tt>/etc/netstart</tt> script.
You can do this by simply typing (as root):

<blockquote><pre>
# <b>sh /etc/netstart</b>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Notice that a few errors were produced.  By running this script, you are
reconfiguring things which are already configured.  As such, some routes
already exist in the kernel routing table.  From here, your system should
be up and running. Again, you can check to make sure that your interface
was set up correctly with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a>.

<p>
Even though you can completely reconfigure networking on an OpenBSD
system without rebooting, a reboot is HIGHLY recommended after any
significant reconfiguration.
The reason for this is that the environment at boot is somewhat different
than it is when the system is completely up and running.
For example, if you had specified a DNS-resolved symbolic name in any of
the files, you would probably find it worked as expected after
reconfigure. On initial boot, however, your external resolver may not be
available, so the configuration will fail.

<h3 id="Setup.chkroute">6.2.6 - Checking routes</h3>

You can check your routes via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat">netstat(1)</a>
or <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route">route(8)</a>.
If you are having routing problems, you may want to use the <tt>-n</tt> flag
to route(8), which prints the IP addresses rather than doing a DNS lookup
and displaying the hostname.  Here is an example of viewing your routing
tables using both programs.

<blockquote><pre>
$ <b>netstat -rn</b>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <b>route show</b>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<h3 id="Setup.forward">6.2.7 - Setting up your OpenBSD box as a forwarding
gateway</h3>

<p>
This is covered in more detail <a href="pf/example1.html">here</a>.

<h3 id="Setup.aliases">6.2.8 - Setting up aliases on an interface</h3>

<p>
OpenBSD has a simple mechanism for setting up IP aliases on an
interface. To do this, simply edit the file <tt>/etc/hostname.<i>if</i></tt>.
This file is read upon boot by the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstart">netstart(8)</a>
script, which is part of the <a href="faq10.html#rc">rc startup hierarchy</a>.
For the example, we assume that the user has an
interface <tt>dc0</tt> and is on the network 192.168.0.0. Other important
information:

<ul>
<li>IP for dc0 is 192.168.0.2
<li>NETMASK is 255.255.255.0
</ul>

<p>
A few side notes about aliases. In OpenBSD you use the interface name
only. There is no difference between the first alias and the second
alias. Unlike some other operating systems, OpenBSD doesn't refer to
them as dc0:0, dc0:1. If you are referring to a specific aliased IP
address with <tt>ifconfig</tt>, or adding an alias, be sure to uaw
<tt>ifconfig int alias</tt> instead of just <tt>ifconfig int</tt> at
the command line. You can delete aliases with <tt>ifconfig int delete</tt>.

<p>
Assuming you are using multiple IP addresses which are in the same IP
subnet with aliases, your netmask setting for each alias becomes
255.255.255.255.  They do not need to follow the netmask of the first IP
bound to the interface.  In this example, <tt>/etc/hostname.dc0</tt>, two
aliases are added to the device <tt>dc0</tt>, which was configured as
192.168.0.2 netmask 255.255.255.0.

<blockquote><pre>
$ <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 NONE media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

Once you've made this file, it just requires a reboot for it to take
effect. You can, however, bring up the aliases by hand using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a>
utility. To bring up the first alias, you would use the command:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

(but again, a reboot is recommended to make sure you entered everything
as you expected it to be!)

<p>
To view these aliases, you must use the command:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>

<h3 id="Setup.replace">6.2.9 - Adding and replacing NICs</h3>

You may have to replace or add a network adapter on an OpenBSD system,
maybe upgrading the capabilities of the system or repairing failed
hardware.
This will require some reconfiguration.
The good news is that it's relatively easy, though there are some things
to be aware of.

<p>
The key is understanding how OpenBSD names NICs.
Unlike some OSs that try to remember any network adapter the installed
OS has ever seen, OpenBSD does not remember a NIC's identification
between boots -- it names them in order that they are found.
In most cases, this is far simpler for you, as the system will always
identify a NIC the same way in the same hardware configuration, and
when configurations change, the results are easily understood.

<p>
Here are some cases:

<ul>
<li><b>Replace a NIC with an identical device:</b> This would be the
case when you move the disk system from a failed machine to another
identical machine, or install an image or full backup to identical
hardware.
In this case, things are easy -- no change in configuration will be
needed, other than perhaps changing the IP address in the
<tt>hostname.if</tt> if needed.

<li><b>Replace a NIC with a different device:</b> This would also be
the case when one moves a disk system to a non-identical machine.
In this case, simply rename the old <tt>hostname.<i>if</i></tt> file to match
the new device.
For example, if you replace an
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp4">fxp(4)</a>
device which was <tt>fxp0</tt> (first fxp) with a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=re">re(4)</a>
device, which would end up as <tt>re0</tt>, 
you could rename <tt>/etc/hostname.fxp0</tt> to <tt>/etc/hostname.re0</tt>
and your new device would take over the configuration of the old device.
If you might someday restore the original configuration, you may prefer
to make the new file a hard link to the original, rather than renaming it.

<li><b>Replacing one of several similar cards with a different type:</b>
Let's assume you have a machine with <tt>fxp0</tt>, <tt>fxp1</tt> and
<tt>fxp2</tt>, and <tt>fxp0</tt> fails.
Unfortunately, you don't have a spare similar fxp card, so you need to
replace it with an
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=em">em(4)</a>
card.
This gets a little ugly, as <tt>fxp1</tt> and <tt>fxp2</tt> will rename
themselves:

<blockquote><pre>
<b>old  -> new</b>
fxp0 -> em0
fxp1 -> fxp0
fxp2 -> fxp1
</pre></blockquote>

Again, rename your <tt>/etc/hostname.<i>if</i></tt> files accordingly:

<blockquote><pre>
# <b>cd /etc</b>
# <b>mv hostname.fxp0 hostname.em0</b>
# <b>mv hostname.fxp1 hostname.fxp0</b>
# <b>mv hostname.fxp2 hostname.fxp1</b>
</pre></blockquote>


<li><b>Adding a new NIC to an existing system:</b> 
If your added NIC is of a different type, it will be the "0" device of
whatever driver it is.
For example, if you are adding a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bge">bge(4)</a>
device to a machine with only a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rl">rl(4)</a>
device, life is easy -- the new device will be <tt>bge0</tt>, create an
appropriate <tt>/etc/hostname.bge0</tt>.

<p>
The more difficult variation is when you are adding a new card of the
same type as another in the machine.
Most add-on NICs will have the MAC address of the card somewhere written
on the card.  Make note of this, insert the card, and look at the dmesg.
Note the identifier of the new NIC and its relationship to the earlier NICs.
You may find that ALL the existing NICs have changed number.
You may be able to put the new NIC in a different slot to change the
identifier as desired, but if the earlier devices were onboard, you
may have no options, and have to adjust the <tt>hostname.<i>if</i></tt>
files.

<li><b>Total Confusion:</b>  Sometimes, things get totally confused.
Maybe your new machine has lots of multi-port NICs, or several onboard
NICs and you aren't quite sure how they are identified, or changes were
made with less care than might be hoped for, and now you aren't sure
what is what.

<p>
The first thing to note is that
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a>
will tell you both the MAC address and the link status of each port.
So the first trick might be to mark add-in cards with their MAC addresses.
Another trick in a confused situation can be to simply attach ONE unknown
NIC to a switch port at a time, and look for which NIC in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a>
is now showing a link.
Once you have a few ports identified, you will often figure out the rest
quickly.

</ul>

In addition to the <tt>hostname.<i>if</i></tt> files, any other file that deals
with hardware interfaces will have to be adjusted.
Some likely candidates might include:

<ul>
<li>PF configuration (<tt>/etc/pf.conf</tt>)
<li>CARP configuration (<tt>/etc/hostname.carp*</tt>)
<li>Bridge configuration (<tt>/etc/hostname.bridge*</tt>)
<li>Trunk configuration (<tt>/etc/hostname.trunk*</tt>)
</ul>

<h2 id="PF">6.3 - How do I filter and firewall with OpenBSD?</h2>

Packet Filter (from here on referred to as PF) is OpenBSD's system for
filtering IP traffic and doing Network Address Translation. PF is
also capable of normalizing and conditioning IP traffic,
providing bandwidth control and packet prioritization, and can be used
to create powerful and flexible firewalls.
It is described in the <a href="pf/index.html">PF User's Guide</a>.

<h2 id="DHCP">6.4 - Dynamic Host Configuration Protocol (DHCP)</h2> 

Dynamic Host Configuration Protocol is a way to configure network
interfaces "automatically."
OpenBSD can be a DHCP server (configuring other machines), a DHCP client
(configured by another machine) or, in some cases, both.

<h3 id="DHCPclient">6.4.1 - DHCP client</h3>

<p>
To use the DHCP client included with OpenBSD,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient">
dhclient(8)</a>, edit <tt>/etc/hostname.xl0</tt>. This is assuming
your main Ethernet interface is <tt>xl0</tt>.
Yours might be <tt>em0</tt> or <tt>fxp0</tt> or something else.

<blockquote><pre>
# <b>echo dhcp > /etc/hostname.xl0</b>
</pre></blockquote>

<p>
This will cause OpenBSD to automatically start the DHCP client on boot.
OpenBSD will gather its IP address, default gateway, and DNS servers
from the DHCP server.

<p>
If you want to start a DHCP client from the command line, make sure
<tt>/etc/dhclient.conf</tt> exists, then run:

<blockquote><pre>
# <b>dhclient xl0</b>
</pre></blockquote>

Where <tt>xl0</tt> is the interface on which you want to receive DHCP.

<p>
No matter how you start the DHCP client, you can edit the
<tt>/etc/dhclient.conf</tt> file to <b>not</b> update your DNS according to the
DHCP server's idea of DNS by first uncommenting the "request" lines in it.
They are examples of the default settings, but you need to uncomment
them to override dhclient's defaults.

<blockquote><pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre></blockquote>

Then remove <tt>domain-name-servers</tt>.
Of course, you may want to remove <tt>host-name</tt>, or other settings too.

<p>
By changing options in your 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf">
dhclient.conf(5)</a>
file, you're telling the DHCP client how to build your
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf">
resolv.conf(5)</a> file.
The DHCP client overrides any information you already have in
resolv.conf with the information it retrieves from the DHCP server.
Therefore, you'll lose any changes you made manually to resolv.conf.

<p>
There are two mechanisms available to prevent this:

<ul>
<li>
Option modifiers (<tt>default</tt>, <tt>supersede</tt>, <tt>prepend</tt>
and <tt>append</tt>) allow you to override any of the options in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf">
dhclient.conf(5)</a>.

<li>
The
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail">
resolv.conf.tail(5)</a>
file allows you to append anything you want to the resolv.conf file
created by dhclient.
</ul>

<p>
An example would be if you're using DHCP but want to append
<tt>lookup file bind</tt> to the resolv.conf created by dhclient.
There is no option for this in <tt>dhclient.conf</tt>, so you must use
<tt>resolv.conf.tail</tt> to preserve this.

<blockquote><pre>
# <b>echo "lookup file bind" > /etc/resolv.conf.tail</b>
</pre></blockquote>

Now your resolv.conf should include "lookup file bind" at the end.

<blockquote><pre>
$ <b>cat /etc/resolv.conf</b>
nameserver 192.168.1.1
nameserver 192.168.1.2
lookup file bind
</pre></blockquote>

<h3 id="DHCPserver">6.4.2 - DHCP server</h3>

<p>
If you want to use OpenBSD as a DHCP server, enable the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd">dhcpd(8)</a>
daemon at startup. For example:

<blockquote><pre>
# <b>rcctl enable dhcpd</b>
</pre></blockquote>

This will run dhcpd and attach to all NICs which have valid configurations
in <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf">
dhcpd.conf(5)</a>.
You may specify individual interfaces instead by naming them explicitly.
For example:

<blockquote><pre>
# <b>rcctl set dhcpd flags xl1 xl2 xl3</b>
</pre></blockquote>

<p>
Then edit <tt>/etc/dhcpd.conf</tt>. The options are pretty self-explanatory.

<blockquote><pre>
option  domain-name "example.com";
option  domain-name-servers 192.168.1.3, 192.168.1.5;
subnet 192.168.1.0 netmask 255.255.255.0 {
        option routers 192.168.1.1;
        range 192.168.1.32 192.168.1.127;
}
</pre></blockquote>

This will tell your DHCP clients that the domain to append to DNS
requests is example.com (so, if the user types in 'telnet joe' then it
will send them to joe.example.com).  It will point them to DNS servers
192.168.1.3 and 192.168.1.5.  For hosts that are on the same network as
an Ethernet interface on the OpenBSD machine, which is in the
192.168.1.0/24 range, it will assign them an IP address between
192.168.1.32 and 192.168.1.127.  It will set their default gateway as
192.168.1.1.

<p>
If you want to start dhcpd(8) from the command line after editing
<tt>/etc/dhcpd.conf</tt>, run:

<blockquote><pre>
# <b>rcctl start dhcpd</b>
</pre></blockquote>

If there were fatal configuration errors, it will exit and let you know
that it failed to start. You can usually see why in <tt>/var/log/messages</tt>
or <tt>/var/log/daemon</tt>.

<p>
If you are serving DHCP to a Windows box, you may want dhcpd(8) to give
the client a 'WINS' server address.  To make this happen, just add the
following line to your <tt>/etc/dhcpd.conf</tt>:

<blockquote><pre>
option    netbios-name-servers    192.168.92.55;
</pre></blockquote>

where <tt>192.168.92.55</tt> is the IP of your Windows or Samba server.
See <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options">
dhcp-options(5)</a> for more options that your DHCP clients may want.

<h2 id="Tuning">6.6 - Tuning networking parameters</h2>

One goal of OpenBSD is to have the system <i>Just Work</i> for the vast
majority of our users.
Twisting knobs you don't understand is far more likely to break the
system than it is to improve its performance.
Always start from the default settings, and <i>only</i> adjust things
you actually see a problem with. VERY FEW people will need to adjust any
networking parameters!

<h3>6.6.1 - I don't want the kernel to dynamically allocate a certain
port</h3>

From <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl#EXAMPLES">
sysctl(8)</a>:

<blockquote><pre>
To set the list of reserved TCP ports that should not be allocated by the
kernel dynamically:

      # <b>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</b>

This can be used to keep daemons from stealing a specific port that
another program needs to function.  List elements may be separated by
commas and/or whitespace.

It is also possible to add or remove ports from the current list:

      # <b>sysctl net.inet.tcp.baddynamic=+748</b>
      # <b>sysctl net.inet.tcp.baddynamic=-871</b>
</pre></blockquote>

<h2 id="NFS">6.7 - Simple NFS usage</h2>

NFS, or the Network File System, is used to share a filesystem over the
network.

<p>
This section will go through the steps for a simple setup of NFS. This
example details a server on a LAN, with clients accessing NFS on the
LAN. It does not talk about securing NFS. We presume you have already
setup packet filtering or other firewalling protection to prevent
outside access.  If you are allowing outside access to your NFS server,
and you have any kind of sensitive data stored on it, we strongly
recommend that you employ IPsec.  Otherwise, people can potentially see
your NFS traffic.  Someone could also pretend to be the IP address which
you are allowing into your NFS server.  There are several attacks that
can result.  When properly configured, IPsec protects against these
types of attacks.

<h3>Setting up an NFS server</h3>

These services must be enabled and running on the server:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap">
portmap(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd">
mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd">
nfsd(8)</a>
</ul>

<p>
By default, each of these is disabled in OpenBSD. If you want them enabled,
run the following commands:

<blockquote><pre>
# <b>rcctl enable portmap mountd nfsd</b>
# <b>rcctl set nfsd flags -tun 4</b>
</pre></blockquote>

The next step is to configure the list of filesystems that will be made
available for clients to mount.

<p>
In this example, we have a server with IP address 10.0.0.1.
This server will be serving NFS only to clients within its own subnet.
All of this is configured in the <tt>/etc/exports</tt> file.
This file lists which filesystems you wish to have accessible via NFS
and defines who is able to access them.
There are many options that you can use in <tt>/etc/exports</tt>; it is
best that you read the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports">exports(5)</a>
man page.
For our example server, we've setup an exports file that looks like this:

<blockquote><pre>
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network=10.0.0 -mask=255.255.255.0
</pre></blockquote>

This means that the local filesystem <tt>/work</tt> will be made
available via NFS.
The <tt>-alldirs</tt> option specifies that clients will be able
to mount at any point under <tt>/work</tt> as well as <tt>/work</tt>
itself.
For example, if there was a directory called <tt>/work/monday</tt>,
clients could mount <tt>/work</tt> (and have access to all
files/directories underneath that directory) or they could mount 
<tt>/work/monday</tt> and have access to just the files/directories
contained there.
The <tt>-ro</tt> option specifies that clients will only be granted
read-only access.
The last two arguments specify that only clients within the 10.0.0.0 network
using a netmask of 255.255.255.0 will be authorized to mount this
filesystem. This is important for some servers that are accessible by
different networks.

<p>
Another important security note: don't just add a filesystem to
<tt>/etc/exports</tt> without some kind of list of allowed host(s).
Without a list of hosts which can mount a particular directory, anyone
who can reach your server will be able to mount your NFS exported
directories.

<p>
Now you can start the server services.
You can either reboot (after enabling them as per the instructions
above) or start them manually.

<blockquote><pre>
# <b>rcctl start portmap mountd nfsd</b>
</pre></blockquote>

The <tt>nfsd_flags</tt> enable TCP (-t) and UDP (-u) connections and enable
4 instances (-n) of nfsd to run. You should set an appropriate number of NFS
server instances handle the maximum number of concurrent client requests
that you want to service by adjusting the flags nfsd is started with.

<p>
You're now ready to mount the exported filesystems from the client(s).

<p>
Remember: If you make changes to <tt>/etc/exports</tt> while NFS is already
running, you need to make mountd aware of this!
Just HUP mountd and the changes will take affect.

<blockquote><pre>
# <b>rcctl reload mountd</b>
</pre></blockquote>

<h3>Mounting NFS Filesystems</h3>

NFS filesystems can be mounted from a client without needing to enable
any services or daemons. They can be mounted just like any other filesystem.

<p>
NFS filesystems should be mounted via mount(8), or more specifically,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs">
mount_nfs(8)</a>.
To mount the <tt>/work</tt> filesystem on host 10.0.0.1 to local filesystem
<tt>/mnt</tt>, do this (note that you don't need to use an IP address;
mount will resolve host names):

<blockquote><pre>
# <b>mount -t nfs 10.0.0.1:/work /mnt</b>
</pre></blockquote>

To have that filesystem mounted at boot, add something like this to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab">fstab(5)</a>:

<blockquote><pre>
# <b>echo '10.0.0.1:/work /mnt nfs rw 0 0' >> /etc/fstab</b>
</pre></blockquote>

It is important that you use <tt>0 0</tt> at the end of this line so
that your computer does not try to fsck the NFS filesystem on boot.
The other standard security options, such as <tt>noexec</tt>,
<tt>nodev</tt>, and <tt>nosuid</tt>, should also be used where applicable.
For example:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

This way, no devices or setuid programs on the NFS server can subvert
security measures on the NFS client.
If you are not mounting programs that you expect to run on the NFS
client, add <tt>noexec</tt> to this list.

<p>
When accessing an NFS mount as the root user, the server automatically
maps root's access to username "nobody" and group "nobody."
This is important to know when considering file permissions.
For example, take a file with these permissions:

<blockquote><pre>
-rw-------    1 root     wheel           0 Dec 31 03:00 _daily.B20143
</pre></blockquote>

If this file was on an NFS share and the root user tried to access this
file from the NFS client, access would be denied.
This is because the server uses the credentials of the user "nobody"
when root tries to access the file.
Since the user nobody doesn't have permissions to access the file,
access is denied.

<p>
The user and group that root are mapped to are configurable via the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=export">exports(5)</a>
file on the NFS server.

<h3>Checking Stats on NFS</h3>

One thing to check to ensure NFS is operating properly is that all the
daemons have properly registered with RPC. To do this, use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rpcinfo">rpcinfo(8)</a>.

<blockquote><pre>
$ <b>rpcinfo -p 10.0.0.1</b>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

During normal usage, there are a few other utilities that allow you to
see what is happening with NFS. One is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount">
showmount(8)</a>, 
which allows you to view what is currently mounted and who is mounting
it. There is also
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsstat">nfsstat(1)</a>,
which shows much more verbose statistics.
To use showmount(8), try <tt>/usr/bin/showmount -a host</tt>. For example:

<blockquote><pre>
$ <b>showmount -a 10.0.0.1</b>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

This output shows that the client 10.0.0.37 has mounted the
<tt>/work</tt> export being served from the server at 10.0.0.1.

<h2 id="Bridge">6.9 - Setting up a network bridge in OpenBSD</h2>

A <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge">bridge(4)</a>
is a link between two or more separate networks.  Unlike a router, 
packets transfer through the bridge "invisibly" -- logically, the two
network segments appear to be one segment to nodes on either side of the
bridge.  The bridge will only forward packets that have to pass from one
segment to the other, so among other things, they provide an easy way to
reduce traffic in a complex network and yet allow any node to access any
other node when needed.

<p>
Note that because of this "invisible" nature, an interface in a bridge
may or may not have an IP address of its own.  If it does, the interface
has effectively two modes of operation, one as part of a bridge, the
other as a normal, stand-alone NIC.  If neither interface has an IP
address, the bridge will pass network data, but will not be externally
maintainable (which can be a feature).

<h3>A simple example of a bridge application</h3>

One of my computer racks has a number of older systems, none of which
have a built-in 10BASE-TX NIC.  While they all have an AUI or AAUI
connector, my supply of transceivers is limited to coax.  One of the
machines on this rack is an OpenBSD-based terminal server which is always
on and connected to the high-speed network.  Adding a second NIC with a
coax port will allow me to use this machine as a bridge to the coax
network.

<p>
This system has two NICs in it now, an Intel EtherExpress/100 <tt>fxp0</tt>
and a 3c590-Combo card <tt>ep0</tt> for the coax port.
<tt>fxp0</tt> is the link to the rest of my network and will thus have an
IP address, while <tt>ep0</tt> is going to be for bridging only, and will
have no IP address.
Machines attached to the coax segment will communicate as if they
were on the rest of my network.  So, how do we make this happen?

<p>
The file <tt>hostname.fxp0</tt> contains the configuration info for
the <tt>fxp0</tt> card.  This machine is set up using DHCP, so its file
looks like this:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp
</pre></blockquote>

No surprises here.

<p>
The <tt>ep0</tt> card is a bit different, as you might guess:

<blockquote><pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre></blockquote>

Here, we are instructing the system to activate this interface using 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a>
and setting it to 10BASE-2 (coax).  No IP address or similar information
needs to be specified for this interface.  The options the <tt>ep</tt>
card accepts are detailed in its
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep">man page</a>.

<p>
Now, we need to set up the bridge.  Bridges are initialized by the
existence of a file named something like 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if">
<tt>hostname.bridge0</tt></a>. 
Here is an example for my situation here:

<blockquote><pre>
$ <b>cat /etc/hostname.bridge0</b>
add fxp0
add ep0
up
</pre></blockquote>

This is saying set up a bridge consisting of the two NICs, <tt>fxp0</tt>
and <tt>ep0</tt>, and activate it.  Does it matter which order the cards
are listed? No, remember a bridge is very symmetrical -- packets flow in
and out in both directions.

<p>
That's it!  Reboot and you now have a functioning bridge.

<h3>A bridge acting as a DHCP server</h3>

Let's say we have a small system which has four
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vr">vr(4)</a>
interfaces, <tt>vr0</tt> through <tt>vr3</tt>.
We want to bridge <tt>vr1</tt>, <tt>vr2</tt> and <tt>vr3</tt> together,
leaving out <tt>vr0</tt> for an uplink (a cable modem for instance).
We also want to serve IP addresses through DHCP over the bridged
interfaces.  Being a DHCP server and an uplink router, the box needs to
have an IP address on the bridged network (contrary to the previous
example in which the bridging box was not visible on the network).

<p>
It is not possible to assign an IP address directly to a bridge
interface.  The IP address should be added to one of the member
interfaces, but we cannot use a physical interface as the link might be
down, in which case the address would not be reachable.
Fortunately, there is the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vether">vether(4)</a>
virtual Ethernet interface driver that can be used for this purpose.
We will add it to the bridge, assign the IP address to it and make
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd">dhcpd(8)</a>
listen there.

<p>
Notes:

<ul>
<li>The <a href="#DHCPserver">DHCP server configuration</a> is not
described yet again in this section, but the addressing scheme used here is
the same.
<li>This will also be the uplink router for your bridged network, so we
will use IP address 192.168.1.1 to match the DHCP server configuration.
<li>We will not cover the uplink, routing or firewalling configuration
here.
</li>
</ul>

<p>
First, mark the <tt>vr1</tt>, <tt>vr2</tt> and <tt>vr3</tt> interfaces as up:

<blockquote><pre>
# <b>echo up > /etc/hostname.vr1</b>
# <b>echo up > /etc/hostname.vr2</b>
# <b>echo up > /etc/hostname.vr3</b>
</pre></blockquote>

Then create the <tt>vether0</tt> configuration:

<blockquote><pre>
# <b>echo 'inet 192.168.1.1 255.255.255.0 192.168.1.255' > /etc/hostname.vether0</b>
</pre></blockquote>

We configure the bridge interface to contain all the above interfaces:

<blockquote><pre>
$ <b>cat /etc/hostname.bridge0</b>
add vether0
add vr1
add vr2
add vr3
up
</pre></blockquote>

And finally we make dhcpd(8) listen on the vether0 interface:

<blockquote><pre>
# <b>rcctl set flags dhcpd vether0</b>
</pre></blockquote>

Reboot and voil&agrave;!

<h3>Filtering on a bridge</h3>

While there are certainly uses for a simple bridge like this, it is
likely you might want to DO something with the packets as they go
through your bridge.  As you might expect, <a href="#PF">Packet
Filter</a> can be used to restrict what traffic goes through your
bridge.

<p>
Keep in mind, by the nature of a bridge, the same data flows through
both interfaces, so you only need to filter on one interface.  Your
default "pass all" statements would look something like this:

<blockquote><pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre></blockquote>

Now, let's say I wish to filter traffic hitting these old machines.
I want only web and SSH traffic to reach them.  In this case, we are going
to let all traffic in and out of the <tt>ep0</tt> interface, but filter
on the <tt>fxp0</tt> interface.

<blockquote><pre>
# Pass all traffic through ep0
pass in  quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port { 22 80 } 
</pre></blockquote>

Note that this rule set will prevent anything but incoming HTTP and SSH
traffic from reaching either the bridge machine or any of the other
nodes "behind" it.  Other results could be had by filtering the other
interface.

<p>
To monitor and control the bridge you have created, use the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a>
command, which can also be used to create a bridge after boot.

<h3>Tips on bridging</h3>

<ul>
<li>It is HIGHLY recommended that you filter on only one interface.
While it is possible to filter on both, you really need to understand
this very well to do it right.

<li>By using the <i>blocknonip</i> option of 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">fconfig(8)</a>
or in  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if">
hostname.bridge0</a>,
you can prevent non-IP traffic (such as IPX or NETBEUI) from slipping
around your filters.  This may be important in some situations, but you
should be aware that bridges work for all kinds of traffic, not just IP.

<li>Bridging requires that the NICs be in a "promiscuous mode" -- they
listen to ALL network traffic, not just that directed at the interface.
This will put a higher load on the processor and bus than one might
expect.  Some NICs don't work properly in this mode, the TI ThunderLAN
chip is an example of a chip that won't work as part of a bridge. 
</ul>

<h2 id="PXE">6.10 - How do I boot using PXE? (i386, amd64)</h2>

The Preboot Execution Environment, or PXE, is a way to boot a computer
from the network, rather than from a hard disk, USB drive or CD-ROM.
The technology was originally developed by Intel, but is supported
by most major network card and computer manufacturers now.
Traditionally, PXE booting is done using ROMs on the NIC or mainboard
of the system, but boot floppies are available from various sources
that will permit PXE booting, as well.
Many ROMs on older NICs support network booting but do NOT support PXE;
OpenBSD/i386 or amd64 cannot currently be booted across the network by these.

<h3>How does PXE booting work?</h3>

First, it is wise to understand how <a href="faq14.html#Boot386">OpenBSD
boots</a> on i386 and amd64 platforms.
Upon starting the boot process, the PXE-capable NIC broadcasts a DHCP
request over the network.
The DHCP server will assign the adapter an IP address, and gives it
the name of a file to be retrieved from a 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp">tftp(1)</a>
server and executed.
This file then conducts the rest of the boot process.
For OpenBSD, the file is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot">pxeboot</a>,
which takes the place of the standard
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot">boot(8)</a> file.
pxeboot(8) is then able to load and execute a kernel (such as
<tt>bsd</tt> or <a href="faq4.html#bsd.rd"><tt>bsd.rd</tt></a>) from the
same TFTP server.

<h3>How do I do it?</h3>

The first and obvious step is you must have a pxeboot-capable computer
or network adapter.
Some documentation will indicate all modern NICs and computers are PXE
capable, but this is clearly not true -- many low cost systems do not
include PXE ROMs or use an older network boot protocol.
You also need a properly configured <a href="#DHCP">DHCP</a> and TFTP server.

<p>
Assuming an OpenBSD machine is the source of the boot files (this is
NOT required), your DHCP server's
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf">dhcpd.conf</a>
file will need to have the following line:

<blockquote><pre>
filename "pxeboot";
</pre></blockquote>

to have the DHCP server offer that file to the booting workstation.
For example:

<blockquote><pre>
shared-network LOCAL-NET {
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;
                <b>filename "pxeboot";</b>
                range 192.168.1.32 192.168.1.127;
                default-lease-time 86400;
                max-lease-time 90000;
        }
}
</pre></blockquote>

<p>
You will also have to activate the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd">tftpd(8)</a>
daemon.

<blockquote><pre>
# <b>rcctl enable tftpd</b>
# <b>rcctl set tftpd flags /tftpboot</b>
</pre></blockquote>

It serves files from a particular directory, and in the case that directory
is <tt>/tftpboot</tt>, which we will use for this example. 
Obviously, this directory needs to be created and populated.
Typically, you will have only a few files here for PXE booting:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot">
pxeboot</a>, the PXE boot loader
<li><a href="faq4.html#bsd.rd">bsd.rd</a>, the install kernel (or <tt>bsd</tt>,
a customized kernel)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf">
boot.conf</a>, a boot configuration file
</ul>

Note that <tt>/etc/boot.conf</tt> is only needed if the kernel you wish to
boot from is not named <tt>bsd</tt>, or other pxeboot defaults are not 
as you need them (for example, you wish to use a serial console).
You can test your tftpd(8) server using a 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp">tftp(1)</a>
client, making sure you can fetch the needed files.

<p>
When your DHCP and TFTP servers are running, you are ready to try it.
You will have to activate the PXE boot on your system or network card;
consult your system documentation.
Once you have it set, you should see something similar to the following:

<blockquote><pre>
Intel UNDI, PXE-2.0 (build 067)
Copyright (C) 1997,1998 Intel Corporation

For Realtek RTL 8139(X) PCI Fast Ethernet Controller v1.00 (990420)

DHCP MAC ADDR: 00 E0 C5 C8 CF E1
CLIENT IP: 192.168.1.76  MASK: 255.255.255.0  DHCP IP: 192.168.1.252
GATEWAY IP: 192.168.1.1
probing: pc0 com0 com1 apm pxe![2.1] mem[540k 28m a20=on]
disk: hd0*
net: mac 00:e0:c5:c8:cf:e1, ip 192.168.1.76, server 192.168.1.252
>> OpenBSD/i386 PXEBOOT 3.23
boot>
</pre></blockquote>

At this point, you have the standard OpenBSD boot prompt.  
If you simply type "<tt>bsd.rd</tt>" here, you will then fetch the 
file <tt>bsd.rd</tt> from the TFTP server.

<blockquote><pre>
>> OpenBSD/i386 PXEBOOT 3.23
boot> <b>bsd.rd</b>
booting tftp:bsd.rd: 4375152+733120 [58+122112+105468]=0x516d04
entry point at 0x100120

Copyright (c) 1982, 1986, 1989, 1991, 1993
        The Regents of the University of California.  All rights reserved.
  ...
</pre></blockquote>

The <a href="faq4.html#bsd.rd">bsd.rd install kernel</a> will now boot.

<h3>Can I boot OpenBSD kernels other than <tt>bsd.rd</tt> using PXE?</h3>

Yes, although with the tools currently in OpenBSD, PXE booting is
primarily intended for installing the OS.

<h2 id="CARP">6.11 - Common Address Redundancy Protocol (CARP)</h2>

<h3>6.11.1 - What is CARP and how does it work?</h3>

CARP is a tool to help achieve system redundancy by having multiple
computers creating a single, virtual network interface between them.
That way, if any machine fails, another can respond instead.
This allows a degree of load sharing between systems.
CARP is an improvement over the Virtual Router Redundancy Protocol
(VRRP) standard.
It was developed after VRRP was deemed to be not free enough because of
a possibly-overlapping Cisco patent.
For more information on CARP's origins and the legal issues surrounding
VRRP, please visit <a href="../lyrics.html#35">this page</a>.

<p>
To avoid legal conflicts, Ryan McBride (with help from Michael
Shalayeff, Marco Pfatschbacher and Markus Friedl) designed CARP to be
fundamentally different.
The inclusion of cryptography is the most prominent change, but still
only one of many.

<p>
How it works: CARP is a multicast protocol.
It groups several physical computers together under one or more virtual
addresses.
Of these, one system is the master and responds to all packets destined
for the group, the other systems act as hot spares.
No matter what the IP and MAC address of the local physical interface,
packets sent to the CARP address are returned with the CARP information.

<p>
At configurable intervals, the master advertises its operation on IP
protocol number 112.
If the master goes offline, the other systems in the CARP group begin to
advertise.
The host that's able to advertise most frequently becomes the new
master.
When the main system comes back up, it becomes a back up host by
default, although if it's more desirable for one host to be master
whenever possible (e.g. one host is a fast Sun Fire V120 and the
others are comparatively slow SPARCstation IPCs), you can so configure
them.

<p>
While highly redundant and fault-tolerant hardware minimizes the need
for CARP, it doesn't erase it.
There's no hardware fault tolerance that's capable of helping if someone
knocks out a power cord, or if your system administrator types
<tt>reboot</tt> in the wrong window.
CARP also makes it easier to make the patch and reboot cycle transparent
to users, and easier to test a software or hardware upgrade--if it
doesn't work, you can fall back to your spare until fixed.

<p>
There are, however, situations in which CARP won't help.
CARP's design does require that the members of a group be on the same
physical subnet with a static IP address, although with the introduction
of the carpdev directive, there is no more need for IP addresses on the
physical interfaces.
Similarly, services that require a constant connection to the server
(such as SSH or IRC) will not be transparently transferred to the other
system--though in this case, CARP can help with minimizing downtime.
CARP by itself does not synchronize data between applications, this has
to be done through "alternative channels" such as 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync">pfsync(4)</a>
(for redundant filtering), manually duplicating data between boxes with
<a href="http://rsync.samba.org/">rsync</a>, or whatever is appropriate
for your application.

<h3>6.11.2 - Configuration</h3>

CARP's controls are located in two places:
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl">sysctl(8)</a>
and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a>.
Let's look at the sysctls first.

<p>
The first sysctl, <tt>net.inet.carp.allow</tt>, defines whether the
host handles CARP packets at all.
Clearly, this is necessary to use CARP.
This sysctl is enabled by default.

<p>
The second, <tt>net.inet.carp.log</tt>, logs CARP state changes,
bad packets and other errors. Set to log state changes by default.

<p>
Third, <tt>net.inet.carp.preempt</tt> enables natural selection
among CARP hosts.
The most fit for the job (that is to say, able to advertise most
frequently) will become master.
Disabled by default, meaning a system that is not a master will
not attempt to (re)gain master status.

<p>
All these sysctl variables are documented in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">
sysctl(3)</a>.

<p>
For the remainder of CARP's configuration, we'll rely on
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a>.
The CARP-specific commands <tt>advbase</tt> and
<tt>advskew</tt> deal with the interval between CARP advertisements.
The formula (in seconds) is <tt>advskew</tt> divided by 256, then added
to <tt>advbase</tt>.
<tt>advbase</tt> can be used to decrease network
traffic or allow longer latency before a backup host takes over;
<tt>advskew</tt> lets you control which host will be master without much
delaying failover (should that be required).

<p>
Next, <tt>pass</tt> sets a password, and <tt>vhid</tt> sets the
virtual host identifier number of the CARP group.
You need to assign a unique number for each CARP group, even if (for
load balancing purposes) they share the same IP address.
CARP is limited to 255 groups.

<p>
Finally, <tt>carpdev</tt> specifies which physical interface belongs to
this particular CARP group.
By default, whichever interface has an IP address in the same subnet
assigned to the CARP interface will be used.

<p>
Let's put all these settings together in a basic configuration.
Let's say you're deploying two identically configured web servers,
<i>rachael</i> (192.168.0.5) and <i>pris</i> (192.168.0.6), to replace
an older system that was at 192.168.0.7.  The commands:

<blockquote><pre>
# <b>ifconfig carp0 create</b>
# <b>ifconfig carp0 vhid 1 pass tyrell carpdev fxp0 192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

will create the carp0 interface and give it a vhid of 1, a password of
<i>tyrell</i>, and the IP address 192.168.0.7 with mask 255.255.255.0.
Assign <tt>fxp0</tt> as the member interface.
To make it permanent across reboots, you can create an
<tt>/etc/hostname.carp0</tt> file that looks like this:

<blockquote><pre>
inet 192.168.0.7 255.255.255.0 192.168.0.255 vhid 1 pass tyrell carpdev fxp0
</pre></blockquote>

Note that the broadcast address is specified in that line, in addition
to the vhid and the password.
Failing to do this is a common cause of errors, as it is needed as a
place holder.

<p>
Do the same on <i>pris</i>. Whichever system brings the CARP interface
up first will be master (assuming that preempt is disabled; the opposite
is true when preempt is enabled).

<p>
But let's say you're not deploying from scratch.
<i>Rachael</i> was already in place at the address 192.168.0.7.
How do you work around that?
Fortunately, CARP can deal with this situation. You simply assign the
address to the CARP interface and leave the physical interface specified
by the `carpdev' keyword without an IP address.
However, it tends to be cleaner to have an IP for each system -- it makes
individual monitoring and access much simpler.

<p>
Let's add another layer of complexity; we want <i>rachael</i> to stay
master when possible.
There are several reasons we might want this: hardware differences,
simple prejudice, "if this system isn't master, there's a problem," or
knowing the default master without doing scripting to parse and email
the output of ifconfig.

<p>
On <i>rachael</i>, we'll use the sysctl we created above, then edit
<tt>/etc/sysctl.conf</tt> to make it permanent.

<blockquote><pre>
# <b>sysctl net.inet.carp.preempt=1</b>
# <b>echo 'net.inet.carp.preempt=1' >> /etc/sysctl.conf</b>
</pre></blockquote>

We'll do configuration on <i>pris</i> too:

<blockquote><pre>
# <b>ifconfig carp0 advskew 100</b>
</pre></blockquote>

This slightly delays <i>pris</i>'s advertisements, meaning
<i>rachael</i> will be master when alive.

<p>
Note that if you are using PF on a CARP'd computer, you must pass 
"proto carp" on all involved interfaces, with a line similar to:

<blockquote><pre>
pass on fxp0 proto carp keep state
</pre></blockquote>

<h3>6.11.3 - Load balancing</h3>

Flash forward a few months. Our company of the previous example has
grown to the point where a single internal Web server is just barely
managing the load. What to do?  CARP to the rescue.  It's time to try
load balancing. Create a new CARP interface and group on <i>rachael</i>:

<blockquote><pre>
# <b>ifconfig carp1 create</b>
# <b>ifconfig carp1 vhid 2 advskew 100 pass bryant carpdev fxp0 192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

On <i>pris</i>, we'll create the new group and interface as well, then set
the "preempt" sysctl:

<blockquote><pre>
# <b>ifconfig carp1 create</b>
# <b>ifconfig carp1 vhid 2 pass bryant carpdev fxp0 192.168.0.7 netmask 255.255.255.0</b>
# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

Now we have two CARP groups with the same IP address.
Each group is skewed toward a different host, which means <i>rachael</i>
will stay master of the original group, but <i>pris</i> will take over
the new one.

<p>
While these examples are for a two-machine cluster, the same
principles apply to more systems.
Please note, however, that it's not expected that you will achieve
perfect 50/50 distribution between the two machines--CARP uses a hash of
the originating IP address to determine which system handles the
request, rather than by load.

<h3>6.11.4 - More Information on CARP</h3>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp">
carp(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">
ifconfig(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl">
sysctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">
sysctl(3)</a>
</ul>

<h2 id="OpenNTPD">6.12 - Using OpenNTPD</h2>

Accurate time is important for many computer applications.
However, many people have noticed that their $5 watch can keep better
time than their $2000 computer.
In addition to knowing what time it is, it is also often important to 
synchronize computers so that they all agree on what time it is.
For some time, <a href="http://www.ntp.org">ntp.org</a> has 
produced a Network Time Protocol
(<a href="http://www.ietf.org/rfc/rfc1305.txt">RFC1305</a>,
<a href="http://www.ietf.org/rfc/rfc2030.txt">RFC2030</a>)
application, available through <a href="faq15.html#Ports">ports</a>,
which can be used to synchronize clocks on computers over the Internet.
However, it is a non-trivial program to set up, has code that's difficult
to audit and has a large memory requirement.
In short, it fills an important role for some people, but it is far
from a solution for all.

<p>
<a href="http://www.openntpd.org">OpenNTPD</a> is an attempt to resolve
some of these problems, making a trivial-to-administer, safe and simple
NTP-compatible way to have accurate time on your computer. OpenBSD's 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd">ntpd(8)</a>
is controlled with an easy to understand configuration file,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf">
ntpd.conf(5)</a>.

<p>
The OpenNTPD daemon is enabled by default at install time, which
will result in your computer's clock slowly moving towards, then keeping
itself synchronized to the
<a href="http://www.pool.ntp.org/">pool.ntp.org</a> time servers.
Once your clock is accurately set, ntpd will hold it at a high 
degree of accuracy. However, if your clock is more than a few minutes
off, it is <i>highly</i> recommended that you bring it close to
accurate initially, as it may take days or weeks to bring a very-off
clock to sync.
You can do this using the <tt>-s</tt> option of ntpd(8) or any other
way to accurately set your system clock.

<h3 id="OpenNTPDaccurate">6.12.1 - "But OpenNTPD isn't as accurate as the
ntp.org daemon!"</h3>

This may be true, as that is not among OpenNTPD's 
<a href="http://www.openntpd.org/goals.html">design goals</a>. It is
intended to be free, simple, reliable and secure.
There is no plan or desire to have OpenNTPD bloated with every
imaginable feature.

<h3 id="OpenNTPDharmful">6.12.2 - "Someone has claimed that OpenNTPD is
'harmful'!"</h3>

Some people have not understood the goals of OpenNTPD -- a simple,
secure and easy to maintain way to keep your computer's clock accurate.
If accurate time keeping is important, a number of users have reported
better results from OpenNTPD than from ntp.org's ntpd.
If security is important, OpenNTPD's code is much more readable (and
thus, auditable) and was written using native OpenBSD function calls
like
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy">strlcpy</a>,
rather than more portable functions like 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strcpy">strcpy</a>.
It was also written to be secure from the beginning, not "made secure" later.
If having more people using time synchronization is valuable, OpenNTPD 
makes it much easier for larger numbers of people to use it.
If this is "harmful," we're all for it.

<p>
There are applications where the ntp.org ntpd is 
more appropriate; however it is felt that for a large majority of the
users, OpenNTPD is more than sufficient.

<p>
A more complete response to this by one of the maintainers of OpenNTPD
can be read
<a href="http://www.advogato.org/person/dtucker/diary.html?start=52">here</a>.

<h3 id="OpenNTPDNoServe">6.12.3 - Why can't my other machines synchronize
to OpenNTPD?</h3>

ntpd(8) does not listen on any address by default.
So in order to use it as a server, you have to uncomment the 
"<tt>#listen on *</tt>" line in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf">
/etc/ntpd.conf</a> and restart the ntp daemon.
Of course, if you wish it to listen on a particular IP address rather
than all available addresses and interfaces, replace the "*" with
the desired address.

<p>
When you have ntpd(8) listening, it may happen that other machines still
can't synchronize to it!
A freshly started ntpd(8) daemon (for example, if you just restarted it
after modifying ntpd.conf) refuses to serve time information to other
clients until it adjusts its own clock to a reasonable level of
stability first.
When ntpd(8) considers its own time information stable, it announces
it by a "clock now synced" message in <tt>/var/log/daemon</tt>.
Even if the system clock is pretty accurate in the beginning, it can
take up to 10 minutes to get in sync, and hours or days if the clock is
not accurately set at the start.

<h2 id="Wireless">6.13 - What are my wireless networking options?</h2>

OpenBSD has support for a number of wireless chipsets:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=acx">acx(4)</a>
TI ACX100/ACX111 <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an">an(4)</a>
Aironet Communications 4500/4800
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ath">ath(4)</a>
Atheros 802.11a/b/g <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=athn">athn(4)</a>
Atheros 802.11/a/g/n devices <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atu">atu(4)</a>
Atmel AT76C50x USB 802.11b
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw">atw(4)</a>
ADMtek ADM8211
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bwi">bwi(4)</a>
Broadcom AirForce 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cnw">cnwi(4)</a>
Xircom CreditCard Netwave
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipw">ipw(4)</a>
Intel PRO/Wireless 2100 802.11b
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi">iwi(4)</a>
Intel PRO/Wireless 2200BG/2225BG/2915ABG 802.11a/b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwm">iwm(4)</a>
Intel Wireless 7260/7265/3160 802.11a/ac/b/g/n
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwn">iwn(4)</a>
Intel WiFi Link 4965/5100/5300 802.11a/b/g/n wireless
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=malo">malo(4)</a>
Marvell Libertas 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=otus">otus(4)</a>
Atheros USB 802.11a/g/n
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pgt">pgt(4)</a>
Conexant/Intersil Prism GT Full-MAC 802.11a/b/g <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ral">ral(4)</a>
and <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ural">ural(4)</a>
Ralink Technology RT25x0 802.11a/b/g <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rsu">rsu(4)</a>
Realtek RTL8188SU/RTL8192SU USB 802.11b/g/n
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtw">rtw(4)</a>
Realtek 8180 802.11b <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtwn">rtwn(4)</a>
Realtek RTL8188CE PCIe IEEE 802.11b/g/n
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rum">rum(4)</a>
Ralink Technology RT2501USB <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=run">run(4)</a>
Ralink Technology USB 802.11a/b/g/Draft-N
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=uath">uath(4)</a>
Atheros USB 802.11a/b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=upgt">upgt(4)</a>
Conexant/Intersil PrismGT SoftMAC USB 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=urtw">urtw(4)</a>
Realtek RTL8187L USB 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=urtwn">urtwn(4)</a>
Realtek RTL8188CU/RTL8192CU USB 802.11b/g/n
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi">wi(4)</a>
Prism2/2.5/3 <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wpi">wpi(4)</a>
Intel PRO/Wireless 3945ABG
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=zyd">zyd(4)</a>
ZyDAS ZD1211/ZD1211B USB 802.11b/g
</ul>

<sup>(AP)</sup> indicates card can be used as an access point.
 
<p>
Adapters based on these chips can be used much like any other network
adapter to connect an OpenBSD system to an existing wireless network,
configured using the standard
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig">ifconfig(8)</a>
utility.
Pease see the manual pages for precise details.
Some of these cards can also be used in the
"Host-Based Access Point" mode, permitting them to be made into the
wireless access point for your network as part of your firewall.

<p>
Note that in order to use some of these cards, you will need to acquire
the firmware files, which the manufacturers refuse to allow 
<a href="faq1.html#ReallyFree">free</a> distribution of, so they can not
be included with OpenBSD.
When possible, the man pages linked above include contact information so
you can contact the right people at the manufacturers to let them know
what you feel about this, or to let them know what other product you
have purchased instead.

<p>
Another option to consider for using your OpenBSD-based firewall to
provide wireless access is to use a conventional NIC and an external
bridging Access Point.
This has the added advantage of letting you easily position the antenna
where it is most effective, which is often not directly on the back of
your firewall.

<h3>Configuring your wireless adapter</h3>

Your wireless adapter can be configured through a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if">
hostname.if(5)</a>
file as other network adapters are, but as they have more options, they
will often be more complicated.

<p>
An example of a wireless hostname file might be:

<blockquote><pre>
nwid puffyuberalles
wpakey puffyguffy
dhcp
</pre></blockquote>

or

<blockquote><pre>
inet 10.0.0.157 255.255.255.0
nwid puffyuberalles
wpakey puffyguffy
</pre></blockquote>

Note that the <tt>dhcp</tt> should be AFTER the other configuration
lines, as the network adapter will not be able to request the DHCP until
it is configured.

<h3>trunk(4)ing your wireless adapter</h3>

Many laptops have both a wireless and a hard-wired adapter.
Sometimes, you may be directly connected to your high speed network and
want the full performance of the wire, other times, you will be using
the wireless.
You probably don't want to reconfigure your machine each time you switch
locations.

<p>
You COULD set up both interfaces with DHCP, but then you would have to
wait for the unused interface to time out while booting, plus things
would be a little confusing if you had both resources available, and
switching between the two resources would be a bit annoying.

<p>
Using a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=trunk">trunk(4)</a>
device may simplify your life.
Trunks are virtual interfaces made up of one or more other network
interfaces.
In this case, we will use a laptop with a wired 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bge">bge0</a>
and a wireless
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwn">iwn0</a>
interface.
Using these two interfaces we will build an interface, <tt>trunk0</tt>, then
use DHCP to get an IP address for this virtual interface.
If we have a cable available, we want to use it, but if not we want to
use the wireless interface.

<p>
To do this, we first configure the two physical ports.
As we are just assigning them to a combined trunk0 interface, we won't
do much of anything with the wired interface other than activate it:

<blockquote><pre>
# <b>echo up > /etc/hostname.bge0</b>
</pre></blockquote>

The wireless interface, however, needs a bit more configuration.
It will need to attach to our wireless WPA-protected network:

<blockquote><pre>
$ <b>cat /etc/hostname.iwn0</b>
nwid puffynet
wpakey mysecretkey
up
</pre></blockquote>

Now, our trunk interface is defined like this:

<blockquote><pre>
$ <b>cat /etc/hostname.trunk0</b>
trunkproto failover trunkport bge0
trunkport iwn0
dhcp
</pre></blockquote>

The trunk is set up to be in "failover" mode, so either interface can be
used, but if both are available, it will prefer the bge0 port, since
that is the first added to the trunk device.

<h2 id="Multipath">6.14 - How can I do equal-cost multipath routing?</h2>

Equal-cost multipath routing refers to having multiple routes in
the routing table for the same network, such as the default route,
0.0.0.0/0.
When the kernel is doing a route lookup to determine where to send
packets destined to that network, it can choose from any of the
equal-cost routes.
In most scenarios, multipath routing is used to provide redundant uplink
connections, e.g., redundant connections to the Internet.

<p>
The
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route">route(8)</a>
command is used to add/change/delete routes in the routing table.
The <tt>-mpath</tt> argument is used when adding multipath routes.

<blockquote><pre>
# <b>route add -mpath default 10.130.128.1</b>
# <b>route add -mpath default 10.132.0.1</b>
</pre></blockquote>

Verify the routes:

<blockquote><pre>
# <b>netstat -rnf inet | grep default</b>
default     10.130.128.1      UGS       2      134      -     fxp1
default     10.132.0.1        UGS       0      172      -     fxp2
</pre></blockquote>

In this example we can see that one default route points to 10.130.128.1
which is accessible via the fxp1 interface, and the other points
to 10.132.0.1 which is accessible via <tt>fxp2</tt>.

<p>
Since the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate">mygate(5)</a>
file does not yet support multipath default routes, the
above commands should be added to the bottom of the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if">
hostname.if(5)</a> files for the <tt>fxp1</tt> and <tt>fxp2</tt> interfaces.
The <tt>/etc/mygate</tt> file should then be deleted.

<blockquote><pre>
$ <b>tail -1 /etc/hostname.fxp1</b>
!route add -mpath default 10.130.128.1
$ <b>tail -1 /etc/hostname.fxp2</b>
!route add -mpath default 10.132.0.1
</pre></blockquote>

Lastly, don't forget to activate the use of multipath routes by enabling the
proper sysctl(3) variable.

<blockquote><pre>
# <b>sysctl net.inet.ip.multipath=1</b>
# <b>sysctl net.inet6.ip6.multipath=1</b>
</pre></blockquote>

Be sure to edit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf">
sysctl.conf(5)</a> to make the changes permanent.

<p>
Now try a traceroute to different destinations.
The kernel will load balance the traffic over each multipath route.

<blockquote><pre>
# <b>traceroute -n 154.11.0.4</b>
traceroute to 154.11.0.4 (154.11.0.4), 64 hops max, 60 byte packets
 1  10.130.128.1  19.337 ms  18.194 ms  18.849 ms
 2  154.11.95.170  17.642 ms  18.176 ms  17.731 ms
 3  154.11.5.33  110.486 ms  19.478 ms  100.949 ms
 4  154.11.0.4  32.772 ms  33.534 ms  32.835 ms

# <b>traceroute -n 154.11.0.5</b>
traceroute to 154.11.0.5 (154.11.0.5), 64 hops max, 60 byte packets
 1  10.132.0.1  14.175 ms  14.503 ms  14.58 ms
 2  154.11.95.38  13.664 ms  13.962 ms  13.445 ms
 3  208.38.16.151  13.964 ms  13.347 ms  13.788 ms
 4  154.11.0.5  30.177 ms  30.95 ms  30.593 ms
</pre></blockquote>

For more information about how the route is chosen, please refer to
<a href="http://www.ietf.org/rfc/rfc2992.txt">RFC2992</a>, "Analysis of an
Equal-Cost Multi-Path Algorithm".

<p>
It's worth noting that if an interface used by a multipath route goes
down (i.e., loses carrier), the kernel will still try to
forward packets using the route that points to that interface.
This traffic will of course be blackholed and end up going nowhere.
It's highly recommended to use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifstated">ifstated(8)</a>
to check for unavailable interfaces and adjust the routing table accordingly.


<p>
<hr>
<p>
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[To Section 5 - Building the System from Source]</a>
<a href="faq7.html">[To Section 7 - Keyboard and Display Controls]</a>
</body>
</html>
