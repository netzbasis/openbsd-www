<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

<!-- If you make edits to any FAQ documents, please start each sentence
     on a new line, and try to keep the general formatting consistent
     with the rest of the pages -->

<title>4 - OpenBSD Installation Guide</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="description"        content= "OpenBSD FAQ 4 - Installation Guide">
<meta name="copyright"          content= "This document copyright 1998-2016
                                          by OpenBSD.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../openbsd.css">
<link rel="canonical" href="http://www.openbsd.org/faq/faq4.html">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<h2>
<a href="../index.html">
<font color="#0000ff"><i>Open</i></font><font color="#000084">BSD</font></a>
<font color="#e00000">FAQ 4 - OpenBSD Installation Guide</font>
</h2>
<hr>
<p>
<a href= "index.html">[FAQ Index]</a>
<a href= "faq3.html">[To Section 3 - Getting Started with OpenBSD]</a>
<a href= "faq5.html">[To Section 5 - Building the System from Source]</a>
<p>

<h3>Table of Contents</h3>
<ul>
<li><a href="#Overview"        >4.1 - Overview of the OpenBSD installation
                                procedure</a>
<li><a href="#Checklist"       >4.2 - Pre-installation checklist</a>
<li><a href="#MkInsMedia"      >4.3 - Creating bootable OpenBSD install
                                media</a>
  <ul>
  <li><a href="#MkFlash"       >4.3.1 - Creating a bootable install flash drive
                                from Unix</a>
  <li><a href="#MkCD-ROM"      >4.3.2 - Creating a boot CD</a>
  <li><a href="#MkFlop"        >4.3.3 - Creating floppies</a>
  </ul>
<li><a href="#Boot"            >4.4 - Booting OpenBSD install media</a>
<li><a href="#Install"         >4.5 - Performing a simple install</a>
<li><a href="#FilesNeeded"     >4.6 - What files are needed for
                                installation?</a>
<li><a href="#Partitioning"    >4.7 - How should I partition my disk?</a>
<li><a href="#SendDmesg"       >4.8 - Sending your dmesg to dmesg@openbsd.org
                                after the install</a>
<li><a href="#AddFileSet"      >4.9 - Adding a file set after install</a>
<li><a href="#bsd.rd"          >4.10 - What is <tt>bsd.rd</tt>?</a>
<li><a href="#InstProb"        >4.11 - Common installation problems
                                (amd64, i386)</a>
<li><a href="#Signify"         >4.12 - Problems with signatures</a>
<li><a href="#site"            >4.13 - Customizing the install process</a>
<li><a href="#Multiple"        >4.14 - How can I install a number of similar
                                systems?</a>
<li><a href="#getdmesg"        >4.15 - How can I get a dmesg(8) to report an
                                install problem?</a>
<li><a href="#Multibooting"    >4.16 - Multibooting OpenBSD (amd64, i386)</a>
<li><a href="#More"            >4.17 - Details for a more complex install</a>
  <ul>
  <li><a href="#MoreNetwork"   >4.17.1 - Setting up the network</a>
  <li><a href="#MoreTimeZone"  >4.17.2 - Setting the time zone</a>
  <li><a href="#Morefdisk"     >4.17.3 - Custom fdisk(8) layout</a>
  <li><a href="#Moredisklabel" >4.17.4 - Custom disklabel layout</a>
  </ul>
<li><a href="#AddThoughts"     >4.18 - Some additional thoughts on
                                partitioning</a>
</ul>
<hr>

<h2 id="Overview">4.1 - Overview of the OpenBSD installation procedure</h2>

OpenBSD has long been respected for its simple and straightforward
installation process, which is very consistent across all platforms.

<p>
All platforms use a very similar installation procedure.
You are urged to read the platform-specific INSTALL document in the
on the CD-ROM or mirror sites.
For example, <tt>i386/INSTALL.i386</tt>, <tt>macppc/INSTALL.macppc</tt>
or <tt>sparc/INSTALL.sparc</tt>.

<p>
The OpenBSD installer is a <a href="#bsd.rd">special kernel</a> with a number
of utilities and install scripts embedded in a pre-loaded RAM disk.
After this kernel is booted, the operating system is extracted and installed
from a number of compressed
<a href="http://man.openbsd.org/?query=tar">tar(1)</a>
files.
There are several ways to boot this install kernel:

<ul>
  <li><b>CD-ROM:</b>
    On several platforms, CD-ROM images are provided, allowing creation of a
    bootable CD-ROM.
    <tt>cdXX.iso</tt> is for just booting, while <tt>installXX.iso</tt> is for
    the entire install.
  <li><b>USB drives:</b>
    On some platforms, raw disk images are provided for creating bootable
    USB drives.
    <tt>minirootXX.fs</tt> is for just booting, while <tt>installXX.fs</tt>
    is for the entire install.
  <li><b>Existing partition:</b>
    The <a href="#bsd.rd">RAM disk kernel</a> can be booted off an already
    existing partition for an upgrade or reinstall.
  <li><b>Network:</b>
    Some platforms support booting over a network, for example using
    <a href="faq6.html#PXE">PXE</a> or other
    <a href="http://man.openbsd.org/?query=diskless">network boot</a>.
  <li><b>Floppy disk:</b>
    At this point, if you are running a system that only has floppy support,
    we will consider you an advanced user who probably doesn't need this
    FAQ for guidance.
</ul>

Not every <a href="../plat.html">platform</a> supports all boot options:

<ul>
  <li><a href="../alpha.html"><b>alpha:</b></a>
    CD-ROM, network, writing a floppy image to hard disk, floppy.
  <li><a href="../amd64.html"><b>amd64:</b></a>
    CD-ROM, miniroot, <a href="faq6.html#PXE">network</a>, floppy.
  <li><a href="../armish.html"><b>armish:</b></a>
    Varies by machine.
  <li><a href="../hppa.html"><b>hppa:</b></a>
    Network.
  <li><a href="../i386.html"><b>i386:</b></a>
    CD-ROM, miniroot, <a href="faq6.html#PXE">network</a>, floppy.
  <li><a href="../landisk.html"><b>landisk:</b></a>
    Miniroot, installed using another computer.
  <li><a href="../loongson.html"><b>loongson:</b></a>
    Miniroot, existing OS partition.
  <li><a href="../luna88k.html"><b>luna88k:</b></a>
    Network.
  <li><a href="../macppc.html"><b>macppc:</b></a>
    CD-ROM, network.
  <li><a href="../octeon.html"><b>octeon:</b></a>
    Network.
  <li><a href="../sgi.html"><b>sgi:</b></a>
    CD-ROM, network.
  <li><a href="../socppc.html"><b>socppc:</b></a>
    Network.
  <li><a href="../sparc.html"><b>sparc:</b></a>
    CD-ROM, network, writing image to existing swap partition, floppy.
  <li><a href="../sparc64.html"><b>sparc64:</b></a>
    CD-ROM, network, writing image to existing partition, floppy (U1/U2 only).
  <li><a href="../zaurus.html"><b>zaurus:</b></a>
    Boot <tt>bsd.rd</tt> from Linux partition.
    See <tt>INSTALL.zaurus</tt> for more details.
</ul>

All platforms can use <a href="#bsd.rd">bsd.rd</a> to reinstall or upgrade.

<p>
Once the install kernel is booted, you have several options of where to get
the <a href="#FilesNeeded">install file sets</a>.
Again, not every platform supports every option.

<ul>
  <li><b>CD-ROM:</b>
    Of course, we prefer you use the
    <a href="../orders.html">official CD-ROM set</a>, but you can also use
    <tt>installXX.iso</tt> or you can make your own.
  <li><b>HTTP:</b>
    Either one of the OpenBSD <a href="../ftp.html#http">mirror sites</a>
    or your own local web server holding the file sets.
  <li><b>Local disk partition:</b>
    In many cases, you can install file sets from another partition on a local
    hard disk.
    For example, on <a href="../i386.html">i386</a>, you can install from a FAT
    partition or a CD-ROM formatted in ISO 9660, Rock Ridge or Joliet format.
    In some cases, you will have to manually mount the file system before using
    it.
  <li><b>NFS:</b>
    Some platforms support using NFS mounts for the file sets.
</ul>

<h2 id="Checklist">4.2 - Pre-installation checklist</h2>

Before you start, you should have some idea what you want to end up with.
You will want to know the following items, at least:

<ul>
  <li>Machine name.
  <li>Hardware installed and available:
    <ul>
      <li>Verify compatibility with your platform's hardware compatibility page.
      <li>If ISA, you also need to know hardware settings, and confirm they are
        as OpenBSD requires.
    </ul>
  <li>Install method to be used.
  <li>Should an important bug be found, how will the system be patched?
    <ul>
      <li>If done locally, you will need to have
        <a href="#Partitioning">sufficient space</a> available for the
        source tree and building it.
      <li>Otherwise, you will need access to another machine to build a patched
        <a href="faq5.html#Release">release</a> on.
    </ul>
  <li>Desired disk layout:
    <ul>
      <li>Does existing data need to be saved elsewhere?
      <li>Will OpenBSD coexist on this system with another OS?
        If so, how will each system be booted?
        Will you need to install a boot manager?
      <li>Will the entire disk be used for OpenBSD, or do you want to
        keep an existing partition/OS (or space for a future one)?
      <li>How do you wish to sub-partition the OpenBSD part of your disk?
    </ul>
  <li>Network settings, if not using DHCP:
    <ul>
      <li>Domain name.
      <li>Domain Name Server(s) (DNS) address.
      <li>IP addresses and subnet masks for each NIC.
      <li>Gateway address.
    </ul>
  <li>Will you be running the X Window System?
  <li>Do you want to set up <a href="faq14.html#softraidFDE">full disk
      encryption</a>?
</ul>

<h2 id="MkInsMedia">4.3 - Creating bootable OpenBSD install media</h2>

Before creating install media, <a href="faq3.html#Download">verify</a> the
signatures on your downloads.

<p>
As an example, these are the installation images available for the
<a href="../i386.html">i386</a> platform:

<ul>
  <li><b><tt>cdXX.iso</tt></b> is an ISO 9660 image that can be used to create
    a bootable CD with most popular CD-ROM creation software on most platforms.
    This image has the widest selection of drivers, and is usually the
    recommended choice if your hardware can boot from a CD-ROM.
    The install file sets are not included and need to be pulled down from the
    network or another disk.
  <li><b><tt>minirootXX.fs</tt></b> is a disk image that can be written to a
    bootable device, such as a USB flash drive, and booted for the install.
    As in <tt>cdXX.iso</tt>, the install file sets are not included.
  <li><b><tt>installXX.iso</tt></b> much like <tt>cdXX.iso</tt>, but also
    includes all the file sets.
    This file can be used to create a CD that can do a stand-alone
    OpenBSD install.
  <li><b><tt>installXX.fs</tt></b> much like <tt>minirootXX.fs</tt>, but also
    includes all the file sets.
  <li><b><tt>floppyXX.fs</tt></b> supports many older machines that lack
    bootable CD-ROMs.
</ul>

<h3 id="MkFlash">4.3.1 - Creating a bootable install flash drive from Unix</h3>

A bootable USB flash drive (or an external hard disk, or a CF/SD/other card,
&hellip;) can be created by attaching the target device on a Unix machine and
then copying over the image with
<a href="http://man.openbsd.org/?query=dd">dd(1)</a>.

<p>
Using OpenBSD, assuming the device was recognized as <tt>sd6</tt>:

<blockquote><pre>
  # <b>dd if=/location/install*.fs of=/dev/rsd6c bs=1m</b>
</pre></blockquote>

Details of this will vary on other platforms.
Note that the <b>raw I/O device</b> is used in its entirety:
<tt><b>r</b>sd6<b>c</b></tt>.
In some Linux variants, the entire seventh <tt>sd</tt> disk would be
<tt>/dev/sdg</tt>.

<h3 id="MkCD-ROM">4.3.2 - Making a CD-ROM</h3>

You can create a CD-ROM using the <tt>cdXX.iso</tt> or <tt>installXX.iso</tt>
files using the tools at your disposal.
Do note that the goal is to create a CD based on the image file,
not to put the ISO file on a CD as a single file.

<p>
In OpenBSD, you can create a CD from an ISO image using
<a href="http://man.openbsd.org/?query=cdio">cdio(1)</a>:

<blockquote><pre>
# <b>cdio tao cd*.iso</b>
</pre></blockquote>

Modern Windows and Macintosh systems can directly create CDs from ISO images.
On Linux or other Unix-like systems, use applications such as
<a href="http://www.cdrkit.org/">cdrkit</a>.

<h3 id="MkFlop">4.3.3 - Creating floppies</h3>

Creating floppies in OpenBSD can be done with
<a href="http://man.openbsd.org/?query=fdformat">fdformat(1)</a>
to prep the disk,
<a href="http://man.openbsd.org/?query=dd">dd(1)</a>
to write the image, then
<a href="http://man.openbsd.org/?query=cmp">cmp(1)</a>
to verify the write was good.
A similar process and tools can be used on other Unix platforms.

<p>
Creating floppies on Windows can be done with the native low-level
formatting tools, and a program like <tt>ntrw</tt> which can be retrieved
from the <tt>tools</tt> directory on any of the mirror sites.

<h2 id="Boot">4.4 - Booting OpenBSD install media</h2>

<h3>Booting i386/amd64</h3>

Booting install media on the i386 and amd64 PC platforms is nothing new to most
people.
Your system will have to be instructed to boot from whatever media you have
chosen to use, usually through a BIOS setup option.
If you want to boot from CD or a USB device, your system BIOS must be able to
do so.
Some machines are buggy with regard to booting from USB devices;
a BIOS update may help.

<p>
You can also install by booting <a href="#bsd.rd">bsd.rd</a> from an
existing OpenBSD partition, or over the network using the
<a href="faq6.html#PXE">PXE boot process</a>.

<h3>Booting sparc/sparc64</h3>

<b>NOTE:</b>
On the <a href="../sparc64.html">sparc64</a> platform, only the SBus
machines (Ultra 1, Ultra 2) are bootable from floppy.

<p>
You will need the system to be at a monitor ROM prompt, which typically looks
like <tt>ok</tt>.
If you are using a Sun keyboard, press and hold <tt>STOP</tt> while tapping
<tt>A</tt>.
If using a serial console, a <tt>BREAK</tt> should return you to the monitor
prompt.

<p>
Use the following commands to boot from a floppy or a CD-ROM:

<blockquote><pre>
ok <b>boot floppy</b>
</pre></blockquote>

or

<blockquote><pre>
ok <b>boot cdrom</b>
</pre></blockquote>

<h2 id="Install">4.5 - Performing a simple install</h2>

The installer is designed to install OpenBSD in a very usable default
configuration with a minimum of user intervention.
In fact, you can often just hit <tt>&lt;Enter&gt;</tt> to get a good OpenBSD
install, moving your hands to the rest of the keyboard only to enter the
root password and to reboot at the end.

<p>
The installer will create a partitioning plan based on the size of your
hard disk.
While this will not be a perfect layout for all people, it provides a
good starting point for figuring out what you need.

<p>
Installation notes for each platform are on the install CDs and the mirrors,
in the file <tt>INSTALL.&lt;plat&gt;</tt>, where <tt>&lt;plat&gt;</tt> is your
<a href="../plat.html">platform</a>, for instance, <tt>i386</tt>.
Read it.

<p>
Whatever your means of <a href="#Boot">booting</a> is, it is now time to use it.
When your boot is successful, you will see a lot of text messages scroll by.
This text is the
<a href="http://man.openbsd.org/?query=dmesg">dmesg(8)</a>,
the kernel telling you what devices have been found and how they are
hooked to other devices.

<p>
After the
<a href="http://man.openbsd.org/?query=dmesg">dmesg(8)</a>,
you will see the first installer question:

<blockquote><pre>
...
root on rd0a swap on rd0b dump on rd0b
erase ^?, werase ^W, kill ^U, intr ^C, status ^T

Welcome to the OpenBSD/i386 X.X installation program.
(I)nstall, (U)pgrade, (A)utoinstall or (S)hell?
</pre></blockquote>

Choose <tt>(I)nstall</tt> and follow the instructions.

<h2 id="FilesNeeded">4.6 - What files are needed for installation?</h2>

The complete OpenBSD installation is broken up into a number of file sets.
New users are recommended to install all of them.

<ul>
  <li><b><tt>bsd</tt></b>
    - the kernel <b>(required)</b>
  <li><b><tt>bsd.mp</tt></b>
    - the multi-processor kernel (only on some platforms)
  <li><b><tt>bsd.rd</tt></b>
    - the <a href="#bsd.rd">RAM disk kernel</a>
  <li><b><tt>baseXX.tgz</tt></b>
    - the base OpenBSD system <b>(required)</b>
  <li><b><tt>compXX.tgz</tt></b>
    - the compiler collection, headers and libraries
  <li><b><tt>manXX.tgz</tt></b>
    - man pages
  <li><b><tt>gameXX.tgz</tt></b>
    - text-based games
  <li><b><tt>xbaseXX.tgz</tt></b>
    - the base libraries and utilities for X11
  <li><b><tt>xfontXX.tgz</tt></b>
    - X11's font server and fonts
  <li><b><tt>xservXX.tgz</tt></b>
    - X11's X servers
  <li><b><tt>xshareXX.tgz</tt></b>
    - X11's man pages, locale settings, includes
</ul>

<h3 id="FilesNeededX">Why do I have to install X for my non-graphical
application?</h3>

Even if you have no intention of running X, many third party
<a href="faq15.html">packages</a> require the libraries or other
utilities in X to be installed on your system.
These applications can sometimes be satisfied simply by installing
just <tt>xbaseXX.tgz</tt> - the rest of X is not always needed.
Many people who resist installing X on their system don't have a valid reason:

<ul>
<li>By itself, installing X does not cause any program to
execute on the system.
<li>By itself, installing X on a system does not change the
risk of external security issues.
<li>If someone is already ON your system, they can most likely install
whatever they wish, so the presence or absence of the X
does not appreciably change the situation.
<li>The only parts of X that are running are the parts
required by your application.
<li>The space required for X is relatively modest on modern hardware.
</ul>

<h3 id="FilesNeededComp">I don't want to install the compilers</h3>

Ok, don't, but please don't tell yourself this is for security reasons.
By the time someone is far enough into your system that the presence or
absence of the compiler matters, they are far enough in they can install
a compiler themselves.
However, the <tt>compXX.tgz</tt> file set is relatively big and has a lot of
files in it, so it can take a while to install and upgrade.
On slow or small systems, this can matter.

<h2 id="Partitioning">4.7 - How should I partition my disk?</h2>

OpenBSD can be installed in as little as 512MB, but using that small of a device
is something for advanced users.
Until you have some experience, 8GB or more disk space is recommended.

<p>
Unlike many other OSs, OpenBSD encourages users to partition their disk into a
number of partitions, rather than having just one or two big partitions.
Some of the reasons for doing so are:

<ul>
  <li><b>Security:</b>
    You can mark some filesystems with
    <a href="http://man.openbsd.org/?query=mount">mount(8)</a>
    options such as as <tt>nosuid</tt>, <tt>nodev</tt>, <tt>noexec</tt> or
    <tt>readonly</tt> in
    <a href="http://man.openbsd.org/?query=fstab">fstab(5)</a>.
  <li><b>Stability:</b>
    A user or a misbehaved program can fill a filesystem with garbage if they
    have write permissions for it.
    Your critical programs, which hopefully run on a different filesystem,
    do not get interrupted.
  <li><b>Speed:</b>
    A filesystem which gets written to frequently may get somewhat fragmented.
    Luckily, the OpenBSD FFS filesystem is not prone to heavy fragmentation.
  <li><b>Integrity:</b>
    If one filesystem is corrupted for some reason then your other filesystems
    are most likely still OK.
  <li><b><a href="http://man.openbsd.org/?query=fsck">fsck(8)</a>:</b>
    You can mount partitions that you never or rarely need to write to as
    <tt>readonly</tt> most of the time, which will eliminate the need for
    fsck(8) after a crash or power interruption.
    fsck(8) requires more RAM for larger partitions and on small-memory systems
    it can end up having to use swap and thus take a very long time.
</ul>

Read the section on automatic disc allocation in the
<a href="http://man.openbsd.org/?query=disklabel">disklabel(8)</a>
manpage and 
<a href="http://man.openbsd.org/?query=hier">hier(7)</a>
before making decisions about custom partitioning schemes.

<h2 id= "SendDmesg">4.8 - Sending your dmesg to dmesg@openbsd.org after the
install</h2>

A quote from <tt>/usr/src/etc/root/root.mail</tt>:

<blockquote><pre>
If you wish to ensure that OpenBSD runs better on your machines, please do us
a favor (after you have your mail system configured!) and type something like:

# <b>(dmesg; sysctl hw.sensors) | \
   mail -s "Sony VAIO 505R laptop, apm works OK" dmesg@openbsd.org</b>

so that we can see what kinds of configurations people are running.  As shown,
including a bit of information about your machine in the subject or the body
can help us even further.  We will use this information to improve device driver
support in future releases.  (Please do this using the supplied GENERIC kernel,
not for a custom compiled kernel, unless you're unable to boot the GENERIC
kernel.  If you have a multi-processor machine, dmesg results of both GENERIC.MP
and GENERIC kernels are appreciated.)  The device driver information we get from
this helps us fix existing drivers. Thank you!
</pre></blockquote>

Alternatively, save your dmesg output to a text file

<blockquote><pre>
$ <b>(dmesg; sysctl hw.sensors) > ~/dmesg.txt</b>
</pre></blockquote>

and transfer this file to the system you normally use for email.
Since the dmesg output you send in is processed automatically, be sure to
check the following:

<ul>
  <li>Configure your email client to send messages as plain text;
    do not use HTML-formatted email.
  <li>Turn off forced line break features.
  <li>Make sure your email client does not reformat messages into text-flow
    nonsense.
  <li>Do not send the dmesg output as a file attachment.
    Put the dmesg output into the body of the message.
</ul>

<h2 id="AddFileSet">4.9 - Adding a file set after install</h2>

If you chose to skip some file sets at install time, you might realize later
that you really do need them after all.

<p>
Simply <a href="#bsd.rd">boot bsd.rd</a> from your root file system.
Choose <tt>(U)pgrade</tt>.
When you get to the list of file sets, select the ones you need.

<h2 id="bsd.rd">4.10 - What is <tt>bsd.rd</tt>?</h2>

The <tt>bsd.rd</tt> RAM disk kernel is a live OpenBSD environment that runs
entirely in memory. 
It contains the install script and a small number of utilities needed to perform
a complete installation.
These utilities can also be useful for disaster recovery.
The installation media automatically boots into <tt>bsd.rd</tt> and starts
the install script for you.

<p>
If you have a running OpenBSD system, <tt>bsd.rd</tt> is all you need to
reinstall or upgrade to a newer version of OpenBSD without the need for
any removable media.
To do so, simply <a href="faq3.html#Download">download and verify</a>
<tt>bsd.rd</tt>, place it on an existing filesystem and boot from it.

<p>
Booting from <tt>bsd.rd</tt> on an i386 system:
<blockquote><pre>
Using Drive: 0 Partition: 3
reading boot.....
probing: pc0 com0 com1 apm mem[639k 255M a20=on]
disk: fd0 hd0+
&gt;&gt; OpenBSD/i386 BOOT 3.26
boot&gt; <b>boot hd0a:/bsd.rd</b>
</pre></blockquote>

The general method of booting <tt>bsd.rd</tt> is to change your boot kernel
from <tt>/bsd</tt> to <tt>/bsd.rd</tt> through whatever means used on your
platform.

<h2 id="InstProb">4.11 - Common installation problems (amd64, i386)</h2>

<ul>
  <li><b>The computer won't boot after install.</b>
    Your install seemed to go fine, but on first boot, you see no sign of
    OpenBSD attempting to boot.
    Possible reasons include:
    <ul>
      <li>No partition is flagged bootable.
        To fix this, reboot the machine using the boot media and use
        <a href="http://man.openbsd.org/?query=fdisk">fdisk(8)</a>.
      <li>No valid boot loader was ever put on the disk.
        Boot the install media again, drop to the shell and use
        <a href="http://man.openbsd.org/?query=fdisk">fdisk(8)</a>
        with the <tt>-u</tt> flag.
      <li>Rarely, the second stage boot loader install may have failed.
        Run
        <a href="http://man.openbsd.org/?query=installboot">installboot(8)</a>.
    </ul>
  <li><b>The fdisk partition table is trashed or blank.</b>
    The system works, but with <tt><b>fdisk wd0</b></tt>, the partition table
    seems to be blank or garbage.
    This is usually caused by having created an
    <a href="http://man.openbsd.org/?query=fdisk">fdisk(8)</a>
    partition with an offset of zero sectors, rather than the
    <a href="#trackoffset">one track offset</a> that it should have.
    The system then <a href="faq14.html#BootAmd64">boots</a> using the PBR,
    not using the MBR.
    <p>
    While this configuration can work, it can be a maintenance problem and
    should be fixed by recreating the disk's filesystems from scratch.
</ul>

<h2 id="Signify">4.12 - Problems with signatures</h2>

<ul>
  <li><b>Why aren't downloadable images self-signed?</b>
    <p>
    If you use <tt>installXX.iso</tt> or <tt>installXX.fs</tt>, you will
    find the installer will complain about no <tt>SHA256.sig file</tt>, and
    thus it can't verify the files during the installation.
    <p>
    It is not possible to <i>usefully</i> have the complete installer verify
    the sets.
    After all, if someone were to make a "rogue" installXX.iso file, they
    would almost certainly change the installer to say everything verified
    successfully.
    Thus, you must <a href="faq3.html#Download">verify</a> your installer
    downloads separately.
  <li><b>I got a "Continue without verification?" message during install!</b>
    <p>
    The verification process consists of fetching the <tt>SHA256.sig</tt>
    file, then fetching all the install files to the local hard disk and
    verifying their signatures.
    If either the signature file is unavailable or there is insufficient
    disk space for that extra copy of the files, verification will not be
    possible, and you will get that message.
    If you trust your source, this should not be a problem.
    If you do not trust your source, you can manually verify the files as
    detailed <a href="faq3.html#Download">here</a>.
</ul>

<h2 id="site">4.13 - Customizing the install process</h2>

<h3><tt>siteXX.tgz</tt> file</h3>

The OpenBSD install/upgrade scripts allow the selection of a
user-created set called <tt>siteXX.tgz</tt>, where XX is the release
version.
The <tt>siteXX.tgz</tt> file set is, like the other
<a href="#FilesNeeded">file sets</a>, a
<a href="http://man.openbsd.org/?query=gzip">gzip(1)</a>
compressed
<a href="http://man.openbsd.org/?query=tar">tar(1)</a>
archive rooted in '/' and is un-tarred like the other sets with the
options <tt>xzphf</tt>.
This set will be installed last, after all other file sets.

<p>
This file set allows the user to add to and/or override the files
installed in the 'normal' sets and thus customize the installation or
upgrade.

<p>
You can also create and use hostname-specific install sets, which are
named <tt>siteXX-<i>&lt;hostname&gt;.tgz</i></tt>, for example,
<tt>siteXX-puffy.tgz</tt>.
This allows easy per-host customized installations, upgrades, or
disaster recovery.

<p>
Some example uses of a <tt>siteXX.tgz</tt> file:
<ul>
<li>Create a siteXX.tgz file that contains all the file changes you made
since first installing OpenBSD.
Then, if you have to re-create the system, you simply select siteXX.tgz
during the re-install and all of your changes are replicated on the new system.

<li>Create a series of machine-specific directories that each contain a
siteXX.tgz file that contains files specific to those machine types.
Installation of machines (e.g. boxes with different graphics cards) of a
particular category can be completed by selecting the appropriate
siteXX.tgz file.

<li>Put the files you routinely customize in a same or similar way
in a siteXX.tgz file --
<a href="http://man.openbsd.org/?query=adduser"><tt>/etc/skel</tt></a> files,
<a href="http://man.openbsd.org/?query=pf.conf"><tt>/etc/pf.conf</tt></a>,
<a href="http://man.openbsd.org/?query=rc.conf.local">
<tt>/etc/rc.conf.local</tt></a>, etc.
</ul>

<h3><tt>install.site</tt>/<tt>upgrade.site</tt> scripts</h3>

As the last step in the install/upgrade process, the scripts look in the
root directory of the newly installed/upgraded system for
<tt>install.site</tt> or <tt>upgrade.site</tt>, as appropriate to the
current process, and runs this script in an environment
<a href="http://man.openbsd.org/?query=chroot">chroot(8)</a>ed
to the installed/upgraded system's root.
Remember, the upgrade is done from a booted file system, so your target
file system is actually mounted on <tt>/mnt</tt>.
However, because of the chroot, your script can be written as if
it is running in the "normal" root of your file system.
Since this script is run after all the files are installed, you have much of the
functionality of the full system when your script runs.
Keep in mind that you are running a minimal kernel and not all features are
available.
Due to space constraints, things that work today may not work in a
future release.

<p>
Note that the <tt>install.site</tt> script would have to be in a
<tt>siteXX.tgz</tt> file, while the <tt>upgrade.site</tt> script could
be put in the root directory before the upgrade, or could be put in a
<tt>siteXX.tgz</tt> file.

<p>
The scripts can be used to do many things:
<ul>
<li>Remove files that are installed/upgraded that you don't want present
on the system.
<li> Remove/upgrade/install the
<a href="faq15.html#PkgMgmt">packages</a> you want on the installed
system (may not work for all packages!).
<li> Do an immediate backup/archive of the new system before you expose it
to the rest of the world.
<li>Use
<a href="http://man.openbsd.org/?query=rdate">rdate(8)</a>
to set the system time.
<li>Have a set of arbitrary commands be run after the first boot.
This will happen if install.site is used to append any such commands to an
<a href="http://man.openbsd.org/?query=rc.firsttime"><tt>rc.firsttime(8)</tt></a>
file (appending to this file is necessary since the installer itself may
write to this file).
At boot time, rc.firsttime is executed once then deleted.
</ul>

<p>
The combination of <tt>siteXX.tgz</tt> and
<tt>install.site/upgrade.site</tt> files is intended to give users
broad customization capabilities without having to build their own
custom install sets.

<p>
Note: if you will be doing your install from an HTTP server, you will
need to add your <tt>site*.tgz</tt> file(s) to the file
<tt>index.txt</tt> in the source directory in order for them to be
listed as an option at install time.
This is not needed for other install methods.

<h2 id="Multiple">4.14 - How can I install a number of similar systems?</h2>

Here are some tools you can use when you have to deploy a number
of similar OpenBSD systems.

<h3><tt>siteXX.tgz</tt> and <tt>install/upgrade.site</tt> files</h3>

See the <a href="#site">above</a> article.

<h3>Restore from dump(8)</h3>

On most platforms, the boot media includes the
<a href="http://man.openbsd.org/?query=restore">restore(8)</a>
program, which can be used to restore a backup made by
<a href="http://man.openbsd.org/?query=dump">dump(8)</a>.
Thus, you could boot from a
<a href="#MkFlop">floppy</a>,
<a href="../orders.html">CD</a>, or
<a href="#bsd.rd">bsd.rd</a> file, then
<a href="faq14.html#fdisk">fdisk</a>,
<a href="faq14.html#disklabel">disklabel</a>, and
<a href="http://man.openbsd.org/?query=restore">restore(8)</a>
the desired configuration from tape or other media, and install the
<a href="http://man.openbsd.org/?query=installboot">boot blocks</a>.

<h3>Disk imaging</h3>

Unfortunately, there are no known disk imaging packages which are
FFS-aware and can make an image containing only the active file space.
Most of the major disk imaging solutions will treat an OpenBSD partition
as a "generic" partition, and can make an image of the whole disk.
This often accomplishes your goal, but usually with huge amounts of wasted
space --  an empty 10GB <tt>/home</tt> partition will require 10GB of
space in the image, even if there isn't a single file in it.
While you can typically install a drive image to a larger drive, you would
not be able to directly use the extra space, and you would not be able to
install an image to a smaller drive.

<p>
If this is an acceptable situation, you may find the
<a href="http://man.openbsd.org/?query=dd">dd(1)</a>
command will do what you need, allowing you to copy one disk to another,
sector-for-sector.
This would provide the same functionality as
commercial programs without the cost.

<h2 id="getdmesg">4.15 - How can I get a dmesg(8) to report an install
problem?</h2>

When <a href="../report.html">reporting a problem</a>, it is critical to
include the complete system
<a href="http://man.openbsd.org/?query=dmesg">dmesg(8)</a>.
However, often when you need to do this, it is because the system is
working improperly or won't install so you may not have disk, network,
or other resources you need to get the dmesg to the appropriate
<a href="../mail.html">mailing list</a>.
There are other ways, however:

<ul>
<li><b>Floppy disk:</b>  The boot disks and CD-ROM have enough tools
to let you record your dmesg to an MSDOS floppy disk for reading on
another machine.
Place an MSDOS formatted floppy in your disk drive and execute the
following commands:

<blockquote><pre>
# <b>mount -t msdos /dev/fd0a /mnt</b>
# <b>dmesg >/mnt/dmesg.txt</b>
# <b>umount /mnt</b>
</pre></blockquote>

If you have another OpenBSD system, you can also write it to an OpenBSD
compatible floppy -- often, the boot floppy has enough room on it to
hold the dmesg.
In that case, leave off the <tt>-t msdos</tt> above.

<p>
<li><b>Serial Console:</b>
Using a serial console and capturing the output on another computer
is often the best way to capture diagnostic information - particularly
if the computer panics immediately after boot.
As well as a second computer, you will need a suitable serial cable
(often a null-modem cable), and a terminal emulator program that can
capture screen output to file.

<p>
General information on setting up a serial console is provided
<a href="faq7.html#SerCon">elsewhere in the FAQ</a>;
in order to capture a log of the install,
the following commands are usually sufficient.

<p>
<b>i386</b>

<p>
At the boot loader prompt, enter

<blockquote><pre>
boot> <b>set tty com0</b>
</pre></blockquote>

This will tell OpenBSD to use the first serial port (often called
COM1 or COMA in PC documentation) as a serial console.
The default baud rate is 9600.

<p>
<b>Sparc/Sparc64</b>

<p>
These machines will automatically use a serial console if started
without a keyboard present.
If you have a keyboard and monitor attached, you can still force the
system to use a serial console with the following invocation at the
<tt>ok</tt> prompt.

<blockquote><pre>
ok <b>setenv input-device ttya</b>
ok <b>setenv output-device ttya</b>
ok <b>reset</b>
</pre></blockquote>

</ul>

<h2 id="Multibooting">4.15 - Multibooting OpenBSD (amd64, i386)</h2>

Multibooting is having several operating systems on one computer, and
some means of selecting which OS is to boot.
It is <i>not</i> a trivial task!
If you don't understand what you are doing, you may end up deleting
large amounts of data from your computer.
New OpenBSD users are <i>strongly</i> encouraged to start with a blank hard
drive on a dedicated machine, and then practice your desired configuration on a
non-production system before attempting a multiboot configuration on a
production machine.
<a href="faq14.html">FAQ 14</a> has more information about the OpenBSD
boot process.

<p>
Preferably use one of the four <i>primary</i> MBR partitions for
booting OpenBSD (i.e., extended partitions may not work).

<p>
Here are several ways you might configure multibooting:

<h3>Setting active partitions</h3>

This is probably the most overlooked, but yet sometimes the best,
solution for multibooting.
Simply set the active partition in whatever OS you are currently using to
be the one you want to boot by default when you next boot.
Virtually every OS offers a program to do this.
OpenBSD's is <a href="faq14.html#fdisk">fdisk(8)</a>, and similarly
named programs are in many other operating systems.
This can be highly desirable for OSs or systems which take a
long time to shut down and reboot -- you can set it and start the reboot
process, then walk away, grab a cup of coffee, and come back to the system
booted the way you want it -- no waiting for the Magic Moment to select
the next OS.

<h3>Boot floppy</h3>

If you have a system that is used to boot OpenBSD infrequently (or don't
wish other users of the computer to note anything has changed), consider
using a boot floppy.
Simply use one of the <a href="#MkFlop">standard OpenBSD install floppies</a>,
and create an <tt>/etc/boot.conf</tt> file (yes, you will also have to create
an <tt>/etc</tt> directory on the floppy) with the contents:

<blockquote><pre>
   boot hd0a:/bsd
</pre></blockquote>

to cause the system to boot from hard drive 0, OpenBSD partition 'a',
kernel file <tt>/bsd</tt>.
Note you can also boot from other drives with a line like
<tt>boot hd2a:/bsd</tt> to boot off the third hard drive on your system.
To boot from OpenBSD, slip your floppy in,
reboot.
To boot from the other OS, eject the floppy, reboot.
(You can, of course, use this floppy to make a bootable CD, too.)

<p>
The
<a href="http://man.openbsd.org/?query=boot&amp;sec=8&amp;arch=i386">boot(8)</a>
program is loaded from the floppy, it then looks for and reads
<tt>/etc/boot.conf</tt>.
The <tt>boot hd0a:/bsd</tt> line instructs boot(8) where to load the
kernel from -- in this case, the first HD the BIOS sees.
Keep in mind that only a small file (<tt>/boot</tt>) is loaded
from the floppy -- the system loads the entire kernel off the hard disk,
so this only adds about five seconds to the boot process.

<h3>Windows Vista</h3>

With Vista, Microsoft dropped NTLDR support in favor of their newer Boot
Configuration Data (BCD) store used for controlling the boot
environment.
Since <tt>BOOT.INI</tt> is no longer available for customization,
a command-line utility, <tt>bcdedit</tt>, takes its place.

<p>
Once OpenBSD's PBR is copied to Windows' system partition, the following
three commands are required to select and boot OpenBSD when the system
is restarted:

<blockquote><pre>
C:\Windows\system32> bcdedit /create /d "OpenBSD/i386" /application bootsector
The entry {05a763ce-d81b-11db-b3ec-000000000000} was successfully created.

C:\Windows\System32>
</pre></blockquote>

The GUID returned here, <tt>05a763ce-d81b-11db-b3ec-000000000000</tt>,
is shown for illustrative reasons.
Take note of the GUID displayed when you run this command as this value
will need to be copied into the following commands.
Simply copying the GUID shown above will not work.

<p>
The following two commands are also required:

<blockquote><pre>
C:\Windows\system32> bcdedit /set {05a763ce-d81b-11db-b3ec-000000000000} device boot
The operation completed successfully.

C:\Windows\system32> bcdedit /set {05a763ce-d81b-11db-b3ec-000000000000} path \openbsd.pbr
The operation completed successfully.

C:\Windows\system32>
</pre></blockquote>

This must be run in a shell with administrative privileges.
Once you've located cmd.exe, right click to be able to select
"run as administrator".

<p>
Note the absolute pathname of the imported PBR file.
Do not add a drive letter as it is assumed that the file is placed
in the system partition.
<tt>bcdedit</tt> will not complain about an explicit drive
specification, but the boot manager will later balk claiming that it
cannot resolve the designated pathname.

<p>
Upon rebooting, Vista will be listed first in the boot manager
ultimately followed by OpenBSD.
Selecting either entry will boot the corresponding operating system.

<p>
If nothing happens, look around in the control panel for boot information.
Most likely, your Windows boot is set up with no delay, so you don't see the
boot menu.
You can also use this to boot OpenBSD by default.

<p>
For more information, consult <tt>bcdedit</tt>'s help by issuing:

<blockquote><pre>
C:\Windows\system32> bcdedit /?
</pre></blockquote>

or by searching Microsoft's documentation and Website.
A good introduction can be found in this TechNet
<a href="http://technet.microsoft.com/en-us/library/cc721886%28WS.10%29.aspx">
Frequently Asked Questions</a> article.

<p>
For those who find manual configuration daunting,
<a href="http://neosmart.net/dl.php?id=1">EasyBCD</a> provides a GUI
alternative.

<h3>Windows 7</h3>

Microsoft has enhanced BCD since releasing Vista to allow multiple
versions of Windows to be booted through <tt>bcdedit</tt>.
Because of this greater control, five commands are required to configure a
multiboot environment with OpenBSD.

<p>
After copying OpenBSD's PBR into Windows 7's system partition, issue
the following command to initialize the needed registry hive:

<blockquote><pre>
C:\Windows\system32> bcdedit /create /d "OpenBSD/i386" /application bootsector
The entry {0154a872-3d41-11de-bd67-a7060316bbb1} was successfully created.

C:\Windows\system32>
</pre></blockquote>

As admonished before, the
<tt>{0154a872-3d41-11de-bd67-a7060316bbb1}</tt> GUID is
system-dependent.
Note the value you receive when executing, and copy it into the following
commands:

<blockquote><pre>
C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} device boot
The operation completed successfully.

C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} path \openbsd.pbr
The operation completed successfully.

C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} device partition=c:
The operation completed successfully.

C:\Windows\system32> bcdedit /displayorder {0154a872-3d41-11de-bd67-7060316bbb1} /addlast
The operation completed successfully.

C:\Windows\system32>
</pre></blockquote>

<h3>Other boot loaders</h3>

Some other bootloaders OpenBSD users have used successfully include
<a href="http://gag.sourceforge.net/">GAG</a>,
<a href="http://www.ranish.com/part/">The Ranish Partition Manager</a>,
<a href="http://www.rodsbooks.com/refind/">rEFInd</a>,
and <a href="http://www.gnu.org/software/grub/">GRUB</a>.

<h3>Time zone issues</h3>

OpenBSD expects the computer's real-time clock to be set to UTC
(Universal Coordinated Time).
Some other OSs expect the real-time clock to be set to local time.
Obviously, this can create a bit of a problem if you are using both
OSs on the same computer.
One or the other is most likely going to have to be adapted.
More info on doing this is in <a href="faq8.html#TimeZone">FAQ 8 - Why
is my clock off by several hours?</a>


<h2 id="More">4.17 - Details for a more complex install</h2>

Sometimes you can't just take the defaults.
Here are some more details on parts of the installation process.

<h3 id="MoreNetwork">4.17.1 - Setting up the network</h3>

If you don't have a DHCP server available, you will have to set up
your network adapter(s) manually.
Here's an example:

<blockquote><pre>
Which one do you wish to configure? (or 'done') [xl0] <b>&lt;Enter&gt;</b>
IPv4 address for xl0? (or 'dhcp' or 'none') [dhcp] <b>192.168.1.37</b>
Netmask? [255.255.255.0] 255.255.254.0
IPv6 address for xl0? (or 'rtsol' or 'none') [none] <b>&lt;Enter&gt;</b>
</pre></blockquote>

After that set of questions, you will be given a chance to configure any other
network adapters that your machine has.
If you specify another network adapter here, the above questions repeat.

<blockquote><pre>
Available network interfaces are: xl0 vlan0.
Which one do you wish to configure? (or 'done') [done]
</pre></blockquote>

Now, you will set up the default gateway and DNS servers, things that
impact all network adapters:

<blockquote><pre>
Default IPv4 route? (IPv4 address, 'dhcp' or 'none') <b>192.168.1.1</b>
add net default: gateway 192.168.1.1
DNS domain name? (e.g. 'bar.com') [my.domain] <b>example.org</b>
DNS nameservers? (IP address list or 'none') [none] <b>192.168.1.250 192.168.1.251</b>
</pre></blockquote>

Note that multiple DNS servers can be listed, separated by spaces.

<p>
Sometimes you will have to do something more, for example set up a
wireless access key or hard-set a duplex or speed setting (don't do this
unless you absolutely HAVE to, fixing your switch configuration is a
much better idea!).
You are now given a chance to drop to the shell and do any manual configuration
that you would like.

<blockquote><pre>
Do you want to do any manual network configuration? [no] <b>y</b>
Type 'exit' to return to install.
# <b>ifconfig xl0 media</b>
xl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        lladdr 00:08:74:2c:df:9c
        groups: egress
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        supported media:
                media 10baseT
                media 10baseT mediaopt full-duplex
                media 100baseTX
                media 100baseTX mediaopt full-duplex
                media autoselect
        inet 192.168.1.37 netmask 0xfffffe00 broadcast 192.168.1.255
# <b>ifconfig xl0 media 100baseTX mediaopt full-duplex</b>
# <b>ifconfig xl0</b>
xl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        lladdr 00:08:74:2c:df:9c
        groups: egress
        media: Ethernet 100baseTX full-duplex
        status: active
        inet6 fe80::208:74ff:fe2c:df9c%xl0 prefixlen 64 scopeid 0x1
        inet 192.168.1.37 netmask 0xfffffe00 broadcast 192.168.1.255
# <b>exit</b>
<i>...setup resumes...</i>
</pre></blockquote>

<a href="#backMoreNetwork">(back to where we might have been)</a>

<h3 id="MoreTimeZone">4.17.2 - Setting the Time Zone</h3>

Time in Unix is not a simple thing (or put another way, time in Unix is
a <i>really</i> simple thing and human time is a politically manipulated
mess).
Time zone files help the system convert Unix time (the number of seconds
past midnight GMT, Jan 1, 1970) to human time, taking into account things
like time zones, daylight savings time (DST), DST rule changes, etc.
They also include the history of changes.

<p>
Multiple time zone definition files will sometimes give the same
<i>current</i> time, but may have different history.
For example, EST5EDT and US/Michigan have the same time NOW, but back in
1975, the rules were different, so if you were doing math with dates and
times that involved 1975, you would care about the differences.
You should use the most specific and accurate timezone file you can for
your region, rather than one that just gives the correct time at this
moment.

<p>
OpenBSD's installer will help you find an appropriate time zone file for
you if you are not sure.
Simply hit <tt>?</tt> at each prompt, and the installer will show you options.
If the first level of answers doesn't suit you, pick a continent or
country, and look at your options there:

<blockquote><pre>
What timezone are you in? ('?' for list) [right/EST5EDT] <b>?</b>
Africa/      Chile/       GB-Eire      Israel       NZ-CHAT      UCT
America/     Cuba         GMT          Jamaica      Navajo       US/
Antarctica/  EET          GMT+0        Japan        PRC          UTC
Arctic/      EST          GMT-0        Kwajalein    PST8PDT      Universal
Asia/        EST5EDT      GMT0         Libya        Pacific/     W-SU
Atlantic/    Egypt        Greenwich    MET          Poland       WET
Australia/   Eire         HST          MST          Portugal     Zulu
Brazil/      Etc/         Hongkong     MST7MDT      ROC          posix/
CET          Europe/      Iceland      Mexico/      ROK          posixrules
CST6CDT      Factory      Indian/      Mideast/     Singapore    right/
Canada/      GB           Iran         NZ           Turkey
What timezone are you in? ('?' for list) [right/EST5EDT] <b>US</b>
What sub-timezone of 'US' are you in? ('?' for list) ?
Alaska          Central         Hawaii          Mountain        Samoa
Aleutian        East-Indiana    Indiana-Starke  Pacific
Arizona         Eastern         Michigan        Pacific-New
What sub-timezone of 'US' are you in? ('?' for list) <b>Michigan</b>
</pre></blockquote>

We've now set the time to "US/Michigan." This creates a symbolic link in
<tt>/etc</tt> pointing to the appropriate zoneinfo file in
<tt>/usr/share/zoneinfo</tt>, something like this:

<blockquote><pre>
/etc/localtime -> /usr/share/zoneinfo/US/Michigan
</pre></blockquote>

Note the directory <tt>right/</tt>, this directory includes leap second
adjustments, but otherwise duplicates the standard zoneinfo choices.
More <a href="faq8.html#NTPerror">here</a>.

<p>
<a href="#backMoreTimeZone">(back to where we might have been)</a>

<h3 id="Morefdisk">4.17.3 - Custom fdisk(8) layout</h3>

Note: only some OpenBSD platforms use fdisk at all, and usually, only
<a href="../i386.html">i386</a> and <a href="../amd64.html">amd64</a>
users will have to worry about getting fancy with fdisk.
Users of most other fdisk(8) using platforms generally don't have to
worry about multibooting or setup/diagnostic partitions.
For this reason, this section is focused on i386 and amd64.

<p>
<a href="http://man.openbsd.org/?query=fdisk">fdisk(8)</a>
is used to mark off the OpenBSD part of your hard disk.
It helps mark off the part of the disk used by OpenBSD from the parts used
by other OSs or system functions.

<p>
If you have a partition on your disk you wish to retain or wish to leave
space for another partition, you will NOT want to chose "(W)hole disk",
but will need to edit the partition table with
<a href="http://man.openbsd.org/?query=fdisk">fdisk(8)</a>.
More information on manually running fdisk(8) can be found
<a href="faq14.html#fdisk">here</a>.

<b>Before working with any system that has data you don't wish to lose,
make sure you have a good backup.</b>
It is very easy in this process to clobber important data, so make sure
you are ready to get it back, if need be.

<p>
If you are adding OpenBSD to an existing system, you will probably
need to create some free space on your system before installing OpenBSD.
This will usually involve deleting or possibly reducing the size of
existing partitions.
The program <a href="http://gparted.sourceforge.net/">gparted</a>
has been found useful for shrinking the partitions of many popular OSs,
making it possible to install OpenBSD on the freed space.

<p>
In this example, we will assume we are starting with a blank 40GB disk
and wish to create a multiboot system, reserving 5GB at the beginning
of the disk for Windows, and the rest for OpenBSD.
Note that a blank drive has to have valid MBR boot code and signature
written to the disk before it can be booted.

<p>
The process is very much the same for working around an existing
partition, you just need to skip over the parts where we create the
Windows partition and worry about installing the MBR boot code.

<blockquote><pre>
Available disks are: wd0.
Which one is the root disk? (or 'done') [wd0] <b>&lt;Enter&gt;</b>
MBR has invalid signature; not showing it.
</pre></blockquote>

If the disk had a valid MBR in place, it would show you the existing
partition table, which can be a good way to show if a disk may have
data on it already.

<blockquote><pre>
Use (W)hole disk or (E)dit the MBR? [whole] <b>e</b>

You will now create a single MBR partition to contain your OpenBSD data. This
partition must have an id of 'A6'; must *NOT* overlap other partitions; and
must be marked as the only active partition.  Inside the fdisk command, the
'manual' command describes all the fdisk commands in detail.

Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
Offset: 0       Signature: 0x0
            Starting         Ending         LBA Info:
 #: id      C   H   S -      C   H   S [       start:        size ]
-------------------------------------------------------------------------------
 0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
Enter 'help' for information
fdisk: 1>
</pre></blockquote>

First of all notice the fdisk prompt.
The number "1" indicates the first level of partition tables -- if you
were editing an extended partition, it would be "2" (or bigger).
Extended partitions are partitions which have their own sub-partition
table, getting around the IBM AT four partition design limit.
Extended partitions won't be covered here.

<p>
First, we will make partition "0" a 5GB Windows partition (using NTFS),
and partition "1" will be our OpenBSD partition using the rest of the
disk.

<blockquote><pre>
fdisk: 1> <b>e 0</b>
            Starting         Ending         LBA Info:
 #: id      C   H   S -      C   H   S [       start:        size ]
-------------------------------------------------------------------------------
 0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
Partition id ('0' to disable)  [0 - FF]: [0] (? for help)
</pre></blockquote>

Since we don't know by memory what the partition ID is for NTFS, we hit
"?" here to get a list.

<blockquote><pre>
Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>?</b>
Choose from the following Partition id values:
00 unused         20 Willowsoft     66 NetWare 386    A9 NetBSD
01 DOS FAT-12     24 NEC DOS        67 Novell         AB MacOS X boot
02 XENIX /        27 Win Recovery   68 Novell         AF MacOS X HFS+
03 XENIX /usr     38 Theos          69 Novell         B7 BSDI filesy*
04 DOS FAT-16     39 Plan 9         70 DiskSecure     B8 BSDI swap
05 Extended DOS   40 VENIX 286      75 PCIX           BF Solaris
06 DOS > 32MB     41 Lin/Minux DR   80 Minix (old)    C0 CTOS
07 NTFS           42 LinuxSwap DR   81 Minix (new)    C1 DRDOSs FAT12
08 AIX fs         43 Linux DR       82 Linux swap     C4 DRDOSs < 32M
09 AIX/Coherent   4D QNX 4.2 Pri    83 Linux files*   C6 DRDOSs >=32M
0A OS/2 Bootmgr   4E QNX 4.2 Sec    84 OS/2 hidden    C7 HPFS Disbled
0B Win95 FAT-32   4F QNX 4.2 Ter    85 Linux ext.     DB CPM/C.DOS/C*
0C Win95 FAT32L   50 DM             86 NT FAT VS      DE Dell Maint
0E DOS FAT-16     51 DM             87 NTFS VS        E1 SpeedStor
0F Extended LBA   52 CP/M or SysV   8E Linux LVM      E3 SpeedStor
10 OPUS           53 DM             93 Amoeba FS      E4 SpeedStor
11 OS/2 hidden    54 Ontrack        94 Amoeba BBT     EB BeOS/i386
12 Compaq Diag.   55 EZ-Drive       99 Mylex          EE EFI GPT
14 OS/2 hidden    56 Golden Bow     9F BSDI           EF EFI Sys
16 OS/2 hidden    5C Priam          A0 NotebookSave   F1 SpeedStor
17 OS/2 hidden    61 SpeedStor      A5 FreeBSD        F2 DOS 3.3+ Sec
18 AST swap       63 ISC, HURD, *   A6 OpenBSD        F4 SpeedStor
19 Willowtech     64 NetWare 2.xx   A7 NEXTSTEP       FF Xenix BBT
1C ThinkPad Rec   65 NetWare 3.xx   A8 MacOS X
Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>07</b>
</pre></blockquote>

Now we define its starting and ending points:

<blockquote><pre>
Do you wish to edit in CHS mode? [n]
</pre></blockquote>

CHS mode allows you to specify disk space in Cylinders, Heads and Sectors.
Keep in mind that for modern hard disks, the CHS numbers are completely
bogus, just three numbers that translate to a sector on the disk, which
is translated to your drives physical geometry (which probably varies
across the disk anyway).

<p>
If you answer "y" here, you will be prompted for the starting and
ending cylinder, head and sector.
If you answer "no" here (as we will), you will be prompted for starting
sector and the size.
Editing by CHS is often easier when working around an existing partition,
starting sector and size is often easier when you want to quickly create
a partition of a given size.

<blockquote><pre>
offset: [0] <b>64</b>
</pre></blockquote>

<a name="trackoffset"></a>
<p>
The fdisk platforms need a gap before the first partition.
The exact amount will not matter on modern machines, OpenBSD defaults
to 64 sectors.
This is recommended for performance reasons on modern disks, and does
not matter on older disks.

<blockquote><pre>
size: [0] <b>5g</b>
Rounding to nearest cylinder: 10490381
</pre></blockquote>

The "Size" value can be the number of sectors (512 bytes each), or the
desired capacity when followed by a "k", "m" or "g".
When editing using offset and size, fdisk will round your partition so
it ends on a cylinder boundary (OpenBSD doesn't care about this, and it
is possible no modern OS cares about this, but some might have at one
time).

<p>
Now, let's look at our new partition:

<blockquote><pre>
fdisk:*1> p
Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
Offset: 0       Signature: 0x0
            Starting         Ending         LBA Info:
 #: id      C   H   S -      C   H   S [       start:        size ]
-------------------------------------------------------------------------------
 0: 07      0   1   2 -    652 254  63 [          64:    10490381 ] NTFS
 1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
fdisk:*1>
</pre></blockquote>

Note that the prompt now includes an "*", this means there are unsaved
changes.

<p>
We've now created our Windows partition.
Note that this partition is so far just reserved space on the disk, it
isn't formatted; no file system exists here.
You will worry about that when you install Windows; we've accomplished
our goal of reserving space for the Windows partition to be created
later.

<p>
Now we create our OpenBSD partition.
In this case, the partition ID will be "A6".

<blockquote><pre>
fdisk:*1> e 1
            Starting         Ending         LBA Info:
 #: id      C   H   S -      C   H   S [       start:        size ]
-------------------------------------------------------------------------------
 1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>a6</b>
Do you wish to edit in CHS mode? [n] <b>&lt;Enter&gt;</b>
offset: [0]
</pre></blockquote>

Uh-oh!
What's our offset?  Simple -- the offset of the previous partition plus
the size of the partition, in this case, 64+10490381 = 10490445.

<blockquote><pre>
offset: [0] <b>10490445</b>
size: [0] <b>*</b>
fdisk:*1>
</pre></blockquote>

Note that here, we entered "*" as the size, meaning "rest of the disk".
Again, we could have entered the size in sectors, "m" or "g" if we
wanted to leave space for something else.

<p>
Now we look at our partition table:

<blockquote><pre>
fdisk:*1> <b>p</b>
Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
Offset: 0       Signature: 0x0
            Starting         Ending         LBA Info:
 #: id      C   H   S -      C   H   S [       start:        size ]
-------------------------------------------------------------------------------
 0: 07      0   1   1 -    652 254  63 [          64:    10490381 ] NTFS
 1: A6    653   0   1 -   4998   5  63 [    10490445:    69802803 ] OpenBSD
 2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
fdisk:*1>
</pre></blockquote>

<b>WE AREN'T DONE YET!</b><br>
This disk is not yet bootable!
As it was a brand new disk, the disk's
<a href="faq14.html#BootAmd64">MBR</a> was completely blank.
The "Signature: 0x0" message there shows there is not a valid signature
(0xAA55), which indicates there definitely is not a valid boot code.
Of course, you could have a valid signature without valid boot code,
through either random bad luck or damage to the existing boot code, but
an invalid signature pretty well indicates you are lacking boot code, so
we will install it now using the "update" command:

<blockquote><pre>
fdisk:*1> <b>update</b>
Machine code updated.
fdisk:*1>
</pre></blockquote>

We also have to "flag" a partition as "active" so the boot ROM knows
what partition to boot from:

<blockquote><pre>
fdisk:*1> <b>f 1</b>
Partition 1 marked active.
</pre></blockquote>

Now, let's see how it looks:

<blockquote><pre>
fdisk:*1> <b>p</b>
Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
Offset: 0       Signature: 0xAA55
            Starting         Ending         LBA Info:
 #: id      C   H   S -      C   H   S [       start:        size ]
-------------------------------------------------------------------------------
 0: 07      0   1   1 -    652 254  63 [          64:    10490381 ] NTFS
*1: A6    653   0   1 -   4998   5  63 [    10490445:    69802803 ] OpenBSD
 2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
fdisk:*1>
</pre></blockquote>

A checklist of things you want to make sure about before you exit
fdisk(8):

<ul>
<li>Valid signature?
<li>non-overlapping partitions?
<li>OpenBSD partition with an "A6" id?
<li>Proper partition (probably OpenBSD) flagged active?
</ul>

<a href="#BackMorefdisk">(back to where we may have been)</a>

<h3 id="Moredisklabel">4.17.4 - Custom disklabel layout</h3>

Inside the OpenBSD fdisk(8) partition, we use
<a href="http://man.openbsd.org/?query=disklabel">disklabel(8)</a>
to create OpenBSD file system partitions.
OpenBSD labels its file system partitions using sixteen letters, "a"
through "p".
Partition "a" on the boot disk is defined as the root partition,
"b" on the boot disk is the default swap partition.
"c" on all disks is the "whole disk" partition, it is used by programs
that have to have raw access to the physical disk, such as fdisk(8)
and disklabel(8).
The "c" partition is created automatically for you, and should not be
deleted or changed.
The remaining letters are available for you to define mount points on.
You may skip letters, you can define them in any order, and they can be
in any order on the disk (although some platforms do have a requirement
for where the "a" partition is).
You can also leave gaps in the disk that are unallocated, and allocate
them later, or potentially enlarge existing partitions later into that
unallocated space using
<a href="http://man.openbsd.org/?query=growfs">growfs(8)</a>.

<p>
All partitions which have native FFS partitions on them should be within
the OpenBSD fdisk(8) partition, however
<a href="faq14.html#foreignfs">non-OpenBSD</a> partitions can (and
usually should) be outside the OpenBSD fdisk partition.

<p>
More information on using disklabel can be found
<a href="faq14.html#disklabel">here</a>.

<p>
More information on the benefits of partitioning and strategies for
creating a good partitioning plan are <a href="#Partitioning">below</a>.

<p>
The OpenBSD installer will attempt to auto-partition your
disk in a usable, "general purpose" configuration, based on the size of
your disk.
If your disk is big enough, unused space will be allocated to the
<tt>/home</tt> partition.
While this is often quite useful, it doesn't satisfy all users' needs.

<p>
For our example, we'll assume we are building a static web server
for some of our friends to use.
We have a machine attached to a modest Internet connection, with a 40GB
disk, with most of it used for OpenBSD (with the same 5GB Windows
partition as the example above.
Why?  Maybe this system has a RAID controller which is supported by
OpenBSD, but manageable only from within Windows.
More likely, because the FAQ editor doesn't feel like maintaining lots
of different example systems).

<p>
The web pages served by an OpenBSD web server will be in
<tt>/var/www</tt>, and very little will be stored in <tt>/home</tt>, so
this indicates a definite change from the default that needs to be made.
For the sake of discussion, we'll also assume that we won't need to
rebuild the OS from source on this machine (we'll do that elsewhere).
The system will not run X, however being that some web applications
<a href="#FilesNeededX">expect X to be installed</a>, we will have X
installed.
The machine is not overly powerful, it can't have more than 1GB RAM in
it, and it is unlikely our application will ever desire more than that.

<p>
So, after a bit of thought, our plan is to partition the system like
this:
<ul>
<li><tt>/ - root</tt>: 100MB.  This will be 'a'.
<li><tt>swap</tt>: 1GB (so we'll always have enough space for a core dump),
 this will be partition 'b'
<li><tt>/usr</tt>: 2GB, partition d
<li><tt>/tmp</tt>: 100MB (we don't anticipate much use of this), partition e
<li><tt>/usr/local</tt>: 2GB, partition f
<li><tt>/usr/X11R6</tt>: 1GB, partition g
<li><tt>/home</tt>: 1GB, partition h
<li><tt>/var</tt>: 1GB (that's a lot of system log files), partition j
<li><tt>/var/www</tt>: rest of disk, partition k
</ul>

<blockquote><pre>
The auto-allocated layout for wd0 is:
#                size           offset  fstype [fsize bsize  cpg]
  a:          1024.0M         10490445  4.2BSD   2048 16384    1 # /
  b:           252.1M         12587597    swap
  c:         39205.7M                0  unused
  d:          2319.3M         13103933  4.2BSD   2048 16384    1 # /tmp
  e:          3653.9M         17853877  4.2BSD   2048 16384    1 # /var
  f:          1149.8M         25337016  4.2BSD   2048 16384    1 # /usr
  g:          1024.0M         27691862  4.2BSD   2048 16384    1 # /usr/X11R6
  h:          3422.6M         29789014  4.2BSD   2048 16384    1 # /usr/local
  i:          5122.3M               63    NTFS
  j:          1848.7M         36798433  4.2BSD   2048 16384    1 # /usr/src
  k:          1848.7M         40584654  4.2BSD   2048 16384    1 # /usr/obj
  l:         17540.2M         44370875  4.2BSD   2048 16384    1 # /home
Use (A)uto layout, (E)dit auto layout, or create (C)ustom layout? [a] <b>c</b>
</pre></blockquote>

If we had only minor revisions, we'd probably opt to "Edit" the custom
layout rather than starting from a clean slate, but we are going to do
things the hard way here.

<blockquote><pre>
You will now create an OpenBSD disklabel inside the OpenBSD MBR
partition. The disklabel defines how OpenBSD splits up the MBR partition
into OpenBSD partitions in which filesystems and swap space are created.
You must provide each filesystem's mountpoint in this program.

The offsets used in the disklabel are ABSOLUTE, i.e. relative to the
start of the disk, NOT the start of the OpenBSD MBR partition.

Label editor (enter '?' for help at any prompt)
> <b>p</b>
OpenBSD area: 10490445-80293248; size: 69802803; free: 69802803
#                size           offset  fstype [fsize bsize  cpg]
  c:         80293248                0  unused
  i:         10490381               64    NTFS
>
</pre></blockquote>

Note there are already two partitions here -- the "c" partition which is
always there and created for you, but disklabel(8) has also noticed the
existing NTFS partition and assigned it a disklabel partition so it
could potentially be accessed by OpenBSD (note, at this time, NTFS
support is experimental and requires a custom kernel but FAT/FAT32
support is quite good).

<p>
We will now create our partitions.
We will start with the "a" partition, our root partition:

<blockquote><pre>
> <b>a a</b>
offset: [10490445] <b>&lt;Enter&gt;</b>
size: [69802803] <b>100m</b>
Rounding to cylinder: 208845
FS type: [4.2BSD]  <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
>
</pre></blockquote>

Note that disklabel defaulted to the first available OpenBSD sector on
the disk, which is what we want.
It also defaulted to a size of all available space, which is NOT what we
want.
Here we overrode it with our preferred size, which can be specified in
sectors, "M" or "G" here.

<p>
You will usually want to use the default FS type of "4.2BSD" for a
FFS (Fast File System) or FFS2 partition, though other types you may find
useful include "swap" and "RAID."

<p>
Finally is the mount point.
Our "a" partition is the root partition, by definition.

<p>
Now, we do swap, which is our 'b' partition (again, this is a
requirement -- 'b' on your boot disk is swap):

<blockquote><pre>
> <b>a b</b>
offset: [10699290] <b>&lt;Enter&gt;</b>
size: [69593958] <b>1g</b>
Rounding to cylinder: 2104515
FS type: [swap] <b>&lt;Enter&gt;</b>
>
</pre></blockquote>

Again, disklabel correctly calculated our starting sector, and presented
us with a suggested size of "entire remaining space", which we again
overrode with our desired size.
Since this is the 'b' partition, disklabel assumed it was to be used
for swap, and when we confirmed that, it didn't bother to ask us a
mount point.

<p>
We are now ready to create the rest of the partitions.

<blockquote><pre>
> <b>a d</b>
offset: [12803805] <b>&lt;Enter&gt;</b>
size: [67489443] <b>2g</b>
Rounding to cylinder: 4209030
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/usr</b>
> <b>a e</b>
offset: [17012835] <b>&lt;Enter&gt;</b>
size: [63280413] <b>100m</b>
Rounding to cylinder: 208845
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
> <b>a f</b>
offset: [17221680] <b>&lt;Enter&gt;</b>
size: [63071568] <b>2g</b>
Rounding to cylinder: 4209030
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/usr/local</b>
> <b>a g</b>
offset: [21430710] <b>&lt;Enter&gt;</b>
size: [58862538] <b>1g</b>
Rounding to cylinder: 2104515
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/usr/X11R6</b>
> <b>a h</b>
offset: [23535225] <b>&lt;Enter&gt;</b>
size: [56758023] <b>1g</b>
Rounding to cylinder: 2104515
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/home</b>
> <b>a j</b>
offset: [25639740] <b>&lt;Enter&gt;</b>
size: [54653508] <b>1g</b>
Rounding to cylinder: 2104515
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
> <b>a k</b>
offset: [27744255] <b>&lt;Enter&gt;</b>
size: [52548993] <b>&lt;Enter&gt;</b>
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var/www</b>
>
</pre></blockquote>

Note that on the <tt>/var/www</tt> partition ("k"), we just took the
default to use all remaining available disk space.
With modern monstrously huge drives, this is usually a bad idea.
If you know you will never use it, don't allocate it, and save it for
some future use.

<p>
Now, let's look at our results, using the "p" and "p m" commands:

<blockquote><pre>
> <b>p</b>
OpenBSD area: 10490445-80293248; size: 69802803; free: 0
#                size           offset  fstype [fsize bsize  cpg]
  a:           208845         10490445  4.2BSD   2048 16384    1 # /
  b:          2104515         10699290    swap
  c:         80293248                0  unused
  d:          4209030         12803805  4.2BSD   2048 16384    1 # /usr
  e:           208845         17012835  4.2BSD   2048 16384    1 # /tmp
  f:          4209030         17221680  4.2BSD   2048 16384    1 # /usr/local
  g:          2104515         21430710  4.2BSD   2048 16384    1 # /usr/X11R6
  h:          2104515         23535225  4.2BSD   2048 16384    1 # /home
  i:         10490381               64    NTFS
  j:          2104515         25639740  4.2BSD   2048 16384    1 # /var
  k:         52548993         27744255  4.2BSD   2048 16384    1 # /var/www
> <b>p m</b>
OpenBSD area: 10490445-80293248; size: 34083.4M; free: 0.0M
  #                size           offset  fstype [fsize bsize  cpg]
  a:           102.0M         10490445  4.2BSD   2048 16384    1 # /
  b:          1027.6M         10699290    swap
  c:         39205.7M                0  unused
  d:          2055.2M         12803805  4.2BSD   2048 16384    1 # /usr
  e:           102.0M         17012835  4.2BSD   2048 16384    1 # /tmp
  f:          2055.2M         17221680  4.2BSD   2048 16384    1 # /usr/local
  g:          1027.6M         21430710  4.2BSD   2048 16384    1 # /usr/X11R6
  h:          1027.6M         23535225  4.2BSD   2048 16384    1 # /home
  i:          5122.3M               64    NTFS
  j:          1027.6M         25639740  4.2BSD   2048 16384    1 # /var
  k:         25658.7M         27744255  4.2BSD   2048 16384    1 # /var/www
>
</pre></blockquote>

Like with fdisk, you don't want your OpenBSD disklabel partitions to
overlap (other than the 'c' partition, which overlaps everything, of
course).

<p>
Write your changes and quit disklabel:

<blockquote><pre>
> <b>w</b>
> <b>q</b>
No label changes.
newfs: reduced number of fragments per cylinder group from 13048 to 12992 to
enlarge last cylinder group
/dev/rwd0a: 102.0MB in 208844 sectors of 512 bytes
5 cylinder groups of 25.38MB, 1624 blocks, 3328 inodes each
/dev/rwd0h: 1027.6MB in 2104512 sectors of 512 bytes
6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
newfs: reduced number of fragments per cylinder group from 13048 to 12992 to
enlarge last cylinder group
/dev/rwd0e: 102.0MB in 208844 sectors of 512 bytes
5 cylinder groups of 25.38MB, 1624 blocks, 3328 inodes each
/dev/rwd0d: 2055.2MB in 4209028 sectors of 512 bytes
11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
/dev/rwd0g: 1027.6MB in 2104512 sectors of 512 bytes
6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
/dev/rwd0f: 2055.2MB in 4209028 sectors of 512 bytes
11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
/dev/rwd0j: 1027.6MB in 2104512 sectors of 512 bytes
6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
/dev/rwd0k: 25658.7MB in 52548992 sectors of 512 bytes
127 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
/dev/wd0a on /mnt type ffs (rw, asynchronous, local)
/dev/wd0h on /mnt/home type ffs (rw, asynchronous, local, nodev, nosuid)
/dev/wd0e on /mnt/tmp type ffs (rw, asynchronous, local, nodev, nosuid)
/dev/wd0d on /mnt/usr type ffs (rw, asynchronous, local, nodev)
/dev/wd0g on /mnt/usr/X11R6 type ffs (rw, asynchronous, local, nodev)
/dev/wd0f on /mnt/usr/local type ffs (rw, asynchronous, local, nodev)
/dev/wd0j on /mnt/var type ffs (rw, asynchronous, local, nodev, nosuid)
/dev/wd0k on /mnt/var/www type ffs (rw, asynchronous, local, nodev, nosuid)

Let's install the sets!
...
</pre></blockquote>

<h2 id="AddThoughts">4.17 - Some additional thoughts on partitioning</h2>

<ul>
 <li>For your first attempt at an experimentation system, one big
 <tt>/</tt> partition and swap may be easiest until you know how much
 space you need.
 By doing this, you will be sacrificing some of the default security
 features of OpenBSD that require separate filesystems for
 <tt>/</tt>, <tt>/tmp</tt>, <tt>/var</tt>, <tt>/usr</tt> and <tt>/home</tt>.
 However, you probably should not be going into production with your
 first OpenBSD install.
 <li>A system exposed to the Internet or other hostile forces should
 have a separate <tt>/var</tt> (and maybe even a separate
 <tt>/var/log</tt>) for logging.
 <li>A <tt>/home</tt> partition can be nice.
 New version of the OS?
 Wipe and reload everything else, leave your <tt>/home</tt> partition
 untouched.
 Remember to save a copy of your configuration files, though!
 <li>A separate partition for anything which may accumulate a large
 quantity of files that may need to be deleted can be faster to
 reformat and recreate than to delete.
 See the <a href="faq5.html#ProbObjPt">building from source FAQ</a>
 for an example (<tt>/usr/obj</tt>).
 <li>If you wish to rebuild your system from source for any reason,
 the source will be in <tt>/usr/src</tt>.
 <b>If you don't make a separate partition for <tt>/usr/src</tt>,
 make sure <tt>/usr</tt> has sufficient space.</b>
 <li>A commonly forgotten fact: you do <b>not</b> have to allocate
 all space on a drive when you set the system up!
 Since you will now find it a challenge to buy a new drive smaller than 100GB,
 it can make sense to leave a chunk of your drive unallocated.
 If you outgrow a partition, you can allocate a new partition from
 your unused space, <a href="faq10.html#DupFS">duplicate</a> your existing
 partition to the new partition, change
 <a href="http://man.openbsd.org/?query=fstab">/etc/fstab</a>
 to point to the new partition, remount, you now have more space.
 <li>If you make your partitions too close to the minimum size required,
 you will probably regret it later, when it is time to upgrade your
 system.
 <li>If you make very large partitions, keep in mind that performing
 filesystem checks using
 <a href="http://man.openbsd.org/?query=fsck">fsck(8)</a>
 requires about 1MB of RAM per gigabyte of filesystem size, and may be
 very time-consuming or not even feasible on older, slower systems.
 <li>If you permit users to write to <tt>/var/www</tt> (i.e., personal
 web pages), you might wish to put it on a separate partition, so you
 can use <a href="faq10.html#Quotas">quotas</a> to restrict the space
 they use, and if they fill the partition, no other parts of your
 system will be impacted.
 <li>You may also want to create an <tt>/altroot</tt> partition, as
 described in
 <a href="http://man.openbsd.org/?query=daily">daily(8)</a>.
 This can make a daily copy of your <tt>/</tt> partition, giving you
 an extra copy of your kernel and <tt>/etc</tt> configuration files should
 something happen to your root partition.
 Obviously, the <tt>/altroot</tt> partition needs to be at least as big
 as <tt>/</tt>.
 If you have a second drive and have something else duplicating the
 rest of your disk, either software
 <a href="http://man.openbsd.org/?query=softraid">softraid(4)</a>
 or a periodic copy using
 <a href="http://man.openbsd.org/?query=dump">dump(8)</a> and
 <a href="http://man.openbsd.org/?query=restore">restore(8)</a>,
 this disk can be bootable after the removal of the primary disk.
 <li>Compiling some <a href="faq15.html#Ports">ports</a> from source
 can take huge amounts of space on your <tt>/usr</tt> and <tt>/tmp</tt>
 partitions.
 This is another reason we suggest using
 <a href="faq15.html#PkgMgmt">pre-compiled packages</a> instead.
 <li>At least some editors use <tt>/tmp</tt> for scratch space, and
 this often needs to be as big or bigger than the largest file you edit.
 If you plan on editing 500MB files, your <tt>/tmp</tt> partition will
 need to be much larger than you might have planned on.
</ul>
<a href="#BackMoredisklabel">(back to where we may have been)</a>
<p>
<hr>
<p>
<a href= "index.html">[FAQ Index]</a>
<a href= "faq3.html">[To Section 3 - Getting started with OpenBSD]</a>
<a href= "faq5.html">[To Section 5 - Building the System from Source]</a>
</body>
</html>
