<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

<!-- If you make edits to any FAQ documents, please start each sentence
     on a new line, and try to keep the general formatting consistent
     with the rest of the pages -->

<title>14 - Disk Setup</title>
<meta name= "description"       content="OpenBSD FAQ 14 - Disk Setup">
<meta name= "copyright"         content="This document copyright 1998-2016
                                         by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="canonical" href="http://www.openbsd.org/faq/faq14.html">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif" border="0">
</a>
<p>
<a href= "index.html">[FAQ Index]</a>
<a href= "faq13.html">[To Section 13 - Multimedia]</a>
<a href= "faq15.html">[To Section 15 - Packages and Ports]</a>

<h1><font color="#e00000">14 - Disk Setup</font></h1><hr>

<h3>Table of Contents</h3>

<ul>
<li><a href="#intro"           >14.1 - Disks and partitions</a>
<li><a href="#fdisk"           >14.2 - Using OpenBSD's fdisk(8)</a>
<li><a href="#disklabel"       >14.3 - Using OpenBSD's disklabel(8)</a>
<li><a href="#SoftUpdates"     >14.4 - Soft updates</a>
<li><a href="#Boot386"         >14.5 - How do OpenBSD/i386 and OpenBSD/amd64
                                boot?</a>
<li><a href="#LargeDrive"      >14.6 - What are the issues regarding large
                                drives with OpenBSD?</a>
<li><a href="#InstBoot"        >14.7 - Installing bootblocks (most, but not
                                all platforms)</a>
<li><a href="#Backup"          >14.8 - Preparing for disaster: backing up
                                and restoring from tape</a>
<li><a href="#MountImage"      >14.9 - Mounting disk images in OpenBSD</a>
<li><a href="#pciideErr"       >14.10 - Help! I'm getting errors with IDE
                                DMA!</a>
<li><a href="#NegSpace"        >14.11 - Why does <tt>df(1)</tt> tell me
                                I have over 100% of my disk used?</a>
<li><a href="#OhBugger"        >14.12 - Recovering partitions after deleting
                                the disklabel</a>
<li><a href="#foreignfs"       >14.13 - Can I access data on filesystems other
                                than FFS?</a>
<ul>
  <li><a href="#foreignfsafter">14.13.1 - The partitions are not in my
                                disklabel! What should I do?</a>
</ul>
<li><a href="#flashmem"        >14.14 - Can I use a flash memory device with
                                OpenBSD?</a>
  <ul>
  <li><a href="#flashmemUSB"   >14.14.1 - Flash memory as a portable storage
                                device</a>
  <li><a href="#flashmemBoot"  >14.14.2 - Flash memory as bootable storage</a>
  <li><a href="#flashmemLive"  >14.14.3 - How can I make a "live" bootable
                                USB device?</a>
  </ul>
<li><a href="#DiskOpt"         >14.15 - Optimizing disk performance</a>
  <ul>
  <li><a href="#Optsoftu"      >14.15.1 - Soft updates</a>
  <li><a href="#Optmaxvnodes"  >14.15.2 - Size of the namei(9) cache</a>
  </ul>
<li><a href="#Async"           >14.16 - Why aren't we using async mounts?</a>
<li><a href="#altroot"         >14.17 - Duplicating your root partition:
                                altroot</a>
<li><a href="#softraid"        >14.18 - How do I use softraid?</a>
  <ul>
  <li><a href="#softraidDI"    >14.18.1 - Installing to a mirror</a>
  <li><a href="#softraidFDE"   >14.18.2 - Full disk encryption</a>
  <li><a href="#softraidCrypto">14.18.3 - Encrypting external disks</a>
  <li><a href="#softraidDR"    >14.18.4 - Disaster recovery</a>
  <li><a href="#softraidNotes" >14.18.5 - Softraid notes</a>
  </ul>
</ul>
<hr>

<h2 id="intro">14.1 - Disks and partitions</h2>

The details of setting up disks in OpenBSD vary between platforms, so
you should read the installation instructions in the
<tt>INSTALL.&lt;arch&gt;</tt> file for your
<a href="../plat.html">platform</a>
to determine the specifics for your system.

<h3>Drive identification</h3>

OpenBSD handles mass storage with two drivers on most platforms,
depending upon the normal command set that kind of device supports:

<ul>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd">wd(4)</a>:
    IDE-like disks: IDE, SATA, MFM or ESDI disks, or a flash device
    with an appropriate adapter, attached to a
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wdc">wdc(4)</a>
    or
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide">pciide(4)</a>
    interface.
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd">sd(4)</a>:
    SCSI-like disks:
    Devices that utilize SCSI commands, USB disks, SATA disks attached to an
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci">ahci(4)</a>
    interface, and disk arrays attached to a RAID controller.
</ul>

The first drive of a particular type identified by OpenBSD will be
drive <tt>0</tt>, the second will be <tt>1</tt>, etc.
So, the first IDE-like disk will be <tt>wd0</tt>, the third SCSI-like disk will
be <tt>sd2</tt>.
If you have two SCSI-like drives and three IDE-like drives on a system,
you would have <tt>sd0</tt>, <tt>sd1</tt>, <tt>wd0</tt>, <tt>wd1</tt> and
<tt>wd2</tt> on that machine.
The order is based on the order they are found during hardware discovery
at boot.
There are a few key points to keep in mind:

<ul>
  <li>
    Drives may not be numbered in the same order as your boot ROM
    attempts to boot them (i.e., your system may attempt to boot what OpenBSD
    identifies as <tt>wd2</tt> or <tt>sd1</tt>).
    Sometimes you may be able to change this, sometimes not.
  <li>Removing or adding a disk may impact the identity of other drives on
    the system.
</ul>

<h3>Partitioning</h3>

Due to historical reasons, the term "partition" is regularly used for
two different things in OpenBSD:

<ul>
  <li>
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
    disklabel(8)</a> partitions, often called filesystem partitions.
  <li>
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk">fdisk(8)</a>
    partitions, often called Master Boot Record (MBR) partitions.
</ul>

All OpenBSD platforms use disklabel(8) as the primary way to manage
OpenBSD filesystem partitions.
Some platforms also require using fdisk(8) to manage MBR partitions.
On the platforms that use them, one fdisk partition is used
to hold all of the OpenBSD file systems.
This partition is then sliced up into 16 disklabel partitions,
labeled <tt>a</tt> through <tt>p</tt>.
A few of these are special:

<ul>
  <li><tt>a</tt>:
    On the boot disk, the <tt>a</tt> partition is your root partition.
  <li><tt>b</tt>:
    On the boot disk, the <tt>b</tt> partition is automatically used
    as a swap partition.
  <li><tt>c</tt>:
    On all disks, the <tt>c</tt> partition is the entire disk, from the
    first sector to the last.
</ul>

<h3>Partition identification</h3>

An OpenBSD filesystem is identified by the disk it is on, plus the
disklabel partition on that disk.
So, file systems may be identified by identifiers like <tt>sd0a</tt>
(the <tt>a</tt> partition of the first <tt>sd</tt> device),
<tt>wd2h</tt> (the <tt>h</tt> partition of the third <tt>wd</tt> device),
or <tt>sd1c</tt> (the entire second <tt>sd</tt> device).
The device files would be <tt>/dev/sd0a</tt> for the block device,
<tt>/dev/rsd0a</tt> would be the device file for the raw (character)
device.

<p>
If you put data on <tt>wd2d</tt>, then later remove <tt>wd1</tt>
from the system and reboot, your data is now on <tt>wd1d</tt>, as your old
<tt>wd2</tt> is now <tt>wd1</tt>.
However, a drive's identification won't change after boot, so if
a USB drive is unplugged or fails, it won't change the identification
of other drives until reboot.

<h3 id="DUID">Disklabel Unique Identifiers</h3>

Disks can also be identified by Disklabel Unique Identifiers (DUIDs), a
16 hex digit number, managed by the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskmap">diskmap(4)</a>
device.
This number is a random number generated when a disklabel is first created.
These UIDs are persistent -- if you identify your disks this way,
drive <tt>f18e359c8fa2522b</tt> will always be <tt>f18e359c8fa2522b</tt>,
no matter what order or how it is attached.
You can specify partitions on the disk by appending a period and the
partition letter, for example, <tt>f18e359c8fa2522b.d</tt> is the <tt>d</tt>
partition of the disk <tt>f18e359c8fa2522b</tt> and will always refer
to the same chunk of storage, no matter what order the device is attached
to the system, or what kind of interface it is attached to.

<h2 id="fdisk">14.2 - Using fdisk(8)</h2>

Be sure to check the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk">fdisk(8)</a>
man page.

<p>
fdisk(8) is used on some platforms (i386, amd64, macppc, zaurus and
armish) to create a partition recognized by the system boot ROM, into
which the OpenBSD disklabel partitions can be placed.
Unlike the fdisk-like programs on some other operating systems,
OpenBSD's fdisk(8) assumes you know what you want to do.

<p>
Normally, only one OpenBSD fdisk partition will be placed on a disk.
That partition will be subdivided by <a href="#disklabel">disklabel</a>
into OpenBSD filesystem partitions.

<p>
To just view your partition table using fdisk, use:

<blockquote><pre>
# <b>fdisk sd0</b>
</pre></blockquote>

Which will give an output similar to this:

<blockquote><pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
</pre></blockquote>

In this example, we are viewing the fdisk output of the first SCSI-like drive.
We can see the OpenBSD partition (id <tt>A6</tt>) and its size.
The <tt>*</tt> tells us that the OpenBSD partition is the bootable partition.

<p>
In the previous example, we just viewed our information.
In order to edit the partition table use the <tt>-e</tt> flag:

<blockquote><pre>
# <b>fdisk -e sd0</b>
Enter 'help' for information
fdisk: 1>
</pre></blockquote>

<h3>fdisk tricks and tips</h3>

<ul>
  <li>
    fdisk(8) offers the ability to specify partitions both in raw sectors
    and in Cylinder/Head/Sector formats.
  <li>
    A totally blank disk will need to have the master boot record's boot code
    written to the disk before it can boot.
    You can use the <tt>reinit</tt> or <tt>update</tt> commands to do this.
  <li>
    If your system has a "maintenance" or "diagnostic" partition, it is
    recommended that you leave it in place or install it <b>before</b>
    installing OpenBSD.
  <li>
    For historical reasons, <tt>q</tt> saves changes and exits the program,
    and <tt>x</tt> exits without saving.
    This is the opposite of what many people are now used to in other
    environments.
    fdisk(8) does not warn before saving the changes, so use with care.
</ul>

<h2 id="disklabel">14.3 - Using OpenBSD's disklabel(8)</h2>

<h3 id="disklabel.1">What is disklabel(8)?</h3>

First, be sure to read the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
disklabel(8)</a>
man page.

<p>
The details of setting up disks in OpenBSD varies somewhat between
platforms.
For <a href="../i386.html">i386</a>,
<a href="../amd64.html">amd64</a>,
<a href="../macppc.html">macppc</a>,
<a href="../zaurus.html">zaurus</a>,
and <a href="../armish.html">armish</a>,
disk setup is done in two stages:
First, the OpenBSD slice of the hard disk is defined using fdisk(8),
then that slice is subdivided into OpenBSD partitions using
disklabel(8).

<p>
All OpenBSD platforms, however, use disklabel(8) as the primary way to
manage OpenBSD partitions.
Labels hold certain information about your disk, like your drive
geometry and information about the filesystems on the disk.
The disklabel is then used by the bootstrap program to access the drive and
to know where filesystems are contained on the drive.
You can read more in-depth information about disklabel in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sec=5">
disklabel(5)</a>
man page.

<p>
On some platforms, disklabel helps overcome architecture limitations on
disk partitioning.
For example, on i386, you can have four primary partitions.
With
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
disklabel(8)</a>,
you use one of these primary partitions to store all of your OpenBSD partitions,
and you will still have 3 more partitions available for other OSs.

<h3 id="disklabel.2">disklabel(8) during OpenBSD's install</h3>

By default, the installer will allocate disklabels automatically.
For an example of setting up a custom disklabel(8) during install, see the
<a href="faq4.html#Moredisklabel">custom disklabel layout</a> part of the
<a href="faq4.html">installation guide</a>.

<h3>Disklabel basics</h3>

<ul>
  <li><b>Get help:</b>
    In the command-driven mode, hitting <tt>?</tt> will produce a list of
    available commands.
    <tt>M</tt> will show the man page for disklabel(8).
  <li><b>Auto-partitioning:</b>
    New users are encouraged to use the <tt>A</tt> command to auto-create a
    recommended disklabel.
    You can then edit or alter the auto-created label as you need.
  <li><b>Reset to default:</b>
    In some cases, you may wish to completely restart from scratch and
    delete all existing disklabel information.
    The "D" command will reset the label back to default, as if there had
    never been a disklabel on the drive.
  <li><b><tt>q</tt> vs. <tt>x</tt>:</b>
    For historical reasons, while in the command-driven editor mode, <tt>q</tt>
    saves changes and exits the program, and "x" exits without saving.
    This is the opposite of what many people are now used to in other
    environments.
    disklabel(8) does warn before saving the changes, though it will <tt>x</tt>
    quickly and quietly.
</ul>

<h3>Miscellaneous disklabel tidbits</h3>

<ul>
  <li>(fdisk platforms) <b>Leave first track free:</b>
    On platforms using fdisk(8), you should leave the first logical track
    unused, both in disklabel(8) and in fdisk(8).
    For this reason, OpenBSD defaults to starting the first partition at
    block 64.
  <li>(sparc/sparc64) <b>Don't put swap at the very beginning of your disk.</b>
    While Solaris often puts swap at the very beginning of a disk, OpenBSD
    requires the boot partition to be at the beginning of the disk.
  <li><b>Devices without a disklabel:</b>
    If a device does not currently have an OpenBSD disklabel on it but has
    another file system (for example, a disk with a pre-existing FAT32 file
    system), the OpenBSD kernel will "create" one in memory, and that can form
    the basis of a formal OpenBSD disklabel to be stored on disk.
    However, if a disklabel is created and saved to disk, and a non-OpenBSD
    file system is added later, the disklabel will not be automatically
    updated.
    You must do this yourself if you wish OpenBSD to be able to access this
    file system.
    More on this <a href="faq14.html#foreignfsafter">below</a>.
</ul>

<h2 id="SoftUpdates">14.4 - Soft updates</h2>

Soft updates are based on an idea proposed by
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg Ganger
and Yale Patt</a> and developed for FreeBSD by
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a>.
Soft updates imposes a partial ordering on the buffer cache
operations which permits the requirement for synchronous writing of
directory entries to be removed from the FFS code.
A large performance increase is seen in diskwriting performance as a result.

<p>
Enabling soft updates must be done with a mount-time option.
When mounting a partition with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount">mount(8)</a>
utility, you can specify that you wish to have soft updates enabled on
that partition.
Below is a sample
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab">fstab(5)</a>
entry that has one partition <i>sd0a</i> that we wish to have mounted
with soft updates.

<blockquote><pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre></blockquote>

Note to sparc users: Do not enable soft updates on sun4 or sun4c machines.
These architectures support only a very limited amount of kernel memory and
cannot use this feature.
However, sun4m machines are fine.

<a name="BootAmd64"></a><h2 id="Boot386">14.5 - How do OpenBSD/i386 and
OpenBSD/amd64 boot?</h2>

The boot process for OpenBSD/i386 and OpenBSD/amd64 is not trivial, and
understanding how it works can be useful to troubleshoot a problem when
things don't work.
There are four key pieces to the boot process:

<ol>
  <li><b><i>Master Boot Record (MBR):</i></b>
    The Master Boot Record is the first 512 bytes on the disk.
    It contains the primary partition table and a small program to load the
    Partition Boot Record (PBR).
    Note that in some environments, the term "MBR" is used to refer to only
    the code portion of this first block on the disk, rather than the whole
    first block (including the partition table).
    It is critical to understand the meaning of "initialize the MBR" -- in
    the terminology of OpenBSD, it would involve rewriting the entire MBR,
    clearing any existing partition table, not just the code, as it
    might on some systems.
    You will often not want to do this.
    Instead, use fdisk(8)'s "-u" command line option
    (<tt>fdisk -u wd0</tt>) to (re)install the MBR boot code.

    <p>
    While OpenBSD includes its own MBR code, you are not obliged
    to use it, as virtually any MBR code can boot OpenBSD.
    The MBR is manipulated by the fdisk(8) program, which is used both to
    edit the partition table, and also to install the MBR code on the disk.

    <p>
    OpenBSD's MBR announces itself with the message:

    <blockquote><pre>
    Using drive 0, partition 3.
    </pre></blockquote>

    showing the disk and partition it is about to load the PBR from.
    In addition to the obvious, it also shows a trailing period ("."), which
    indicates this machine is capable of using LBA translation to boot.
    If the machine were incapable of using LBA translation, the above
    period would have been replaced with a semicolon (";"), indicating
    CHS translation:

    <blockquote><pre>
    Using drive 0, partition 3;
    </pre></blockquote>

    Note that the trailing period or semicolon can be used as an indicator
    of the "new" OpenBSD MBR, introduced with OpenBSD 3.5.

  <p>
  <li><b><i>Partition Boot Record (PBR):</i></b>
    The Partition Boot Record, also called the PBR or
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot">
    biosboot(8)</a>
    (after the name of the file that holds the code) is the first 512 bytes
    of the OpenBSD partition of the disk.
    The PBR is the "first-stage boot loader" for OpenBSD.
    It is loaded by the MBR code,
    and has the task of loading the OpenBSD second-stage boot loader,
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot">boot(8)</a>.
    Like the MBR, the PBR is a very tiny section of code and data,
    only 512 bytes, total.
    That's not enough to have a fully filesystem-aware application, so
    rather than having the PBR locate <tt>/boot</tt> on the disk, the
    BIOS-accessible location of <tt>/boot</tt> is physically coded into the
    PBR at installation time.

    <p>
    The PBR is installed by
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot">
    installboot(8)</a>,
    which is further described <a href="faq14.html#InstBoot">later in this
    document</a>.
    The PBR announces itself with the message:

    <blockquote><pre>
    Loading...
    </pre></blockquote>

    printing a dot for every file system block it attempts to load.
    Again, the PBR shows if it is using LBA or CHS to load, if it has
    to use CHS translation, it displays a message with a semicolon:

    <blockquote><pre>
    Loading;...
    </pre></blockquote>

  <li><b><i>Second Stage Boot Loader, <tt>/boot</tt>:</i></b>
    <tt>/boot</tt> is
    loaded by the PBR, and has the task of accessing the OpenBSD file system
    through the machine's BIOS, and locating and loading the actual kernel.
    boot(8) also passes various options and information to the kernel.

    <p>
    boot(8) is an interactive program.
    After it loads, it attempts to locate and read <tt>/etc/boot.conf</tt>,
    if it exists (which it does not on a default install), and processes any
    commands in it.
    Unless instructed otherwise by <tt>/etc/boot.conf</tt>, it then gives the
    user a prompt:

    <blockquote><pre>
    probing: pc0 com0 com1 apm mem[636k 190M a20=on]
    disk: fd0 hd0+
    >> OpenBSD/i386 BOOT 3.26
    boot>
    </pre></blockquote>

    It gives the user (by default) five seconds to start giving it other
    tasks, but if none are given before the timeout, it starts its default
    behavior: loading the kernel, <tt>bsd</tt>, from the root partition of
    the first hard drive.
    The second-stage boot loader probes (examines) your system hardware,
    through the BIOS (as the OpenBSD kernel is not loaded).
    Above, you can see a few things it looked for and found:
    <ul>
      <li><b>pc0</b> - the standard keyboard and video display of an i386
        system.
      <li><b>com0, com1</b> - Two serial ports
      <li><b>apm</b> - Advanced Power Management BIOS functions
      <li><b>636k 190M</b> - The amount of conventional (below 1M) and
        extended (above 1M) memory it found
      <li><b>fd0 hd0+</b> - The BIOS disk devices found, in this case, one
        floppy and one hard disk.
    </ul>

    The '+' character after the "hd0" indicates that the BIOS has told
    <tt>/boot</tt> that this disk can be accessed via LBA.
    When doing a first-time install, you will sometimes see a '*' after a
    hard disk -- this indicates a disk that does not seem to have a valid
    OpenBSD disk label on it.

  <p>
  <li><b><i>Kernel: <tt>/bsd</tt></i>:</b>
    This is the goal of the boot process, to have the OpenBSD kernel loaded into
    RAM and properly running.
    Once the kernel has loaded, OpenBSD accesses the hardware directly,
    no longer through the BIOS.
</ol>

So, the very start of the boot process could look like this:

<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 3.26
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
   ...
</pre></blockquote>

<h3>What can go wrong</h3>

<ul>
  <li><b>Bad/invalid/incompatible MBR:</b>
    Usually, a used hard disk has some MBR code in place, but if the
    disk is new or moved from a different platform, AND you don't answer "w"
    to the "Use (W)hole disk or (E)dit the MBR?" question of the
    <a href="faq4.html#InstDisks">installation process</a>, you may end up
    with a disk without a valid MBR, and thus, it will not be bootable, even
    though it has a valid partition table.

    <p>
    You may install the OpenBSD MBR on your hard disk using the fdisk program.
    Boot from your install media, choose "Shell" to get a command prompt:

    <blockquote><pre>
    # <b>fdisk -u wd0</b>
    </pre></blockquote>

    You may also install a specific MBR to disk using fdisk:
    <blockquote><pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
    </pre></blockquote>

    which will install the file <tt>/usr/mdec/mbr</tt> as your system's
    MBR.
    This particular file on a standard OpenBSD install happens
    to be the standard MBR that is also built into fdisk, but any other
    MBR could be specified here.

  <p>
    <li><b>Invalid <tt>/boot</tt> location installed in PBR:</b>
    When installboot(8) installs the partition boot record, it writes the
    block number and offset of <tt>/boot</tt>'s inode into the PBR.
    Therefore, deleting and replacing <tt>/boot</tt> without re-running
    <a href="faq14.html#InstBoot">installboot(8)</a> will render
    your system unbootable, as the PBR will load whatever happens to be
    pointed to by the inode specified in it, which will almost certainly no
    longer be the desired second-stage boot loader!

    Since <tt>/boot</tt> is being read using BIOS calls, old versions of
    the PBR were sensitive to BIOS disk translation.
    If you altered the
    drive's geometry (i.e., took it out of one computer that uses CHS
    translation and moving it into one that uses LBA translation, or even
    changed a translation option in your BIOS), it would have
    <i>appeared to the BIOS</i>
    to be in a different location (a different numerical block must be accessed
    to get the same data from the disk), so you would have had to run
    installboot(8) before the system could be rebooted.
    The new (as of OpenBSD 3.5 and later) PBR is much more tolerant to
    changes in translation.
</ul>

As the PBR is very small, its range of error messages is pretty limited,
and somewhat cryptic.
Most likely messages are:

<ul>
  <li><b>ERR R</b> -- BIOS returned an error when trying to read a block
    from the disk.
    Usually means exactly what it says: your disk wasn't readable.
  <li><b>ERR M</b> -- An invalid
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic">magic(5)</a>
    number was read in the second-stage bootloader's header.
    This generally means whatever it was that was read in was NOT
    <tt>/boot</tt>, usually meaning installboot(8) was run incorrectly,
    the /boot file was altered, or you have exceeded your BIOS's ability to
    read a <a href="#LargeDrive">large disk</a>.
</ul>

Other error messages are detailed in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot">
biosboot(8)</a>
man page.

<p>
For more information on the i386 boot process, see:
<ul>
  <li>
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386">
    boot_i386(8)</a>
  <li>
    Hale Landis's <a href=
    "https://web.archive.org/web/20080707020112/http://www.ata-atapi.com/hiw.html">
    How it Works Documents</a>.
</ul>

<h2 id="LargeDrive">14.6 - What are the issues regarding large drives with
OpenBSD?</h2>

OpenBSD supports both FFS and FFS2 file systems, also known as UFS and UFS2.
Before looking at the limits of each system, we need to look at some
more general system limits.

<p>
Of course, the ability of file system and the abilities of particular
hardware are two different things.
A newer 250G IDE hard disk may have issues on older (pre >137G
standards) interfaces (though for the most part, they work just fine),
and some very old SCSI adapters have been seen to
have problems with more modern drives, and some older BIOSs will hang
when they encounter a modern sized hard disk.
You must respect the abilities of your hardware and boot code, of
course.

<h3>Partition size and location limitations</h3>

Unfortunately, the full ability of the OS isn't available until <b>after</b>
the OS has been loaded into memory.
The boot process has to utilize (and is thus limited by) the system's boot ROM.

<p>
For this reason, the entire /bsd file (the kernel) must be located on
the disk within the boot ROM addressable area.
This means that on some older i386 systems, the root partition must be
completely within the first 504M, but newer computers may have limits of
2G, 8G, 32G, 128G or more.
It is worth noting that many relatively new computers which support
larger than 128G drives actually have BIOS limitations of booting
only from within the first 128G.
You can use these systems with large drives, but your root partition
must be within the space supported by the boot ROM.

<p>
Note that it is possible to install a 40G drive on an old 486 and load
OpenBSD on it as one huge partition, and think you have successfully
violated the above rule.
However, it might come back to haunt you in a most unpleasant way:

<ul>
  <li>You install on the 40G / partition.
    It works, because the base OS and all its files (including /bsd) are within
    the first 504M.
  <li>You use the system, and end up with more than 504M of files on it.
  <li>You upgrade, and copy your new /bsd over the old one.
  <li>You reboot.
  <li>You get a message such as "ERR M" or other problems on boot.
</ul>

Why?
Because when you copied "over" the new <tt>/bsd</tt> file, it didn't
overwrite the old one, it got relocated to a new location on the
disk, probably outside the 504M range the BIOS supported.
The boot loader was unable to fetch the file <tt>/bsd</tt>, and the system hung.

<p>
To get OpenBSD to boot, the boot loaders (biosboot(8) and <tt>/boot</tt>
in the case of i386/amd64) and the kernel (<tt>/bsd</tt>) must be within the
boot ROM's supported range, and within their own abilities.
To play it safe, the rule is simple:

<blockquote>
<b>The entire root partition must be within the computer's BIOS
(or boot ROM) addressable space.</b>
</blockquote>

Some non-i386 users think they are immune to this, however most platforms
have some kind of boot ROM limitation on disk size.
Finding out for sure what the limit is, however, can be difficult.

<p>
This is another good reason to <a href="faq4.html#Partitioning">partition
your hard disk</a>, rather than using one large partition.

<h3>fsck(8) time and memory requirements</h3>

Another consideration with large file systems is the time and memory
required to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck">fsck(8)</a>
the file system after a crash or power interruption.
One should not put a 120G file system on a system with 32M of RAM and
expect it to successfully fsck(8) after a crash.
A rough guideline is the system should have at least 1M of available
memory for every 1G of disk space to successfully fsck the disk.
Swap can be used here, but at a very significant performance penalty,
so severe that it is usually unacceptable, except in special cases.

<p>
The time required to fsck the drive may become a problem as the file
system size expands, but you only have to fsck the disk space that is
actually allocated to mounted filesystems.
This is another reason NOT to allocate all your disk space Just Because
It Is There.
Keeping file systems mounted RO or not mounted helps keep them from
needing to be fsck(8)ed after tripping over the power cord.
Reducing the number of inodes (using the -i option of newfs) can also
improve fsck time -- assuming you really don't need them.

<p>
Don't forget that if you have multiple disks on the system, they could
all end up being fsck(8)ed after a crash at the same time, so they could
require more RAM than a single disk.

<h3>FFS vs. FFS2</h3>

Using FFS, OpenBSD supports an individual file system of up to
2<sup>31</sup>-1, or 2,147,483,647 blocks, and as each block is 512
bytes, that's a tiny amount less than 1T.
FFS2 is capable of much larger file systems, though other limits will be
reached long before the file system limits will be reached.

<p>
The boot/installation kernels <i>only support FFS</i>, not FFS2, so key
system partitions (<tt>/, /usr, /var, /tmp</tt>) should not be FFS2, or
severe maintenance problems can arise (there should be no reason for
those partitions to be that large, anyway).
For this reason, very large partitions should only be used for
"non-system" partitions, for example, <tt>/home, /var/www/,
/bigarray</tt>, etc.

<p>
Note that not all controllers and drivers support large disks.
For example,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ami">ami(4)</a>
has a limit of 2TB per logical volume.
Always be aware of what was available when a controller or interface was
manufactured, and don't just rely on "the connectors fit".

<h3>Disks larger than 2TB</h3>

The MBR system used on PCs only directly understands disks up to 2TB in
size.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk">fdisk(8)</a>
will show disks larger than 2TB as only 2TB.
This does not in any way hinder OpenBSD's ability to utilize larger
disks, as the MBR is used only to bootstrap the OS.
Once the OS is
running, the file systems are defined by the disklabel, which does not
have a 2TB limit.

<p>
To use a disk larger than 2TB, create an OpenBSD partition on the disk
using fdisk, whatever size fdisk will let you.
When you label the disk with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
disklabel(8)</a>,
use the "b" option to set the OpenBSD boundaries (which defaulted to
the size of the OpenBSD fdisk partition) to cover the entire disk.
Now you can create your partitions as you wish.
You must still respect the abilities of your BIOS, which will have the
limitation of only understanding fdisk partitions, so your 'a'
partition should be entirely within the fdisk-managed part of the disk,
in addition to any BIOS limitations.

<h2 id="InstBoot">14.7 - Installing bootblocks
(most, but not all platforms)</h2>

OpenBSD has a very robust boot loader that is quite indifferent to drive
geometries.
However, it is sensitive to where the file
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot">/boot</a></tt>
resides on the disk.
If you do something that causes boot(8) to be moved to a new place on
the disk (actually, a new inode), you will "break" your system,
preventing it from booting properly.
To fix your boot block so that you can boot normally, just use any boot
media (CD, floppy, network, USB) to get a <tt>boot&gt;</tt> prompt, then
type <tt>boot hd0a:/bsd</tt> to force it to boot from the first hard
disk (and not the boot media).
Your machine should come up normally.
You now need to reinstall the first-stage boot loader
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot">
biosboot(8)</a>) based on the position of the <tt>/boot</tt>
file, using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot">
installboot(8)</a> program.

<p>
Our example will assume your boot disk is sd0 (but
for IDE it would be wd0, etc.):

<blockquote><pre>
# <b>installboot sd0</b>
</pre></blockquote>

installboot(8) copies over a new second stage boot loader to <tt>/boot</tt>
and installs the first stage boot loader to look for it in the right
place.

<h2 id="Backup">14.8 - Preparing for disaster: backing up and restoring
from tape</h2>

<h3>Introduction:</h3>

If you plan on running what might be called a production server, it is
advisable to have some form of backup in the event one of your fixed
disk drives fails, or the data is otherwise lost.

<p>
This information will assist you in using the standard
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump">
dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore">
restore(8)</a>
utilities provided with OpenBSD.
More advanced backup utilities, such as
"<a href="http://www.bacula.org/">Bacula</a>"
are available through
<a href="faq15.html#PkgMgmt">packages</a> for backing up multiple servers to
disk and tape.

<h3>Backing up to tape:</h3>

Backing up to tape requires knowledge of where your file systems are mounted.
You can determine how your filesystems are mounted using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount">mount(8)</a>
command at your shell prompt.
You should get output similar to this:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

In this example, the root (<tt>/</tt>) filesystem resides physically on sd0a
which indicates a SCSI-like fixed disk 0, partition a.
The <tt>/usr</tt> filesystem resides on sd0h, which indicates SCSI-like
fixed disk 0, partition h.

<p>
Another example of a more advanced mount table might be:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

In this more advanced example, the root (<tt>/</tt>) filesystem resides
physically on sd0a.
The <tt>/var</tt> filesystem resides on sd0d, the <tt>/home</tt>
filesystem on sd0e and finally <tt>/usr</tt> on sd0h.

<p>
To backup your machine, you will need to feed dump the name of each fixed disk
partition.
Here is an example of the commands needed to backup the simpler mount table
listed above:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

For the more advanced mount table example, you would use something
similar to:

<blockquote><pre>
# <b>dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

You can review the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump">dump(8)</a>
man page to learn exactly what each command line switch does.
Here is a brief description of the parameters used above:

<ul>
  <li><b>0</b> - Perform a level 0 dump, get everything
  <li><b>a</b> - Attempt to automatically determine tape media length
  <li><b>u</b> - Update the file <tt>/etc/dumpdates</tt> to indicate when
    backup was last performed
  <li><b>f</b> - Which tape device to use (/dev/nrst0 in this case)
</ul>

Finally which partition to backup (/dev/rsd0a, etc.)

<p>
The
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt">mt(1)</a>
command is used at the end to rewind the drive.
Review the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt">mt(1)</a>
man page for more options (such as eject).

<p>
If you are unsure of your tape device name, use dmesg to locate it.
An example tape drive entry in dmesg might appear similar to:

<blockquote><pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre></blockquote>

You may have noticed that when backing up, the tape drive is accessed as
device name <tt>nrst0</tt> instead of the <tt>st0</tt> name that is seen in
dmesg.
When you access <tt>st0</tt> as <tt>nrst0</tt> you are accessing the same
physical tape drive but telling the drive to not rewind at the end of the job
and access the device in raw mode.
To back up multiple file systems to a single tape, be sure you use the
non-rewind device.
If you use a rewind device (<tt>rst0</tt>) to back up multiple file systems,
you'll end up overwriting the prior filesystem with the next one dump tries
to write to tape.
You can find a more elaborate description of various tape drive devices in the
dump man page.

<p>
If you wanted to write a small script called "backup", it might look
something like this:

<blockquote><pre>
echo "  Starting Full Backup..."
dump -0au -f /dev/nrst0 /dev/rsd0a
dump -0au -f /dev/nrst0 /dev/rsd0d
dump -0au -f /dev/nrst0 /dev/rsd0e
dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre></blockquote>

If scheduled nightly backups are desired,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron">cron(8)</a>
could be used to launch your backup script automatically.

<p>
It will also be helpful to document (on a scrap of paper) how large each
file system needs to be.
You can use <tt>df -h</tt> to determine how much space each partition is
currently using.
This will be handy when the drive fails and you need to recreate your
partition table on the new drive.

<p>
Restoring your data will also help reduce fragmentation.
To ensure you get all files, the best way of backing up is rebooting your
system in single user mode.
File systems do not need to be mounted to be backed up.
Don't forget to mount root (/) r/w after rebooting in single user mode or
your dump will fail when trying to write out dumpdates.
Enter <tt>bsd -s</tt> at the boot&gt; prompt for single user mode.

<h3>Viewing the contents of a dump tape:</h3>

After you've backed up your file systems for the first time, it would be
a good idea to briefly test your tape and be sure the data on it is as
you expect it should be.

<p>
You can use the following example to review a catalog of files on a dump
tape:

<blockquote><pre>
# <b>restore -tvs 1 -f /dev/rst0</b>
</pre></blockquote>

This will cause a list of files that exist on the 1st partition of the
dump tape to be listed.
Following along from the above examples, 1 would be your root file system.

<p>
To see what resides on the 2nd tape partition and send the output to a
file, you would use a command similar to:

<blockquote><pre>
# <b>restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre></blockquote>

If you have a mount table like the simple one, 2 would be /usr, if yours
is a more advanced mount table 2 might be /var or another fs.
The sequence number matches the order in which the file systems are written
to tape.

<h3>Restoring from tape:</h3>

The example scenario listed below would be useful if your fixed drive
has failed completely.
In the event you want to restore a single file from tape, review the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore">restore(8)</a>
man page and pay attention to the interactive mode instructions.

<p>
If you have prepared properly, replacing a disk and restoring your data
from tape can be a very quick process.
The standard OpenBSD install/boot CD already contains the required restore(8)
utility as well as the binaries required to partition and make your new drive
bootable.
In most cases, a CD and your most recent dump tape is all you'll need to
get back up and running.

<p>
After physically replacing the failed disk drive, the basic steps to
restore your data are as follows:

<ul>
  <li>
    Boot from the OpenBSD install/boot floppy.
    At the menu selection, choose Shell.
    Write protect and insert your most recent back up tape into the drive.

  <li>
    Using the
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk">fdisk(8)</a>
    command, create a primary OpenBSD partition on this newly installed
    drive.
    Example:

    <blockquote><pre>
    # <b>fdisk -e sd0</b>
    </pre></blockquote>

    See <a href="#fdisk">fdisk FAQ</a> for more info.

  <li>
    Using the disklabel command, recreate your OpenBSD partition table
    inside that primary OpenBSD partition you just created with fdisk.
    Example:

    <blockquote><pre>
    # <b>disklabel -E sd0</b>
    </pre></blockquote>

    (Don't forget swap, see <a href="#disklabel">disklabel FAQ</a>
    for more info)

  <li>
    Use the newfs command to build a clean file system on each partition you
    created in the above step.
    Example:

    <blockquote><pre>
    # <b>newfs /dev/rsd0a</b>
    # <b>newfs /dev/rsd0h</b>
    </pre></blockquote>

  <li>
    Mount your newly prepared root (/) file system on /mnt.
    Example:

    <blockquote><pre>
    # <b>mount /dev/sd0a /mnt</b>
    </pre></blockquote>

  <li>
    Change into that mounted root file system and start the restore process.
    Example:

    <blockquote><pre>
    # <b>cd /mnt</b>
    # <b>restore -rs 1 -f /dev/rst0</b>
    </pre></blockquote>

  <li>
    You'll want this new disk to be bootable, use the following to write a
    new MBR to your drive.
    Example:

    <blockquote><pre>
    # <b>fdisk -i sd0</b>
    </pre></blockquote>

  <li>
    In addition to writing a new MBR to the drive, you will need to install
    boot blocks to boot from it.
    The following is a brief example:

    <blockquote><pre>
    # <b>installboot -v -r /mnt sd0</b>
    </pre></blockquote>

  <li>
    Your new root file system on the fixed disk should be ready enough so
    you can boot it and continue restoring the rest of your file systems.
    Since your operating system is not complete yet, be sure you boot back
    up with single user mode.
    At the shell prompt, issue the following commands to unmount and
    halt the system:

    <blockquote><pre>
    # <b>umount /mnt</b>
    # <b>halt</b>
    </pre></blockquote>

  <li>
    Remove the install/boot floppy from the drive and reboot your system.
    At the OpenBSD boot&gt; prompt, issue the following command:

    <blockquote><pre>
    boot> <b>bsd -s</b>
    </pre></blockquote>

    The bsd -s will cause the kernel to be started in single user mode which
    will only require a root (/) file system.

  <li>
    Assuming you performed the above steps correctly and nothing has gone
    wrong, you should end up at a prompt asking you for a shell path or press
    return.
    Press return to use sh.
    Next, you'll want to remount root in r/w mode as opposed to read only.
    Issue the following command:

    <blockquote><pre>
    # <b>mount -u -w /</b>
    </pre></blockquote>

  <li>
    Once you have re-mounted in r/w mode, you can continue restoring your
    other file systems.
    Example:

    <blockquote><pre>
    <i>(simple mount table)</i>
    # <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

    <i>(more advanced mount table)</i>
    # <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
    # <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
    # <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
    </pre></blockquote>

    You could use "<b>restore rvsf</b>" instead of just rsf to view names of
    objects as they are extracted from the dump set.

  <li>
    Finally after you finish restoring all your other file systems to disk,
    reboot into multiuser mode.
    If everything went as planned, your system will be back to the state it
    was in as of your most recent back up tape and ready to use again.
</ul>

<h2 id="MountImage">14.9 - Mounting disk images in OpenBSD</h2>

To mount a disk image (ISO images, disk images created with dd, etc.) in
OpenBSD you must configure a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd">vnd(4)</a>
device.
For example, if you have an ISO image located at <i>/tmp/ISO.image</i>,
you would take the following steps to mount the image.

<blockquote><pre>
# <b>vnconfig vnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/vnd0c /mnt</b>
</pre></blockquote>

Notice that since this is an ISO 9660 image, as used by CDs and DVDs,
you must specify type of <i>cd9660</i> when mounting it.
This is true, no matter what type, e.g.  you must use type <i>ext2fs</i>
when mounting Linux disk images.

<p>
To unmount the image, use the following commands.

<blockquote><pre>
# <b>umount /mnt</b>
# <b>vnconfig -u vnd0</b>
</pre></blockquote>

For more information, refer to the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig">vnconfig(8)</a>
man page.

<h2 id="pciideErr">14.10 - Help! I'm getting errors with IDE DMA!</h2>

DMA IDE transfers, supported by
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide">pciide(4)</a>
are unreliable with many combinations of older hardware.

<p>
OpenBSD is aggressive and attempts to use the highest DMA Mode it can configure.
This will cause corruption of data transfers in some configurations because of
buggy motherboard chipsets, buggy drives, and/or noise on the cables.
Luckily, Ultra-DMA modes protect data transfers with a CRC to detect corruption.
When the Ultra-DMA CRC fails, OpenBSD will print an error message and try the
operation again.

<blockquote><pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre></blockquote>

After failing a couple times, OpenBSD will downgrade to a slower
(hopefully more reliable) Ultra-DMA mode.
If Ultra-DMA mode 0 is hit, then the drive downgrades to PIO mode.

<p>
UDMA errors are often caused by low quality or damaged cables.
Cable problems should usually be the first suspect if you get many
DMA errors or unexpectedly low DMA performance.
It is also a bad idea to put the CD-ROM on the same channel with a hard
disk.

<p>
If replacing cables does not resolve the problem and OpenBSD does not
successfully downgrade, or the process causes your machine to lock hard,
or causes excessive messages on the console and in the logs, you may
wish to force the system to use a lower level of DMA or UDMA by default.
This can be done by using <a href="faq5.html#BootConfig">UKC</a> or
<a href="faq5.html#config">config(8)</a> to change the flags on the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd">wd(4)</a>
device.

<h2 id="NegSpace">14.11 - Why does <tt>df(1)</tt> tell me I have over 100% of
my disk used?</h2>

People are sometimes surprised to find they have <i>negative</i>
available disk space, or more than 100% of a filesystem in use, as shown
by
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df">df(1)</a>.

<p>
When a filesystem is created with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs">newfs(8)</a>,
some of the available space is held in reserve from normal users.
This provides a margin of error when you accidently fill the disk, and
helps keep disk fragmentation to a minimum.
Default for this is 5% of the disk capacity, so if the root user has
been carelessly filling the disk, you may see up to 105% of the
available capacity in use.

<p>
If the 5% value is not appropriate for you, you can change it with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs">tunefs(8)</a>
command.

<h2 id="OhBugger">14.12 - Recovering partitions after deleting the
disklabel</h2>

If you have a damaged partition table, there are various things
you can attempt to do to recover it.

<p>
Firstly, panic.
You usually do so anyways, so you might as well get it over with.
Just don't do anything stupid.
Panic away from your machine.
Then relax, and see if the steps below won't help you out.

<p>
A copy of the disklabel for each disk is saved
in <tt>/var/backups</tt> as part of the daily system maintenance.
Assuming you still have the var partition, you can simply read the
output, and put it back into disklabel.

<p>
In the event that you can no longer see that partition, there are two
options.
Fix enough of the disk so you can see it, or fix enough of the disk so
that you can get your data off.

Depending on what happened, one or other of those may be preferable
(with dying disks you want the data first, with sloppy fingers you can
just have the label)

<p>
The first tool you need is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(note the underscore, it isn't called "scanffs").
scan_ffs(8) will look through a disk, and try and find partitions and
also tell you what information it finds about them.
You can use this information to recreate the disklabel.
If you just want <tt>/var</tt> back, you can recreate the partition for
<tt>/var</tt>, and then recover the backed up label and add the rest
from that.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
disklabel(8)</a>
will update both the kernel's understanding of the disklabel, and
then attempt to write the label to disk.
Therefore, even if the area of the disk containing the disklabel is
unreadable, you will be able to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount">mount(8)</a>
it until the next reboot.

<h2 id="foreignfs">14.13 - Can I access data on filesystems other than FFS?</h2>
<!-- This article written by Steven Mestdagh,
steven@openbsd.org, and released under the BSD license -->

Yes.
Other supported filesystems include: ext2/3/4 (Linux), ISO 9660 and UDF
(CD-ROM, DVD media), FAT (MS-DOS and Windows), NFS, NTFS (Windows).
Some of them have limited support; for instance read-only.

<p>
We will give a general overview on how to use one of these filesystems under
OpenBSD.
To be able to use a filesystem, it must be mounted.
For details and mount options, please consult the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount">mount(8)</a>
manual page, and that of the mount command for the filesystem you will be
mounting, e.g. mount_msdos, mount_ext2fs, ...

<p>
First, you must know on which device your filesystem is located.
This can be simply your first hard disk, <tt>wd0</tt> or <tt>sd0</tt>,
but it may be less obvious.
All recognized and configured devices on your system are mentioned in the
output of the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg">dmesg(8)</a>
command: a device name, followed by a one-line description of the device.
For example, my first CD-ROM drive is recognized as follows:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

For a much shorter list of available disks, you can use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl">sysctl(8)</a>.
The command

<blockquote><pre>
# <b>sysctl hw.disknames</b>
</pre></blockquote>

will show all disks currently known to your system, for example:

<blockquote><pre>
hw.disknames=sd0:303c29298c315c77,cd0:,fd0:
</pre></blockquote>

At this point, it is time to find out which partitions are on the device, and
in which partition the desired filesystem resides.
Therefore, we examine the device using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
disklabel(8)</a>.
The disklabel contains a list of partitions, with a maximum number of 16.
Partition c always indicates the entire device.
Partitions a-b and d-p are used by OpenBSD.
Partitions i-p may be automatically allocated to file systems of other
operating systems.
In this case, I'll be viewing the disklabel of my hard disk, which contains
a number of different filesystems.

<p>
<b>NOTE: OpenBSD was installed after the other operating systems</b>
on this system, and during the install a disklabel containing partitions for
the native as well as the foreign filesystems was installed on the disk.
However, if you install foreign filesystems after the OpenBSD disklabel
was already installed on the disk, you need to add or modify them manually
afterwards.
This will be explained in <a href="#foreignfsafter">this subsection</a>.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A
duid: d920a43a5a56ad5f
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
boundstart: 20338290
boundend: 49656915
drivedata: 0

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        408366      20338290  4.2BSD   2048 16384   16 # /
  b:       1638000      20746656    swap
  c:      78165360             0  unused
  d:       4194288      22384656  4.2BSD   2048 16384   16 # /usr
  e:        409248      26578944  4.2BSD   2048 16384   16 # /tmp
  f:      10486224      26988192  4.2BSD   2048 16384   16 # /var
  g:      12182499      37474416  4.2BSD   2048 16384   16 # /home
  i:         64197            63 unknown
  j:      20274030         64260 unknown
  k:       1975932      49656978   MSDOS
  l:       3919797      51632973 unknown
  m:       2939832      55552833  ext2fs
  n:       5879727      58492728  ext2fs
  o:      13783707      64372518  ext2fs

</pre></blockquote>

As can be seen in the above output, the OpenBSD partitions are listed first.
Next to them are a number of ext2 partitions and one MSDOS partition, as
well as a few 'unknown' partitions.
On i386 and amd64 systems, you can usually find out more about those using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk">fdisk(8)</a>
utility.
For the curious reader: partition i is a maintenance partition created by
the vendor, partition j is a NTFS partition and partition l is a Linux swap
partition.

<p>
Once you have determined which partition it is you want to use, you can
move to the final step: mounting the filesystem contained in it.
Most filesystems are supported in the GENERIC kernel: just have a look at
the kernel configuration file, located in the
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt> directory.
If you want to use one of the filesystems not supported in GENERIC, you
will need to <a href="faq5.html#Options">build a custom kernel</a>.

<p>
When you have gathered the information needed as mentioned above, it is
time to mount the filesystem.
Let's assume a directory <tt>/mnt/otherfs</tt> exists, which we will use as
a mount point where we will mount the desired filesystem.
In this example, we will mount the ext2 filesystem in partition m:

<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/otherfs</b>
</pre></blockquote>

If you plan to use this filesystem regularly, you may save yourself some
time by inserting a line for it in <tt>/etc/fstab</tt>, for example something
like:

<blockquote><pre>
/dev/wd0m /mnt/otherfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>

Notice the 0 values in the fifth and sixth field.
This means we do not require the filesystem to be dumped, and checked using
fsck.
Generally, those are things you want to have handled by the native
operating system associated with the filesystem.

<h3 id="foreignfsafter">14.13.1 - The partitions are not in my disklabel!
What should I do?</h3>

If you install foreign filesystems on your system (often the result of
adding a new operating system) after you have already installed OpenBSD,
a disklabel will already be present, and it will not be updated
automatically to contain the new foreign filesystem partitions.
If you wish to use them, you need to add or modify these partitions
manually using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
disklabel(8)</a>.

<p>
As an example, I have modified one of my existing ext2 partitions: using
Linux's fdisk program, I've reduced the size of the 'o' partition (see
disklabel output above) to 1G.
We will be able to recognize it easily by its starting position
(offset: 64372518) and size (13783707).
Note that these values are sector numbers, and that using sector numbers
(not megabytes or any other measure) is the most exact and safest way of
reading this information.

<p>
Before the change, the partition looked like this using OpenBSD's
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk">fdisk(8)</a>
utility (leaving only relevant output):

<blockquote><pre>
# <b>fdisk wd0</b>
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4864 254 63 [    64372518:    13783707 ] Linux files*
. . .
</pre></blockquote>

As you can see, the starting position and size are exactly those reported
by disklabel(8) earlier.
(Dont' be confused by the value indicated by "Offset": it is referring to
the starting position of the extended partition in which the ext2 partition
is contained.)

<p>
After changing the partition's size from Linux, it looks like this:

<blockquote><pre>
# <b>fdisk wd0</b>
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4137 254 63 [    64372518:     2104452 ] Linux files*
. . .
</pre></blockquote>

Now this needs to be changed using disklabel(8).
For instance, you can issue <tt>disklabel -e wd0</tt>, which will invoke
an editor specified by the EDITOR environment variable (default is vi).
Within the editor, change the last line of the disklabel to match the new
size:

<blockquote><pre>
  o:       2104452      64372518  ext2fs
</pre></blockquote>

Save the disklabel to disk when finished.
Now that the disklabel is up to date again, you should be able to mount
your partitions as described above.

<p>
You can follow a very similar procedure to add new partitions.

<h2 id="flashmem">14.14 - Can I use a flash memory device with OpenBSD?</h2>

<h3 id="flashmemUSB">14.14.1 - Flash memory as a portable storage device</h3>
<!-- This article written by Steven Mestdagh,
steven@openbsd.org, and released under the BSD license -->

Normally, the memory device should be recognized upon plugging it into a
port of your machine.
Shortly after inserting it, a number of messages are written to the console
by the kernel.
For instance, when I plug in my USB flash memory device, I see the following
on my console:

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 512 bytes/sec, 251904 sec total
</pre></blockquote>

These lines indicate that the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass">umass(4)</a>
(USB mass storage) driver has been attached to the memory device, and that
it is using the SCSI system.
The last two lines are the most important ones: they are saying to which
device node the memory device has been attached, and what the total amount of
storage space is.
If you somehow missed these lines, you can still see them afterwards with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg">dmesg(8)</a>
command.
The reported CHS geometry is a rather fictitious one, as the flash memory
is being treated like any regular SCSI disk.

<p>
We will discuss two scenarios below.

<h4>The device is new/empty and you want to use it with OpenBSD only</h4>

You will need to initialize a disklabel onto the device, and create at
least one partition.
Please read <a href="#disklabel">Using OpenBSD's disklabel</a> and the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
disklabel(8)</a>
manual page for details about this.

<p>
In this example I created just one partition <i>a</i> in which I will place
a FFS filesystem:

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
    cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
        122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Let's mount the filesystem we created in the <i>a</i> partition on
<tt>/mnt/flashmem</tt>.
Create the mount point first if it does not exist.

<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>

<h4>You received the memory device from someone with whom you want to
exchange data</h4>

There is a considerable chance the other person is not using OpenBSD, so there
may be a foreign filesystem on the memory device.
Therefore, we will first need to find out which partitions are on the device,
as described in <a href="#foreignfs">FAQ 14 - Foreign Filesystems</a>.

<blockquote><pre>
# <b>disklabel sd0</b>
# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  c:        251904             0  unused      0     0      # Cyl     0 -   122
  i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

As can be seen in the disklabel output above, there is only one partition
<i>i</i>, containing a FAT filesystem created on a Windows machine.
As usual, the <i>c</i> partition indicates the entire device.

<p>
Let's now mount the filesystem in the <i>i</i> partition on
<tt>/mnt/flashmem</tt>.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>

Now you can start using it just like any other disk.

<blockquote>
<b>WARNING:</b>
You should <b>always unmount</b> the filesystem <b>before unplugging</b> the
memory device.
If you don't, the filesystem may be left in an inconsistent state, which
may result in data corruption.
</blockquote>

Upon detaching the memory device from your machine, you will again see the
kernel write messages about this to the console:

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<h3 id="flashmemBoot">14.14.2 - Flash memory as bootable storage</h3>

<!-- This article written by Nick Holland
nick@openbsd.org, and released under the BSD license -->

One can also use flash memory in various forms as bootable disk with
OpenBSD.
This can be done with both USB devices (assuming your computer can
boot from a USB flash device, not all can), or with a non-USB (i.e.,
CF) device with an IDE or SATA adapter.
(Non-USB devices attached with a USB adapter are treated as USB devices.)
In some cases, you may actually use a device in both ways (load the
media in a USB adapter, but run it in an IDE adapter).

<p>
A flash device attached to a USB port will show up as a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd">sd(4)</a>
SCSI-like device.
When attached to an IDE adapter, it will show up as a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd">wd(4)</a>
device.

<p>
In the case of flash media in an IDE adapter, it can be booted from
any system that could boot from an IDE hard disk on the same adapter.
In every sense, the system sees the flash media as an IDE disk.
Simply configure the hardware appropriately, then install OpenBSD
to the flash disk as normal.

<p>
In the case of booting from a USB device, your system must be
able to boot from the USB device without being distracted by
other devices on the system.
Note that if your intention is to make a portable boot environment on a
USB device, you really want to use <a href="#DUID">DUIDs</a>, rather
than the traditional <tt>/dev/sd0X</tt> notation.
The USB device will show up as a SCSI disk, sometimes sd0.
Without DUIDs, if you plug this device into a system which already has a few
SCSI-like disks (i.e., devices attached to an ahci(4) interface) on it,
it will probably end up with a different
identifier, which will complicate carrying the flash device from system
to system, as you would have to update <tt>/etc/fstab</tt>.
Using DUIDs completely resolves this issue.

<p>
Some notes:

<ul>
  <li><b>Speed:</b>
    In general, flash devices are much slower than hard disks, especially when
    it comes to writing.
    Using <a href="#SoftUpdates">soft updates</a> will help this
    considerably, as will using the "noatime" mount option.

  <li><b>"Write fatigue":</b>
    Much has been written about the finite number of times an individual
    flash cell can be rewritten before failure.
    Practically speaking, however, there are many ways a flash device can
    fail, write fatigue is just one of them.
    Modern flash devices will verify writes, and in the event of failure,
    will automatically remap the failed sectors with one of the many spare
    sectors.
    Most users with most flash devices will not have to worry about "write
    fatigue".
    You would probably experience more down time due to failure of "clever"
    tricks done to avoid writing to the flash drive than you will by just
    using the drives as read-write media.

  <li><b>Reliability:</b>
    The fact that flash media has no moving parts has prompted many people
    to assume the flash media is inherently more reliable than hard disks.
    It is not wise to assume that switching to flash means you
    don't need to worry about data loss or drive failure.
    People have reported considerable variation in flash media quality,
    it is probably best to consider flash storage as a silent and low-power
    alternative to disk rather than a failure-free storage media.

  <li><b>Creating a bootable USB flash drive:</b>
    While a USB device can only be booted on a machine which can boot from
    USB drives, it can be created on any machine with supported USB
    hardware.
    You will, of course, be unable to test your work until you can get to a
    USB bootable system.

  <li><b>Going from IDE to USB interfaces:</b>
    Since flash media can be readable and writable through USB, IDE and
    other adapters, you can create bootable media with one type of adapter
    but maintain or use it with another type of adapter.

  <li><b>Mixing OpenBSD and other partitions on one device:</b>
    OpenBSD treats the flash disk as any other disk so one can use
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk">fdisk(8)</a>
    to partition a flash device, as you would any hard disk.
    You can then have OpenBSD file systems on one partition, and use another
    partition for another file system, for example, FAT32.
    However, not all OSs treat USB devices as "equals".
    Windows, at least, will not attempt to use or create a partition that
    doesn't start at the beginning of the device, nor will the Windows
    partitioning tools allow you to partition the disk, though it will
    respect existing partitions.
    So, if you wish to create a USB flash drive that is bootable with
    OpenBSD, but also functions as a FAT32-capable device on other OSs, you
    would want to do something like this:

    <ol>
    <li>Partition the media with OpenBSD's fdisk, creating a partition
      of the type you desire for Windows to use at the beginning of the
      disk, and an OpenBSD partition at the end of the disk.
    <li>Install OpenBSD as normal to the OpenBSD fdisk partition, don't
      forget to flag the OpenBSD partition as "Active" for booting.
    <li>Format the other partition.
      This can be (and perhaps should be) done on the "target" OS
      (Windows, in this case).
    </ol>

    Note that if the other partition's type is chosen appropriately, it is
    possible to have OpenBSD access both partitions on the device.
    So, a Windows user could populate the FAT32 partition with MP3 files
    which could be played when they booted from the OpenBSD partition.
</ul>

<h3 id="flashmemLive">14.14.3 - How do I create a bootable "live" USB
device?</h3>

It is very easy to create a bootable USB flash (or other!) drive that
can be used as a "live" OpenBSD system without installing OpenBSD on
the local hard disk of a machine.
Obviously, the target machine must be bootable from a USB device, but
the initial load can actually be done from any machine with a USB
interface.

<p>
Some reasons you may want to do this:

<ul>
  <li>A portable, secure "machine" you can carry with you in your pocket.
  <li>Fix problems in OpenBSD and other installs with tools that aren't
    available with <a href="faq4.html#bsd.rd">bsd.rd</a>.
  <li>Evaluate hardware for OpenBSD compatibility at the point of purchase.
  <li>Install machines that lack any other form of boot media.
  <li>Collect <a href="faq4.html#SendDmesg">dmesg</a> outputs from your
    friends' computers!
    As OpenBSD's dmesg is useful for identifying hardware, this can be a
    good way to prep for the install of <b>other</b> OSs on a machine -- make
    sure you have all the needed drivers before starting.
</ul>

Creating such a "live OpenBSD drive" is simple.
<ul>
  <li>Mount your USB drive to the machine you are installing from.
  <li>Boot your favorite OpenBSD install media.
  <li><a href="faq4.html">Install</a> as normal, being careful to select
    your flash drive as the install target.
  <li>Boot from your newly created USB device.
</ul>

That's it!

<p>
There are some things you may want to do after the install to improve
your results:

<ul>
  <li>
    Install all packages and utilities you are likely to wish to have available.
  <li>
    Different target machines will likely have different NICs.
    You could create a bunch of
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if">
    hostname.if(5)</a>
    files in <tt>/etc</tt>, each containing just <tt>dhcp</tt>, for all the
    NICs you are likely to encounter (fxp0, re0, rl0, bge0, bnx0, em0, etc.)
    on USB-bootable machines, plus maybe sample wireless config files as
    well.
    OpenBSD will ignore all hostname.if(5) files for devices not present
    at boot time.
  <li>
    You may wish to have a copy of the install files and maybe any
    desired package .tgz files so you can use the drive as an install
    media (boot bsd.rd instead of letting it boot normally).
  <li>
    On many machines, X will "Just Work" with no config file, but you may
    wish to collect X config files for those systems that require them.
  <li>
    <a href="#SoftUpdates">Soft updates</a>
    will be something you will want to use.
  <li>
    For maximum flexibility, you probably want to use
    <a href="../i386.html">i386</a> rather than
    <a href="../amd64.html">amd64</a>.
    However, if you wish to use it as an install media, you could have an
    amd64 bsd.rd and install files in addition to i386.
  <li>
    Use <a href="#DUID">DUIDs</a> to identify your partitions (default).
  <li>
    You may find it desirable to have a FAT partition on the USB drive,
    create it as detailed <a href="#flashmemBoot">above</a>.
  <li>
    You may wish to use
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid">
    softraid(4)</a>
    to encrypt a data partition.
</ul>

<h2 id="DiskOpt">14.15 - Optimizing disk performance</h2>

Disk performance is a significant factor in the overall speed of your computer.
It becomes increasingly important when your computer is hosting a
multi-user environment (users of all kinds, from those who log-in
interactively to those who see you as a file-server or a web-server).
Data storage constantly needs attention, especially when your partitions
run out of space or when your disks fail.
OpenBSD has a few options to increase the speed of your disk operations.

<ul>
  <li><a href="#Optsoftu">Soft updates</a>
  <li><a href="#Optmaxvnodes">Size of the namei(9) cache</a>
</ul>

<h3 id="Optsoftu">14.15.1 - Soft updates</h3>

An important tool that can be used to speed up your system is soft updates.
One of the slowest operations in the traditional BSD file system is
updating metainfo (which happens, among other times, when you create or
delete files and directories).
Soft updates attempts to update metainfo in RAM instead of writing to the
hard disk each and every single metainfo update.
Another effect of this is that the metainfo on disk should always be
complete, although not always up to date.
You can read more about soft updates in the
<a href="#SoftUpdates">soft updates FAQ</a> entry.

<h3 id="Optmaxvnodes">14.15.2 - Size of the namei(9) cache</h3>

The name-to-inode translation (a.k.a.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=namei">namei(9)</a>)
cache controls the speed of pathname to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode">inode(5)</a>
translation.
A reasonable way to derive a value for the cache, should a large number of
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=namei">namei(9)</a>
cache misses be noticed with a tool such as
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat">systat(1)</a>,
is to examine the system's current computed value with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl">sysctl(8)</a>,
(which calls this parameter <tt>kern.maxvnodes</tt>) and to increase this
value until either the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=namei">namei(9)</a>
cache hit rate improves or it is determined that
the system does not benefit substantially from an increase in the size of the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=namei">namei(9)</a>
cache.
After the value has been determined, you can set it at system startup time with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf">
sysctl.conf(5)</a>.

<h2 id="Async">14.16 - Why aren't we using async mounts?</h2>

Question: "I simply do "mount -u -o async /" which makes one package I use
(which insists on touching a few hundred things from time to time) usable.
Why is async mounting frowned upon and not on by default (as it is in some
other unixen)?
Isn't it a much simpler, and therefore, a safer way of improving performance
in some applications?"

<p>
Answer: "Async mounts are indeed faster than sync mounts, but they are also
less safe.
What happens in case of a power failure?
Or a hardware problem?
The quest for speed should not sacrifice the reliability and the stability of
the system.
Check the man page for
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount">mount(8)</a>."

<blockquote><pre>
         async   Metadata I/O to the file system should be done
                 asynchronously.  By default, only regular data is
                 read/written asynchronously.

                 This is a dangerous flag to set since it does not
                 guarantee to keep a consistent file system structure on
                 the disk.  You should not use this flag unless you are
                 prepared to recreate the file system should your system
                 crash.  The most common use of this flag is to speed up
                 restore(8) where it can give a factor of two speed
                 increase.
</pre></blockquote>

On the other hand, when you are dealing with temp data that you can recreate
from scratch after a crash, you can gain speed by using a separate
partition for that data only, mounted async.
 Again, do this <i>only if</i> you don't mind the loss of all the data in the
partition when something goes wrong.
For this reason,
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount_mfs">mfs</a>
partitions are mounted asynchronously, as they will get wiped and recreated
on a reboot anyway.

<h2 id="altroot">14.17 - Duplicating your root partition: altroot</h2>

OpenBSD provides an <tt>/altroot</tt> facility in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=daily">daily(8)</a>
scripts.
If the environment variable <tt>ROOTBACKUP=1</tt> is set in either
<tt>/etc/daily.local</tt> or root's
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crontab">crontab(5)</a>,
and a partition is specified in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab">fstab(5)</a>
as mounting to <tt>/altroot</tt> with the mount options of <tt>xx</tt>, every
night the entire contents of the root partition will be duplicated to the
<tt>/altroot</tt> partition.

<p>
Assuming you want to back up yur root partition to the partition specified
by the <a href="faq14.html#DUID">DUID</a> <tt>bfb4775bb8397569.a</tt>,
add the following to <tt>/etc/fstab</tt>

<blockquote><pre>
bfb4775bb8397569.a /altroot ffs xx 0 0
</pre></blockquote>

and set the appropriate environment variable in <tt>/etc/daily.local</tt>:

<blockquote><pre>
# <b>echo ROOTBACKUP=1 >>/etc/daily.local</b>
</pre></blockquote>

As the <tt>/altroot</tt> process will capture your <tt>/etc</tt> directory, this
will make sure any configuration changes there are updated daily.
This is a "disk image" copy done with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd">dd(1)</a>
not a file-by-file copy, so your <tt>/altroot</tt> partition should be at least
the same size as your root partition.
Generally, you will want your <tt>/altroot</tt> partition to be on a different
disk that has been configured to be fully bootable should the primary
disk fail.

<h2 id="softraid">14.18 - How do I use softraid?</h2>

The
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid">softraid(4)</a>
subsystem works by emulating a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scsibus">scsibus(4)</a>
with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd">sd(4)</a>
devices made by combining a number of OpenBSD
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
disklabel(8)</a> partitions into a virtual disk with the desired RAID level,
such as RAID0, RAID1, RAID4, RAID5 or crypto.
Note that only RAID0, RAID1, RAID5 and crypto are fully supported at the moment.
This virtual disk is treated as any other disk, first partitioned with
<a href="#fdisk">fdisk</a> (on fdisk platforms) and then
<a href="#disklabel">disklabels</a> are created as usual.

<h4>Some words on RAID in general:</h4>

<ul>
  <li>
    Before implementing any RAID solution, understand what it will and
    will not do for you.
    It is not a replacement for a good backup strategy.
    It will not keep your system running through every hardware failure.
    It may not keep your system running through a simple disk failure.
    In the case of software RAID, it won't guarantee the ability to boot
    from the surviving drive if your computer could not otherwise do so.
  <li>
    Before going into production, you must understand how you use your
    RAID solution to recover from failures.
    The time to do this is <b>before</b> your system has had a failure event.
    Poorly implemented RAID will often cause more down time than it will
    prevent.
    This is even more true if it has caused you to become complacent on your
    backups or other disaster planning.
  <li>
    The bigger your RAIDed partitions are, the longer it will take to
    recover from an "event."
    In other words, this is an especially bad time to allocate all of your
    cheap 500GB drives just because they are there.
    Remirroring 500GB drives takes a much longer time than mirroring the
    4GB that you actually use.
    One advantage of software mirroring is one can control how much of
    those "huge" drives is actually used in a RAID set.
  <li>
    There is a reflex to try to RAID as much of your system as possible.
    Even hardware which CAN boot from RAIDed drives will often have difficulty
    determining when a drive has failed to avoid booting from it.
    OpenBSD's <a href="#altroot">altroot</a> system can actually be better
    for some applications, as it provides a copy of old configuration
    information in case a change does not work quite as intended.
  <li>
    RAID provides redundancy only for the disk system.
    Many applications need more redundancy than just the disks, and for some
    applications, RAID can be just added complication, rather than a real
    benefit.
    An example of this is a <a href="faq6.html#CARP">CARP'd</a> set of
    firewalls provide complete fail over redundancy.
    In this case, adding RAID (either via hardware or softraid) is just
    added complication.
</ul>

<h3 id="softraidDI">14.18.1 - Installing to a mirror</h3>

The tools to assemble your softraid system are in the basic OpenBSD
install (for adding softraid devices after install), but they are
also available on the CD-ROM and <a href="faq4.html#bsd.rd">bsd.rd</a>
for installing your system to a softraid setup.
This section covers installing OpenBSD to a mirrored pair of hard drives,
and assumes familiarity with the <a href="faq4.html">installation process</a>
and ramdisk kernel.
Disk setup may vary from platform to platform, and
<b>booting from softraid devices isn't supported on all of them</b>.
It's currently only possible to boot from RAID1, RAID5 and crypto volumes
on i386, amd64 and sparc64.

<p>
The installation process will be a little different than the standard
OpenBSD install, as you will want to drop to the shell and create your
softraid(4) drive before doing the install.
Once the softraid(4) disk is created, you will perform the install relatively
normally, placing the partitions you wish to be RAIDed on the newly
configured drive.
If it sounds confusing at first, don't worry.
All the steps will be explained in detail.

<p>
The install kernel only has the <tt>/dev</tt> entries for one
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd">wd(4)</a>
device and one
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd">sd(4)</a>
device on boot, so you will need to manually create more disk devices
if your desired softraid setup requires them.

This process is normally done automatically by the installer, but you
haven't yet run the installer, and you will be adding a disk that didn't
exist at boot.
For example, if we needed to support a second wd(4) device for a mirrored
setup, you could do the following from the shell prompt:

<blockquote><pre>
Welcome to the OpenBSD/amd64 X.X installation program.
(I)nstall, (U)pgrade, (A)utoinstall or (S)hell? <b>s</b>
# <b>cd /dev</b>
# <b>sh MAKEDEV wd1</b>
</pre></blockquote>

You now have full support for the <tt>wd0</tt> and <tt>wd1</tt> devices.

<p>
Next, we'll initialize the disks with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk">fdisk(8)</a>
and create the softraid partition with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
disklabel(8)</a>.
An "a" partition will be made on both of the drives for the new RAID device.

<blockquote><pre>
# <b>fdisk -iy wd0</b>
Writing MBR at offset 0.
# <b>fdisk -iy wd1</b>
Writing MBR at offset 0.
# <b>disklabel -E wd0</b>
Label editor (enter '?' for help at any prompt)
> <b>a a</b>
offset: [2104515]
size: [39825135] <b>*</b>
FS type: [4.2BSD] <b>RAID</b>
> <b>w</b>
> <b>q</b>
No label changes.
</pre></blockquote>

You'll notice that we initialized both disks, but only created a partition
layout on the first drive.
That's because you can easily import the drive's configuration directly with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
disklabel(8)</a> command.

<blockquote><pre>
# <b>disklabel wd0 > layout</b>
# <b>disklabel -R wd1 layout</b>
# <b>rm layout</b>
</pre></blockquote>

The "layout" file in this example can be named anything.

<p>
Next, create the mirror with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl">bioctl(8)</a>
command.

<blockquote><pre>
# <b>bioctl -c 1 -l /dev/wd0a,/dev/wd1a softraid0</b>
</pre></blockquote>

Note that if you are creating multiple RAID devices, either on one disk
or on multiple devices, you're always going to be using the <tt>softraid0</tt>
virtual disk interface driver.
You won't be using "softraid1" or others.
The "softraid0" there is a virtual RAID controller, and you can hang many
virtual disks off this controller.

<p>
The new pseudo-disk device will show up as <tt>sd0</tt> here, assuming there
are no other sd(4) devices on your system.
This device will now show on the system console and dmesg as a newly
installed device:

<blockquote><pre>
scsibus1 at softraid0: 1 targets
sd0 at scsibus2 targ 0 lun 0: &lt;OPENBSD, SR RAID 1, 005&gt; SCSI2 0/direct fixed
sd0: 10244MB, 512 bytes/sec, 20980362 sec total
</pre></blockquote>

This shows that we now have a new SCSI bus and a new disk, <tt>sd0</tt>.
This volume will be automatically detected and assembled from this point
onwards when the system boots.

<p>
Because the new device probably has a lot of garbage where you expect
a master boot record and disklabel, zeroing the first chunk of it is
highly recommended.
Be <i>very careful</i> with this command; issuing it on the wrong device
could lead to a very bad day.
This assumes that the new softraid device was created as <tt>sd0</tt>.

<blockquote><pre>
# <b>dd if=/dev/zero of=/dev/rsd0c bs=1m count=1</b>
</pre></blockquote>

You are now ready to install OpenBSD on your system.
Perform the install as normal by invoking "install" or "exit" at the boot
media console.
Create all the partitions on your new softraid disk (<tt>sd0</tt> in our
example here) that should be there, rather than on <tt>wd0</tt> or <tt>wd1</tt>
(the non-RAID disks).

<p>
Now you can reboot your system and, if you have done things properly, it
will automatically assemble your RAID set and mount the appropriate
partitions.

<p>
To check on the status of your mirror, issue the following command:

<blockquote><pre>
# <b>bioctl sd0</b>
</pre></blockquote>

A nightly cron job to check the status might also be a good idea.

<h3 id="softraidFDE">14.18.2 - Full disk encryption</h3>

Much like RAID, full disk encryption in OpenBSD is handled by the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid">softraid(4)</a>
subsystem and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl">bioctl(8)</a>
command.
This section covers installing OpenBSD to a single encrypted disk, and is a
very similar process to the previous one.

<p>
Select (S)hell at the initial prompt.

<blockquote><pre>
Welcome to the OpenBSD/amd64 X.X installation program.
(I)nstall, (U)pgrade, (A)utoinstall or (S)hell? <b>s</b>
</pre></blockquote>

From here, you'll be given a shell within the live environment to manipulate
the disks.
For this example, we will install to the <tt>wd0</tt> SATA drive, erasing all
of its previous contents.
You may want to write random data to the drive first with something like the
following:

<blockquote><pre>
# <b>dd if=/dev/random of=/dev/rwd0c bs=1m</b>
</pre></blockquote>

This can be a very time-consuming process, depending on the speed of your
CPU and disk, as well as the size of the disk.
If you don't write random data to the whole device, it may be possible for an
adversary to deduce how much space is actually being used.

<p>
Next, we'll initialize the disk with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk">fdisk(8)</a>
and create the softraid partition with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel">
disklabel(8)</a>.

<blockquote><pre>
# <b>fdisk -iy wd0</b>
Writing MBR at offset 0.
# <b>disklabel -E wd0</b>
Label editor (enter '?' for help at any prompt)
> <b>a a</b>
offset: [2104515]
size: [39825135] <b>*</b>
FS type: [4.2BSD] <b>RAID</b>
> <b>w</b>
> <b>q</b>
No label changes.
</pre></blockquote>

We'll use the entire the disk, but note that the encrypted device can be
split up into multiple mountpoints as if it were a regular hard drive.
Now it's time to build the encrypted device on our "a" partition.

<blockquote><pre>
# <b>bioctl -c C -l /dev/wd0a softraid0</b>
New passphrase:
Re-type passphrase:
sd0 at scsibus2 targ 1 lun 0: &lt;OPENBSD, SR CRYPTO, 005&gt; SCSI2 0/direct fixed
sd0: 19445MB, 512 bytes/sector, 39824607 sectors
softraid0: CRYPTO volume attached as sd0
</pre></blockquote>

All data written to <tt>sd0</tt> will now be encrypted (with AES in XTS mode)
by default.

<p>
As in the previous example, we'll overwrite the first megabyte of our new
pseudo-device.

<blockquote><pre>
# <b>dd if=/dev/zero of=/dev/rsd0c bs=1m count=1</b>
</pre></blockquote>

Type <tt>exit</tt> to return to the main installer, then choose this new
device as the one for your installation.

<blockquote><pre>
[...]
Available disks are: wd0 sd0.
Which disk is the root disk? ('?' for details) [wd0] <b>sd0</b>
</pre></blockquote>

You will be prompted for the passphrase on startup, but all other operations
should be handled transparently.

<h3 id="softraidCrypto">14.18.3 - Encrypting external disks</h3>

As we just illustrated, cryptographic softraid(4) volumes are set up rather
simply.
This section explains how you might do so for an external USB flash drive,
but can be applied to any disk device.
If you already read the section on full disk encryption, this should be very
familiar.
An outline of the steps is as follows:

<ul>
  <li>Overwrite the drive's contents with random data
  <li>Create the desired RAID-type partition with disklabel(8)
  <li>Encrypt the drive (note that the initial creation of the container and
    attaching the container are done with the same bioctl(8) command)
  <li>Zero the first megabyte of the new psuedo-partition
  <li>Create a filesystem on the pseudo-device with
  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs">newfs(8)</a>
  <li>Unlock and
  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount">mount(8)</a>
    the new pseudo-device
  <li>Access the files as needed
  <li>Unmount the drive and detach the encrypted container
</ul>

A quick example runthrough of the steps follows, with <tt>sd0</tt> being
the USB drive.

<blockquote><pre>
# <b>dd if=/dev/random of=/dev/rsd0c bs=1m</b>
# <b>fdisk -iy sd0</b>
# <b>disklabel -E sd0</b> (create an "a" partition, see above for more info)
# <b>bioctl -c C -l /dev/sd0a softraid0</b>
New passphrase:
Re-type passphrase:
softraid0: CRYPTO volume attached as sd1
# <b>dd if=/dev/zero of=/dev/rsd1c bs=1m count=1</b>
# <b>disklabel -E sd1</b> (create an "i" partition, see above for more info)
# <b>newfs /dev/sd1i</b>
# <b>mkdir -p /mnt/secretstuff</b>
# <b>mount /dev/sd0i /mnt/secretstuff</b>
# <b>mv planstotakeovertheworld.txt /mnt/secretstuff/</b>
# <b>umount /mnt/secretstuff</b>
# <b>bioctl -d sd1</b>
</pre></blockquote>

Next time you need to access the drive, simply use bioctl(8) to attach it
and then repeat the last four commands as needed.

<p>
The man page for this looks a little scary, as the <tt>-d</tt> command is
described as "deleting" the volume.
In the case of crypto, however, it just deactivates encrypted volume so it
can't be accessed until it is activated again with the passphrase.

<p>
Many other options are available with softraid, and new features are
being added and improvements made, so do consult the aforementioned man
pages for detailed information.

<h4>I forgot my passphrase!</h4>

Sorry.
This is real encryption, there's not a back door or magic unlocking
tool.
If you lose your passphrase, your data on your softraid crypto volume
will be unusable.

<h3 id="softraidDR">14.18.4 - Disaster recovery</h3>

This is the section you want to skip over, but don't.
This is the reason for RAID -- if disks never failed, you wouldn't add
the complexity of RAID to your system!
Unfortunately, as failures are very difficult to list comprehensively,
there is a strong probability that the event you experience won't be
described exactly here, but if you take the time to understand the
strategies here, and the WHY, hopefully you can use them to recover
from whatever situations come your way.

<p>
Keep in mind, failures are often not simple.
The author of this article had a drive in a hardware RAID solution develop
a short across the power feed, which in addition to the drive itself,
also required replacing the power supply, the RAID enclosure and a power
supply on a second computer he used to verify the drive was actually
dead, and the data from backup as he didn't properly configure the
replacement enclosure.

<p>
The steps needed for system recovery can be performed in
<a href="faq8.html#LostPW">single user mode</a>, or from the
<a href="faq4.html#bsd.rd">install kernel (bsd.rd)</a>.

<p>
If you plan on practicing softraid recovery (and we <b>highly</b> suggest you
do so!), you may find it helpful to zero a drive you remove from the
array before you attempt to return it to the array.
Not only does this more accurately simulate replacing the drive with a
new one, it will avoid the confusion that can result when the system
detects the remains of a softraid array.

<p>
Recovery from a failure will often be a two-stage event -- the first
stage is bringing the system back up to a running state, the second
stage is to rebuild the failed array.
The two stages may be separated by some time if you don't have a
replacement drive handy.

<h4>Recovery from drive failure: secondary</h4>

This is relatively easy.
You may have to remove the failed disk to get the system back up.

<p>
When you are ready to repair the system, you will replace the failed
drive, create the RAID and other disklabel partitions, then rebuild the
mirror.
Assuming your RAID volume is <tt>sd0</tt>, and you are replacing the
failed device with <tt>wd1m</tt>, the following process should work:

<ul>
  <li>Boot the system back up.
  <li>Create appropriate partitions on your new drive
  <li>Rebuild your RAID partition and reboot:
</ul>

<blockquote><pre>
# <b>bioctl -R /dev/wd1m sd0</b>
# <b>reboot</b>
</pre></blockquote>

<h4>Recovery from drive failure: primary</h4>

Many PC-like computers can not boot from a second drive if the primary
drive has failed, but still attached unless it is so dead it isn't
detected.
Many can not boot from a drive that isn't the "primary", even if there
is no other drive.

<p>
In general, if your primary drive fails, you will have to remove it, and
in many cases "promote" your secondary drive to primary configuration
before the system will boot.
This may involve re-jumpering the disk, plugging the disk into another
port or some other variation.
Of course, what is on the secondary disk has to not only include your RAID
partition, but also has to be functionally bootable.

<p>
Once you have the system back up on the secondary disk and a new
disk in place, you rebuild as above.

<h4>Recovery from "shuffling" your disks</h4>

What if you have four disks in your system, say, sd0, sd1, sd2, and sd3,
and for reasons of hardware replacement or upgrade, you end up with the
drives out of the machine, and lose track of which was which?

<p>
Fortunately, softraid handles this very well, it considers the disks
"roaming," but will successfully rebuild your arrays.
However, the boot disk in the machine has to be bootable, and if you
just made changes in the root partition before doing this, you probably
want to be sure you didn't boot from your altroot partition by mistake.

<h3 id="softraidNotes">14.18.5 - Softraid notes</h3>

<h4>Complications when other sd(4) disks exist</h4>

Softraid disks are assembled <i>after</i> all other IDE, SATA, SAS and
SCSI disks are attached.
As a result, if the number of sd(4) devices changes (either by adding
or removing devices -- or if a device fails), the identifier of the
softraid disk will change.
For this reason, it's important to use <a href="faq14.html#DUID">DUIDs</a>
(Disklabel Unique Identifiers) rather than drive names in your
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab">fstab(5)</a> file.

<h4>Three disk RAID1?</h4>

Softraid supports RAID1 with more than two "chunks," and the man page
examples show a three-disk RAID1 configuration.
RAID1 simply duplicates the data across all the chunks of storage.
Two gives full redundancy, three gives additional fault tolerance.
The advantage of RAID1 with three (or more) disks/chunks is that, in
event of one disk failure, you still have complete redundancy.
Think of it as a hot spare that doesn't need time to rebuild!

<p>
<hr>
<p>
<a href= "index.html">[FAQ Index]</a>
<a href= "faq13.html">[To Section 13 - Multimedia]</a>
<a href= "faq15.html">[To Section 15 - Packages and Ports]</a>
</body>
</html>
