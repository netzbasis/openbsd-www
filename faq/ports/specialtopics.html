<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>3 - Special Porting Topics</title>
<meta name= "description"   content= "OpenBSD Porting Guide">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../../openbsd.css">
<link rel="canonical" href="http://www.openbsd.org/faq/ports/specialtopics.html">
</head>

<!--
Copyright (c) 2005-2010 XXX

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<!-- Passes validator.w3.org.  Please keep it this way -->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href="index.html">[Handbook Index]</a>
<a href="guide.html">[To Section 2 - OpenBSD Porting Guide]</a>
<a href="testing.html">[To Section 4 - Port Testing Guide]</a>
</font>

<h1><font color="#e00000">3 - Special Porting Topics</font></h1><hr>

<h3>Table of Contents</h3>
<ul>
  <li><a href="#SharedLibs" >3.1 - Shared Libraries</a>
  <li><a href="#Autoconf"   >3.2 - GNU autoconf</a>
  <li><a href="#Config"     >3.3 - Configuration Files</a>
  <li><a href="#Audio"      >3.4 - Audio Applications</a>
  <li><a href="#Mandoc"     >3.5 - Manual pages</a>
  <li><a href="#RcScripts"  >3.6 - rc.d(8) scripts</a>
</ul>

<hr>

<h2 id="SharedLibs">3.1 - Shared Libraries</h2>

<h3>Understanding shared libraries number rules</h3>
Shared libraries are a bit tricky for a variety of reasons.
You must understand the library naming scheme:
<tt>libfoo.so.major.minor</tt>.
<p>
When you link a program, the linker ld embeds that information in the created
binary.
You can see it with ldd. Later, when you run that program, the dynamic linker
ld.so uses that information to find the right dynamic library:
<ul>

	<li>A library with the same exact major number is required.
	<li>A library with an equal or higher minor number is required.
</ul>
So, this means that <b>all</b> libraries with the same major
number and an equal or higher minor number <b>must satisfy the
binary API that the program expects</b>.  If they do not, then your
port is broken. Specifically, it will break when users try to update their
system.
<p>
The rules for shared libraries are quite simple.
<ul>
	<li>If functions were added to the library, you must bump the
library minor number: a program that needs those functions has no way to
require it except by asking explicitly for at least this version.
	<li>If the existing API changes, that is, if any function signature
is altered, or if valid calling sequences are no longer valid, if a
type changes in an incompatible way, the library major number <b>must
be bumped</b>.
	<li>This includes removing old functions. Any function removal
should trigger a major number bump.
	<li>A good hint is to compare the output of

<blockquote><pre>
$ <b>nm -g oldlib.so.X.Y | cut -c10- | grep -e^T</b>
</pre></blockquote>

and

<blockquote><pre>
$ <b>nm -g newlib.so.X.Y | cut -c10- | grep -e^T</b>
</pre></blockquote>

This won't show if functions arguments type changed, but at least you'll see
quickly if some functions were added and/or removed.
</ul>
<p>
Sometimes, it happens that a library is written as several files, and that
internal functions happen to be visible to communicate between those files.
Those function names traditionally begin with an underscore, and are not
part of the API proper.

<h3>Tweaking ports builds to achieve the right names</h3>
Quite a few ports need tweaks to build shared libraries correctly anyways.
Remember that building shared libraries should be done with

<blockquote><pre>
$ <b>gcc -shared -fpic|-fPIC -o libfoo.so.4.5 obj1 obj2</b>
</pre></blockquote>

<p>
Trying to rename the library after the fact to adjust the version number
does not work: ELF libraries use some extra magic to set the library
internal name, so you must link it with the correct version the first time.

<p>
On the other hand, remember that you can override <tt>Makefile</tt> variables from
the command line, by using <tt>MAKE_FLAGS</tt> in the port's <tt>Makefile</tt>.
In some cases, the program you're porting will have a simple variable which
you can override by setting the library version in MAKE_FLAGS, for example
<tt>MAKE_FLAGS= SO_VERSION=${LIBfoo_VERSION}</tt>.
In others, the port will need to be patched to make use of such a variable.

<p>
The ports infrastructure already handles these details in libtool-based
and CMake-based ports.
For libtool, by default the version from the base OS is used, but in some
cases this is insufficient and <tt>USE_LIBTOOL=gnu</tt> can be set.
CMake is handled by using the <tt>cmake.port.mk</tt> module:
<tt>MODULES += devel/cmake</tt>.
In these cases, most details are handled automatically:
<ul>
	<li><tt>SHARED_LIBS</tt> is examined and version numbers are
	automatically replaced.
	<li>shared library building is logged in
	<tt>${WRKBUILD}/shared_libs.log</tt> which can be directly
	included in the port's <tt>Makefile</tt>.
</ul>

<h3>Avoid DT_SONAME hardcoding</h3>

<p>
Some ports use ld(1)'s <tt>-soname</tt> flag to override the library
specification in the DT_SONAME field.
Setting DT_SONAME is not a bug itself but is usually not desirable on
OpenBSD where ld.so(1) is smart and the ports tree takes care of library
versioning.
Moreover a wrong soname can result in unusable binaries that depend on this
library; either always or after some updates to the port containing the
library.
To check if the DT_SONAME field is set, run the following command:
<blockquote><pre>
$ <b>objdump -x /path/to/libfoo.so.0.0 | fgrep SONAME</b>
  SONAME      libfoo.so.0.0
</pre></blockquote>
As a general rule, <em>setting soname explicitly should be patched
out</em>.
The only exception is a situation when the right soname is recorded
<em>and</em> it's hard to patch soname-related code out <em>and</em>
upstream won't accept such a patch.  In that case the soname should
fully match the file name (see the example above).

<h3>Try putting all user visible libraries into /usr/local/lib</h3>

As a rule, requesting the user to add directories to their ldconfig path is a
very bad idea: all shared libraries that are linked directly to programs
should appear in <tt>/usr/local/lib</tt>.
However, it is quite possible to use a symbolic link to the actual library.
You should understand the library lookup rules:
<ul>
	<li>At build time, ld uses <tt>-L</tt> flags to set up paths to look
        for libraries.
        It stops looking as soon as it finds a library that matches its
        requirements.
	<li>At run time, ld.so uses the information cached through ldconfig
        to find the required library.

</ul>

So, let us assume you have two ports that provide two major versions of a
given library, say <tt>qt.1.45</tt> and <tt>qt.2.31</tt>.
Since both ports can be installed simultaneously, to make sure a given program
will link against <tt>qt.1</tt>, that library is provided as
<tt>/usr/local/lib/qt/libqt.so.1.45</tt>, and programs will be linked using

<blockquote><pre>
$ <b>ld -o program program.o -L/usr/local/lib/qt -lqt</b>
</pre></blockquote>

Similarly, a program that links with <tt>qt.2</tt> will use the
<tt>/usr/local/lib/qt2/libqt.so.2.31</tt> file with

<blockquote><pre>
$ <b>ld -o program program.o -L/usr/local/lib/qt2 -lqt</b>
</pre></blockquote>

<p>
To solve those libraries at run-time, a link called
<tt>/usr/local/lib/libqt.so.1.45</tt> and a link called
<tt>/usr/local/lib/libqt.so.2.31</tt> have been provided. This is
enough to satisfy ld.so.
<p>
It is an error to link a program using <tt>qt1</tt> with

<blockquote><pre>
$ <b>ld -o program program.o -L/usr/local/lib -lqt</b>
</pre></blockquote>

This code assumes that <tt>qt.2.31</tt> is not installed, which is
a wrong assumption.

<p>
Such tricks are only necessary in the rare cases of very pervasive
libraries where a transition period between major versions must be
provided. In general, it is enough to make sure the library appears in
<tt>/usr/local/lib</tt>.

<h3>Writing library dependencies correctly</h3>

The new dependency code does need complete library dependencies. You must
use <tt><b>make lib-depends-check</b></tt> or
<tt><b>make port-lib-depends-check</b></tt>
to verify a port does mention all
libraries it requires.
You just write them in <tt>LIB_DEPENDS</tt>/<tt>WANTLIB</tt> like this:

<blockquote><pre>
LIB_DEPENDS += x11/gtk+
WANTLIB += gtk&gt;=1.2 gdk&gt;=1.2
</pre></blockquote>

<p>
It is not an error to specify static libraries on a <tt>WANTLIB</tt> line as
well.
<tt>WANTLIB</tt> are fully evaluated at package build time: the resulting
package will have library dependency information embedded as lines for ld.so
that hold the actual major.minor number that was used for building, and
nothing for static libraries.

<p>
In fact, providing <tt>LIB_DEPENDS</tt> lines even for static libraries is a
good idea:
this will simplify port update if a given dependency goes from a static library
to a shared library.
<p>
<tt>WANTLIB</tt> lines must specify the same paths that are used for ld.
With the same example as above, a standard <tt>qt2</tt> depends fragment would
say <tt>WANTLIB += lib/qt2/qt.=2</tt>.
This allows the dependency checking code to do the right thing when
multiple versions of the same library are encountered.

<h3>Updating ports correctly</h3>

So, when you update or add a port that involves shared libraries, a few details
must be done right.
<ul>
	<li>Make sure the shared libraries major.minor numbers are correct.
	<li>Verify all ports that depend on your port. Verify that they
build correctly with your changes. Notify corresponding maintainers of the
update, so that they can verify their ports still run correctly.
	<li>You may have to adjust dependent ports <tt>WANTLIB</tt> and
<tt>LIB_DEPENDS</tt>.
If you introduce new shared libraries, watch out for <tt>BUILD_DEPENDS</tt>
that need to be turned into <tt>LIB_DEPENDS</tt>.
	<li>Whenever you introduce a new port, you should verify that you
are not creating a library that conflicts with an existing library:
libraries from two ports with the same name are deadly, because their
version numbering schemes have no chance to match.  You should try to solve
the situation with the software author (for instance, a library that is
called libnet is definitely badly named).
	<li>Check <a href="guide.html#PortsUpdate">the ports update guidelines</a>

for a more extensive discussion.
</ul>

<h2 id="Autoconf">3.2 - GNU autoconf</h2>

autoconf is a gnu tool that is supposed to help in writing portable
programs.
It is often used together with automake (portable makefiles) and
libtool (portable shared libraries).

<p>
Those tools do not work all that well, and often create specific challenges
in porting software to OpenBSD.

<h3>Detecting the use of autoconf in a piece of software</h3>

Quite a few software projects have configure scripts, and in most
cases, those scripts were generated by autoconf.
Such scripts have a line near the top that says:

<blockquote><pre>
# Generated automatically using autoconf version 2.13
</pre></blockquote>

or something similar.
The generation procedure is covered in a following section. Most often,
autoconf ports come with the generated scripts, and with the source
scripts that generated these.
The next section covers the simple case where you simply want to run the
generated script, and not modify it.
Make sure you read the section about Trojan horses as well.

<h3>Running an autoconf configure script</h3>

This script is normally run during the configure stage of ports building.
To invoke the configure script, one only has to set
<tt>CONFIGURE_STYLE=	gnu</tt>
which will automatically invoke <tt>${WRKSRC}/configure</tt>.

<p>
If your configure script lies elsewhere, just set <tt>CONFIGURE_SCRIPT</tt> to
the right value.

<p>
configure scripts often take a lot of arguments.
The default processing of the ports tree will only pass <tt>--prefix</tt> and
<tt>--sysconfdir</tt> to these.
Very old configure scripts don't understand <tt>--sysconfdir</tt>; you
can set <tt>CONFIGURE_STYLE=gnu old</tt> in such cases.

<p>
Similarly, some ports are not aware of <tt>DESTDIR</tt>.
Those ports will often accept setting <tt>prefix=${DESTDIR}/usr/local</tt>
without any issue, which can be done with <tt>CONFIGURE_STYLE=gnu dest</tt>.

<p>
Ports using autoconf and automake will have <tt>Makefile</tt>s
with a specific format, that begins with a few standard locations:
<ul>

<li><tt>bindir</tt>: location for binaries
<li><tt>sysconfdir</tt>: location for configuration
<li><tt>includedir</tt>: location for include dirs
</ul>
If the configure script does not allow you to override these, you may
still be able to do it later on during the build or <tt>fake</tt> stage.
This does assume, of course, that the only reference to such a directory is with
in the generated <tt>Makefile</tt>.

<p>
For instance, a neat trick involves switching <tt>sysconfdir</tt> to
<tt>${PREFIX}/share/example/pkgname</tt> during the <tt>fake</tt> stage, to get
default config files to package (since packages don't normally store files
under <tt>/etc</tt>).

<p>
Ports fully using autoconf and automake  may support building
under a different directory: try setting <tt>SEPARATE_BUILD=flavored</tt> and
see if that works.
This would allow you to wipe the build tree without wiping the source tree, by
giving you separate <tt>${WRKSRC}</tt> and <tt>${WRKBUILD}</tt> locations.
In a few cases, separate builds may need to use gmake, where the rest
of the port is happy with bsd-make, in which case this is not worth it.

<p>
automake will generate a few rules to rebuild all the generated scripts
if anything changes.
These often get in the way of OpenBSD specific patches.
For that reason, as soon as <tt>CONFIGURE_STYLE</tt> corresponds to
autoconf use, <tt>post-patch</tt> will touch various files in a
specific order, so that no automake dependencies get triggered later.
The list of dependencies is given in tsort(1) order in a file mentioned in
<tt>REORDER_DEPENDENCIES</tt> (the default is
<tt>${PORTSDIR}/infrastructure/mk/automake.dep</tt>).

<h3>The mechanics of configure checks</h3>

The configure script first runs a fixed script called
<tt>config.guess</tt>, that will determine which system configure is
running on.
<tt>config.guess</tt> does not vary from port to port and is a fixed script, so
the OpenBSD ports tree replaces it with a fixed version that knows about some
specific OpenBSD architectures.
Since most software packages come with bundled <tt>config.guess</tt>, and since
some of them are quite old, this is a necessary step.
If a software package contains more than one <tt>config.guess</tt>, you can
overwrite them all by setting <tt>MODGNU_CONFIG_GUESS_DIRS</tt> to the full list
of directories to process.

<p>
The configure script generated by autoconf then simply checks
all functionality on the existing system, by looking for a compiler, and running
simple test programs through it.
Since some of these tests are quite lengthy, the ports tree primes
configure with a <tt>CONFIG_SITE=config.site</tt> file.
configure will look at the contents of that file first before running
the tests.
A few configure scripts may have bugs that will prevent them from
running correctly in the presence of <tt>config.site</tt>.
Setting <tt>CONFIG_SITE</tt> to empty will weed out these kind of problems.
<p>
Most configure will auto-detect quite a few conditions.
It is very important to look at configure's options,
at configure's output, and at the generated <tt>config.log</tt> file:
these will tell you what options were found, and what options were not found.
This will allow you to find out when configure did not find a package
that was installed.
<p>
This will also tell you which optional packages configure would find.
In the ports tree, those are called hidden dependencies.
This is a bad thing: a hidden dependency is some extra package
configure will pick up if it's installed.
Then it will proceed in building a mutant package.
In some cases, the build will fail because of OpenBSD peculiarities.
In some cases, the package creation will fail, as some files will have different
names.
In some cases, the resulting package will be incorrect, as it will fail to
record any dependency on the optional package.
So looking at configure's output is one of the most important duty of
ports' maintainers.
Watch out for cascading tests: detecting a given feature may lead a
configure script to try out and find some dependent feature, so you
will not see the second feature in the configure output unless the
first feature is triggered.
<p>
In case some hidden dependencies are found, some action should be taken.
The most simple action is to install the optional package, and see what
configure will do.
If it detects the package, one can either disable the detection (by using
configure options, or environment variables, or patching the
configure script), or verify that the build goes well and add the
dependency to the list of dependent packages.
A better choice is to figure out a reasonable set of default dependencies, and
then add some flavors to cover other common features.

<h3>Re-generating configure scripts</h3>

configure scripts are normally generated from a <tt>configure.in</tt>
file (recent versions of autoconf use a <tt>configure.ac</tt> file
instead).
A standard library of definitions is often available in an <tt>aclocal.m4</tt>.
<p>
In most cases, patching configure directly is a bad idea.
It is better to patch the <tt>configure.in</tt> file and get the ports tree to
call autoconf.
Good porters will endeavor to write <tt>configure.in</tt> changes that they can
feed to software authors.
<p>
Different versions of autoconf will produce distinct configure
scripts.
<tt>autoconf-2.13</tt> is special: it was used over a fairly long period, and
there has been mutant versions of <tt>autoconf-2.13</tt> (actually, betas of a
newer autoconf) in wide use.
Hence, using <tt>autoconf-2.13</tt> will often not produce the exact same
configure script.
<p>
Since having several autoconf versions around at the same time is
useful, the autoconf script actually available in the ports tree is
part of a port called metaauto.
Which autoconf script actually gets called is controlled through the
environment variable <tt>AUTOCONF_VERSION</tt>.
Calling autoconf happens if you set <tt>CONFIGURE_STYLE=autoconf</tt>,
together with setting <tt>AUTOCONF_VERSION</tt>.
In most cases, identify the version of autoconf that was used to generate
the distributed configure script (usually obvious when reading the script)
and use this same version yourself.

<p>
autoconf relies on the standard unix preprocessor m4(1).
Normally, autoconf relies on some features on the GNU version of m4, gm4.
Fortunately, OpenBSD's m4 has enough features to run autoconf
as well, it just needs to be invoked with <tt>-g</tt> to handle
autoconf.
Very seldom, autoconf run with OpenBSD's m4 will produce
bogus configure scripts.
The OpenBSD developers will fix such an issue.

<h3>Trojan horses</h3>

Configure scripts are big generated files.  They are an ideal hiding place
for Trojan horses, and this has indeed already happened in the past.
This is the main reason for having most versions of autoconf in the tree:
a good porter is expected to check that a generated configure script matches
what the ports tree autoconf builds.

<h3>Interaction with other programs</h3>

autoheader is another program related to autoconf that is normally run to
create a <tt>config.h.in</tt> file.
Setting <tt>CONFIGURE_STYLE=autoconf</tt> will also run autoheader.
A few ports don't use autoheader.
Setting <tt>CONFIGURE_STYLE=autoconf no-autoheader</tt> will fix that issue.
<p>
libtool has a few specific hooks in <tt>configure.in</tt>.
There is often a <tt>libtool.m4</tt> script that goes with it.
Getting libtool to do the right thing goes beyond the scope of this
documentation.
<p>
KDE uses an extra layer on top of autoconf.
This extra layer assembles a <tt>configure.in</tt> file from a set of
<tt>configure.in.in</tt> files, and is also able to tweak both
<tt>configure.in</tt> for snappier results, and <tt>Makefile.in</tt> to allow
for some supplementary options in building, and to automatically insert
<tt>DESTDIR</tt> in the right places.
The <tt>AUTOCONF</tt> variable can be used to tweak the actual autoconf
script that gets run, and KDE expects <tt>/bin/sh ${WRKDIST}/admin/cvs.sh</tt>
to work correctly.

<h2 id="Config">3.3 - Configuration Files</h2>

Packages should only install files under <tt>${PREFIX}</tt>, which is
<tt>/usr/local</tt> by default.
On the other hand, the OpenBSD policy is to install most configuration files
under <tt>${SYSCONFDIR}</tt>, which is <tt>/etc</tt> by default.
<p>
<i>Note that it is perfectly acceptable for a binary package to have both
<tt>${PREFIX}</tt> and <tt>${SYSCONFDIR}</tt> hardcoded: <tt>PREFIX</tt> and
<tt>SYSCONFDIR</tt> are mostly user settings that influence the build of the
package.</i>
<p>

<h3><tt>@sample</tt> explained</h3>

Packing-lists contain a specific <tt>@sample</tt> mechanism to deal with
configuration files:
<ul>
<li>During fake installation, the port should install a sample configuration
file, for instance as <tt>${PREFIX}/share/examples/PKGNAME/foo.rc</tt>.
<li>The packing-list should contain a <tt>@sample ${SYSCONFDIR}/foo.rc</tt>
right under the sample configuration file.
<li>During installation, the default example configuration file will be copied
into the actual location where the configuration file should live.
<li>During updates and deinstallation, an existing configuration file will be
compared with the default example file. If they differ, the package tools will
inform the user and let him perform the update/removal himself. If they are
identical, the package tools know they can proceed and update/remove the
configuration files without any further precautions.
</ul>

<h3>more <tt>@sample</tt> specificities</h3>

Contrary to other files in a packing-list, <tt>@sample</tt> entries can
have an absolute path name.

<p>
Some big packages will also need their own configuration directory,
<tt>@sample ${SYSCONFDIR}/directory/</tt> will deal with that.
<p>
Using <tt>@sample directory/</tt> to create port specific directories
that do not hold any configuration files is perfectly good style.
<tt>@sample</tt> correctly interprets correct <tt>@mode</tt>,
<tt>@owner</tt>, <tt>@group</tt> annotations.   This can be a
bit cumbersome, because you will often need to switch back and forth
between a default mode and a configuration file specific mode.

<h3>Special tricks</h3>

<tt><b>make update-plist</b></tt> knows how to copy <tt>@sample</tt>
annotations over, but it does not know how to create them, so they have
to be written in the first place.
<p>
Note the distinction between configuration files and example configuration
files: the port must be configured to find its files under
<tt>${SYSCONFDIR}</tt>, it is only the fake installation stage that must
put stuff under <tt>${PREFIX}/share/examples</tt>.
One simple way to handle that is to copy the files over in a <tt>post-install</tt>.

<p>
A neat trick which often works is to look at a program's <tt>Makefile</tt>, and
override the configuration directory in the fake installation stage by using
specific <tt>FAKE_FLAGS</tt>, for instance:

<blockquote><pre>
FAKE_FLAGS=	DESTDIR=${WRKINST} \
		sysconfdir=${WRKINST}${TRUEPREFIX}/share/examples/PKGNAME
</pre></blockquote>

You just need to watch out for programs that write the configuration directory
down in specific files during their install stage.

<h3>Examples</h3>

<ul>
<li>The <tt>security/integrit</tt> port uses a configuration directory with a
few files.
Its packing-list looks like this:

<blockquote><pre>
@comment &#36;OpenBSD&#36;
@bin bin/i-ls
@info info/integrit.info
@man man/man1/i-ls.1
@man man/man1/i-viewdb.1
@man man/man1/integrit.1
@bin sbin/i-viewdb
@bin sbin/integrit
share/doc/integrit/
share/doc/integrit/README
share/doc/integrit/crontab
share/doc/integrit/install_db
share/doc/integrit/integrit_check
share/doc/integrit/viewreport
share/examples/integrit/
@sample ${SYSCONFDIR}/integrit/
share/examples/integrit/root.conf
@sample ${SYSCONFDIR}/integrit/root.conf
share/examples/integrit/src.conf
@sample ${SYSCONFDIR}/integrit/src.conf
share/examples/integrit/usr.conf
@sample ${SYSCONFDIR}/integrit/usr.conf
</pre></blockquote>

<li>The <tt>security/nessus</tt> port uses <tt>@sample dir/</tt> to create
private directories.

<blockquote><pre>
...
sbin/uninstall-nessus
@sample ${SYSCONFDIR}/nessus/
@mode 0700
@sample /var/nessus/
@sample /var/nessus/jobs/
@sample /var/nessus/logs/
@sample /var/nessus/users/
@extraunexec rm -fr %D/lib/nessus/plugins/*
@extraunexec rm -fr %D/nessus
@extraunexec rm -fr /var/nessus
</pre></blockquote>

<li>The <tt>sysutils/nut</tt> port uses a specific owner for its configuration
files.

<blockquote><pre>
@comment &#36;OpenBSD&#36;
@conflict upsd-*
@newuser ${NUT_USER}:${NUT_ID}:daemon:UPS User:/var/empty:/sbin/nologin
...
share/examples/nut/
@sample ${SYSCONFDIR}/nut/
@owner ${NUT_USER}
share/examples/nut/ups.conf
@sample ${SYSCONFDIR}/nut/ups.conf
share/examples/nut/upsd.conf
@mode 600
@sample ${SYSCONFDIR}/nut/upsd.conf
@mode
share/examples/nut/upsd.users
@mode 600
@sample ${SYSCONFDIR}/nut/upsd.users
@mode
share/examples/nut/upsmon.conf
@mode 600
@sample ${SYSCONFDIR}/nut/upsmon.conf
@mode
share/examples/nut/upssched.conf
@sample ${SYSCONFDIR}/nut/upssched.conf
@mode 700
@sample /var/db/nut/
@mode
@owner
share/ups/
share/ups/cmdvartab
share/ups/driver.list
</pre></blockquote>

</ul>

<h2 id="Audio">3.4 - Audio Applications</h2>

<p>
  This document currently deals with sampled sounds issues only. Contributions
  dealing with synthesizers and waveform tables are welcome.


<p>

	Audio applications tend to be hard to port, as this is a domain where
	interfaces are not standardized at all, though approaches don't vary
	much between operating systems.


<h3>Using <tt>ossaudio</tt></h3>

  The <tt>ossaudio</tt> emulation is possibly the simplest way, but
  it won't always work, and it is not such a great idea usually.
  <ul>
  	<li>It redefines <tt>ioctl</tt>. If the code to port uses
	<tt>ioctl</tt> for more than audio, you will have to
	<tt>#undef ioctl</tt> and use the bare form with
	<tt>_ossioctl</tt>.

	<li>Some features of linux sound are not emulated.

	<li>Applications with correct linux sound support that is not
	Intel-specific tend to use these features.

  </ul>

  <h3>Using existing NetBSD or FreeBSD code</h3>
  Since we share part of the audio interface with NetBSD and FreeBSD,
  starting from a NetBSD port is reasonable. Be aware that some files
  changed places, and that some entries in <tt>sys/audioio.h</tt>
  are obsolete.  Also, many ports tend to be incorrectly coded and to
  work on only one type of machine. Some changes are bound to be
  necessary, though.  Read through the next part.

  <h3>Writing OpenBSD code</h3>

	  <h3><font color="#0000e0">libsndio</font></h3>
   <p>

	OpenBSD has its own audio layer provided by the sndio library,
	documented in
	<a href="http://man.openbsd.org/?query=sio_open&amp;sektion=3">sio_open(3)</a>.
	Until it's merged into this page, you can find further information
	about programming for this API in the guide,
	<a href="http://www.sndio.org/tips.html">hints on
	writing and porting audio code</a>.
	sndio allows user processes to access
<a href="http://man.openbsd.org/?query=audio&amp;sektion=4">audio(4)</a>
	hardware and the
<a href="http://man.openbsd.org/?query=sndiod&amp;sektion=8">sndiod(8)</a>
	audio server in a uniform way.
	It supports full-duplex operation, and when used with the
<a href="http://man.openbsd.org/?query=sndiod&amp;sektion=8">sndiod(8)</a>
	server it supports resampling and format conversions on the fly.

	  <h3><font color="#0000e0">Hardware independence</font></h3>

   <p>
	<b>YOU SHOULDN'T ASSUME ANYTHING ABOUT THE AUDIO HARDWARE USED.
	</b><br>
	Wrong code is code that only checks the <tt>a_info.play.precision</tt>
	field against 8 or 16 bits, and assumes unsigned or signed samples based
	on soundblaster behavior. You should check the sample type explicitly,
	and code according to that. Simple example:

<blockquote><pre>
AUDIO_INIT_INFO(&amp;a_info);
a_info.play.encoding = AUDIO_ENCODING_SLINEAR;
a_info.play.precision = 16;
a_info.play.sample_rate = 22050;
error = ioctl(audio, AUDIO_SETINFO, &amp;a_info);
if (error)
    /* deal with it */
error = ioctl(audio, AUDIO_GETINFO, &amp;a_info);
switch(a_info.play.encoding)
    {
case AUDIO_ENCODING_ULINEAR_LE:
case AUDIO_ENCODING_ULINEAR_BE:
    if (a_info.play.precision == 8)
        /* ... */
    else
        /* ... */
    break;
case ...

default:
    /* don't forget to deal with what you don't know !!! For instance, */
    fprintf(stderr,
        "Unsupported audio format (%d), ask ports@ about that\n",
            a_info.play.encoding);

    }
    /* now don't forget to check what sampling frequency you actually got */
</pre></blockquote>

  <p>
  This is about the smallest code fragment that will deal with most issues.

  	<h3><font color="#0000e0">16 bit formats and endianness</font></h3>
	In normal usage, you just ask for an encoding type (e.g.,
	<tt>AUDIO_ENCODING_SLINEAR</tt>), and you retrieve
	an encoding with endianness (e.g., <tt>AUDIO_ENCODING_SLINEAR_LE</tt>).
	Considering that a soundcard does not have to use the same endianness
	as your platform, you should be prepared to deal with that.
	The easiest way is probably to prepare a full audio buffer, and to use
	swab(3) if an endianness change is required.
	Dealing with external samples usually amounts to:
	<ol>

		<li>Parsing the sample format,
		<li>Getting the sample in,
		<li>Swapping endianness if it is not your native format,
		<li>Computing what you want to output into a buffer,
		<li>Swapping endianness if the sound card is not in your native format,
		<li>Playing the buffer.
	</ol>
	Obviously, you may be able to remove steps 3 and 5 if you are simply
	playing a sound sample which happens to be in your sound card native
	format.

	<h3><font color="#0000e0">Audio quality</font></h3>
	<p>
	Hardware may have some weird limitations, such as being unable to get
	over 22050 Hz in stereo, but up to 44100 in mono.  In such cases, you
	should give the user a chance to state his preferences, then try your
	best to give the best performance possible. For instance, it is stupid
	to limit the frequency to 22050 Hz because you are outputting stereo.
	What if the user does not have a stereo sound system connected to his
	audio card output ?

	<p>
	It is also stupid to hardcode soundblaster-like limitations into your
	program. You should be aware of these, but do try to get over the
	22050&nbsp;Hz/stereo barrier and check the results.

	<h4>Sampling frequency</h4>
	You should definitely check the sampling frequency your card gives you
	back. A 5% discrepancy already amounts to a half-tone, and some people
	have much more accurate hearing than that, though most of us won't
	notice a thing.  Your application should be able to perform
	resampling on the fly, possibly naively, or through devious
	applications of Shannon's resampling formula if you can.

	<h4>Dynamic range</h4>
	<p>

	Samples don't always use the full range of values they could.  First,
        samples recorded with a low gain will not sound very loud on the
	machine, forcing the user to turn the volume up.
	Second, on machines with badly isolated audio, low sound output means
	you mostly hear your machine heart-beat, and not the sound you expected.
	Finally, dumb conversion from 16 bits to 8 bits may leave you with only
	4 bits of usable audio, which makes for an awfully bad quality.

	<p>
	If possible, the best solution is probably to scan the whole stream
	you are going to play ahead of time, and to scale it so that it fits
	the full dynamic range.  If you can't afford that, but you can manage
	to get a bit of look-ahead on what you're going to play, you can
	adjust the volume boost on the fly, you just have to make sure
	that the boost factor stays at a low frequency compared to the
	sound you want to play, and that you get absolutely <i>no
	overflows</i> -- those will always sound much worse than the
	improvement you're trying to achieve.<br>
	As sound volume perception is logarithmic, using arithmetic shifts is usually
	enough. If your data is signed, you should explicitly code the shift as
	a division, as C <tt>&gt;&gt;</tt> operator is not portable on
	signed data.

	<p>

	If all else fails, you should at least try to provide the user with
	a volume scaling option.

	<h3><font color="#0000e0">Audio performance</font></h3>
	<p>
	Low-end applications usually don't have much to worry about.  Keep in
	mind that some of us do use OpenBSD on low-end 68030, and that if a
	sound application can run on that, it should.

	<p>
	Don't forget to run benches.  Theoretical optimizations are just that:
	theoretical. Some hard figures should be collected to check what's a
	sizeable improvement, and what's not.

	<p>
	For high performance audio applications, such as mpegI-layer3, some
	points should be taken into account:

	<ul>
	    <li>The audio interface does provide you with the natural hardware
	    blocksize. Using multiples of that for your output buffer is
	    essential.  Keep in mind that <tt>write</tt>, as a system call,
	    incurs a high cost compared to internal audio processing.

	    <li>Bandwidth is a very important factor when dealing with audio.
	    A useful way to optimize an audio player is to see it as a
	    decompressor. The longer you can keep with the compressed data, the
	    better usually. Very short loops that do very little processing are
	    usually a bad idea. It is generally much better to combine all
	    processing into one loop.

	    <li>Some formats do incur more overhead than others. The
	    <tt>AUDIO_GETENC</tt> <tt>ioctl</tt> should be used
	    to retrieve all formats that the audio device provides.
	    Be especially aware of the
	    <tt>AUDIO_ENCODINGFLAG_EMULATED</tt> flag. If your
	    application is already able to output all kinds of weird formats,
	    and reasonably optimized for that, try to use a native format at
	    all costs. On the other hand, the emulation code present in the
	    audio device can be assumed to be reasonably optimal, so don't
	    replace it with quickly hacked up code.
	</ul>

	<p>A model you may have to follow to get optimal results is to first
	compile a small test program that enquires about the specific audio
	hardware available, then proceed to configure your program so that it
	deals optimally with this hardware. You may reasonably expect people
	who want good audio performance to recompile your port when they change
	hardware, provided it makes a difference.

	<h3><font color="#0000e0">Real time or synchronized</font></h3>
	<p>
	Considering that OpenBSD is not real time, you may still wish to write
	audio applications that are mostly real time, for instance games. In
	such a case, you will have to lower the blocksize so that the sound
	effects don't get out of synch with the current game.  The problem
	with this if that the audio device may get starved, which yields
	horrible results.

	<p>
	In case you simply want audio to be synchronized with some graphics
	output, but the behavior of your program is predictable, synchronization
	is easier to achieve. You just play your audio samples, and ask the
	audio device what you are currently playing with
	<tt>AUDIO_GETOOFFS</tt>, then use  that information to
	post-synchronize graphics.  Provided you ask sufficiently often (say,
	every tenth of a second), and as long as you have enough horse-power to
	run your application, you can get very good synchronization that way.
	You might have to tweak the figures by a constant offset, as there is
	some lag between what the audio reports, what's currently playing, and
	the time it takes for XWindow to display something.

  <h3>Contributing code back</h3>
   <p>In the case of audio applications, working with the original program's
	author is very important. If their code only works with soundblaster
	cards, for instance, there is a good chance they will have to cope with
	other technology soon.

	<p>
	<b>If you don't send your comments to the author, your work will
	have been useless</b>.
	<p>
	It may also be that the author has already noticed whatever problems
	you are currently dealing with, and is addressing them in his current
	development tree.  If the patches you are writing amount to more than
	a handful of lines, cooperation is almost certainly a very good idea.

<h2 id="Mandoc">3.5 - Manual pages</h2>

<p>This section provides guidelines on how to deal with
groff versus <a href="http://man.openbsd.org/?query=mandoc&amp;sektion=1">mandoc(1)</a>
issues in ports.

<h3>Should I check anything?</h3>

<p>When creating a new port or updating an existing port, you are welcome
to check whether the port can use mandoc to format its manuals.
This may make the manuals more useable for the port's users, and it will
reduce the port's build time.  Note that these checks are recommended,
but not strictly required to create a new port.  It is also acceptable to
just put <tt>USE_GROFF=Yes</tt> into the <tt>Makefile</tt> and be done with it.
Marc has done that more than 3.000 times, and we didn't kill him.

<p>Ports matching one or more of the following criteria are good candidates
for doing the checks described below, so in these cases, a bit of your time
is likely well spent:

<ul>
<li>You know the upstream authors, you know they care about good and
portable documentation, and they gladly accept documentation patches.
<li>The documentation is written using the
<a href="http://man.openbsd.org/?query=mdoc&amp;sektion=7">mdoc(7)</a>
language rather than the
<a href="http://man.openbsd.org/?query=man&amp;sektion=7">man(7)</a>
language.  To distinguish the two, look at the beginning of the manual
source code:  .Dd is mdoc(7), .TH is man(7).
<li>The documentation is man(7), but generated by
<a href="http://man.openbsd.org/?query=pod2man&amp;sektion=1">pod2man(1)</a>.
For such pages, the first line of the manual source code reads<br>
<tt>.\" Automatically generated by Pod::Man...</tt>
</ul>

<p>Of course, ports not matching these criteria might work as well,
so there is nothing wrong with checking if you like to.
However,
<ul>
<li>if a port is using DocBook, checking mandoc compatibility will likely
turn out to be a waste of time.
<li>if a port is using <tt>CONFIGURE_STYLE = imake</tt>,
merely removing <tt>USE_GROFF</tt> is insufficient,
because <tt>/usr/X11R6/lib/X11/config/OpenBSD.cf</tt>
will still attempt to call groff.
Typically, you need to convince Imake to not format the manual(s),
for example by changing <tt>ComplexProgramTarget</tt> to
<tt>ComplexProgramTargetNoMan</tt> and install the manual(s) by hand,
typically using a <tt>post-install</tt> target in the port <tt>Makefile</tt>.
See <tt>sysutils/xbattbar</tt> for a simple example.
</ul>

<p>When you choose to do any checks, note that both automatic and manual
checks are required.  In case you are not willing to do a manual check at
the end, looking over the manuals as formatted with mandoc, do not bother
with the automatic part of the checks, just put <tt>USE_GROFF=Yes</tt>.

<p>Only remove <tt>USE_GROFF</tt> if you plan to actively maintain
the port.
Removing <tt>USE_GROFF</tt> from a port nobody is going to maintain
will force the poor soul doing the next update to redo the check.
If that person fails to check and the upstream author has added
any features to the manuals mandoc does not support, we will end up with
unusable manuals.

<h3>Which tools do I need?</h3>

<p>Before you start checking anything, make sure you have -current mandoc
installed.  For now, it should not be older than one or two months:
being told about issues
that have been fixed long ago will not help mandoc developers.
In case of doubt, just update your mandoc utility, it is really quick
and easy, and does not require to have your whole system up to date:

<blockquote><pre>
$ <b>cd /usr/src/usr.bin/mandoc/</b>
$ <b>cvs up -dP</b>
$ <b>make cleandir</b>
$ <b>make obj</b>
$ <b>make depend</b>
$ <b>make</b>
$ <b>sudo make install</b>
</pre></blockquote>

Optionally, you may also get a copy of the
<a href="http://mdocml.bsd.lv/cgi-bin/cvsweb/gmdiff?cvsroot=mdocml">gmdiff</a>
utility script that helps to compare groff and mandoc output.
The gmdiff script is not strictly required, doing the necessary checks
by hand is perfectly acceptable.

<h3>How do I report the results?</h3>

<p>The following paragraphs ask for sending in reports to the mandoc
maintainers in some particular situations.  Before sending such reports,
please always tick off the following checklist:

<ol>
<li>For the time being, do not report problems related to DocBook.
We know source code generated by DocBook is extremely crappy even
when DocBook works as intended, and on top of that, DocBook tends
to be more buggy than average software.  We also know that mandoc
usually parses and renders DocBook output badly, and we know what to
do to improve mandoc in this respect.  This may change in the future,
but right now, more than half of all reports that fail to reveal new,
useful information are related to DocBook, and the signal-to-noise
ratio in DocBook reports is too low to be worthwhile.
<li>Make sure your mandoc binary is up to date - see above.
<li>Attach the <a href="http://man.openbsd.org/?query=mdoc&amp;sektion=7">mdoc(7)</a>
or <a href="http://man.openbsd.org/?query=man&amp;sektion=7">man(7)</a>
source file in question to the mail.  This may either be a file contained
in the distribution tarball or a file generated during the build process.
In case several files exhibit the problems, choose one that shows all
problems.  In case different files exhibit different problems you wish
to report, attach as many files as necessary.  The point is to save the
mandoc maintainers the work of downloading distribution tarballs, searching
them for source files, sometimes even installing software before being able
to start a build, while you have that information readily at hand, anyway.
<li>Briefly describe all the problems you want to report, and
where they can be seen in which file.  I have spent time wondering
what exactly the reporter's point was more than once in the past.
<li>In case your report is related to errors or warnings printed
by the mandoc utility, copy the output of <tt><b>mandoc -Tlint</b></tt>
(or <tt><b>mandoc -Tlint -Werror</b></tt> when warnings are irrelevant)
into the body of your mail.  Usually, this is easy to reproduce,
but it did happen that it was not, causing unnecessary confusion.
<li>In case the version of the port you are talking about is not yet
committed, please attach what is needed to build the uncommitted
port: A diff against -current when it is an update, or a tarball
of the port directory when it is a completely new port.  Very often,
the source files will be sufficient to identify the problem; however,
in those cases where they are not, mailing back and forth or searching
mailing list archives just to get the needed additional information is
a waste of time.
<li>As a rule, please mail to both schwarze@ and kristaps@ to
minimize the risk that real problems get lost.  Unless you are
the maintainer of the port, Cc: him or her.  Unless you are an
OpenBSD developer, in case you regularly work with a developer
who is committing your ports and who you know is interested in
this port, Cc:ing him or her may be useful as well.
</ol>

<h3>How do I do automatic checking?</h3>

<p>To do the automatic part of the check, please run the following command
over all <a href="http://man.openbsd.org/?query=mdoc&amp;sektion=7">mdoc(7)</a>
and <a href="http://man.openbsd.org/?query=man&amp;sektion=7">man(7)</a>
manual source files contained in the port:

<blockquote><pre>
$ <b>mandoc -Tlint -Werror *</b>
</pre></blockquote>

<p>If this produces a considerable number of error messages, for now,
the port needs <tt>USE_GROFF</tt>.  Don't even consider using mandoc
for anything here, it's not up to the job yet.  Sending a report to
the mandoc developers is useful if:

<ul>
<li>The manual pages in question are generated by
<a href="http://man.openbsd.org/?query=pod2man&amp;sektion=1">pod2man(1)</a>.
<li>The manual pages in question are in
<a href="http://man.openbsd.org/?query=mdoc&amp;sektion=7">mdoc(7)</a> format.
<li>You find one or more messages "ERROR: skipping unknown macro",
and the fact that the manual pages you are looking at use these macros
is not yet reported in the mandoc
<a href="http://mdocml.bsd.lv/cgi-bin/cvsweb/TODO?cvsroot=mdocml">TODO</a>
list.  Even if we already now that a certain roff request is still
unsupported, learning which manuals actually use it is useful to get
our priorities right when implementing new features.
</ul>

<p>If manual pages look good with groff, never patch them to get rid of
mandoc errors.  That would merely be a make-work project not helping
anyone: It will neither help to improve upstream manuals nor mandoc.

<h3>How do I do manual checking?</h3>

<p>If there are no errors, proceed to the manual part of the check.
Look at the manuals as formatted by mandoc.  Do they look fine?
If yes, you do not need <tt>USE_GROFF</tt>, and there is no need
to report anything.

<p>If there are no errors, but mandoc output has serious issues, that
is, relevant information is missing or part of the output is seriously
garbled, please always report your findings, even if you
happen to know it's due to a known issue with mandoc.  We do want to know
which issues cause serious problems in practice, such that we can address
the most pressing issues first.

<p>If mandoc output has serious issues and groff output looks bad
as well, then the manuals are probably just broken upstream.
In that case, you have
the usual options when porting broken software:  Abandon the port,
ignore the problem, report upstream, and/or patch the bugs away.
In case you need help with the latter, talk to schwarze@.

<p>If there are no errors, but mandoc output has minor issues that
don't really hinder the user when reading the manual, you are welcome
to report these issues as well.  In that case, you are even more
welcome to first check the mandoc
<a href="http://mdocml.bsd.lv/cgi-bin/cvsweb/TODO?cvsroot=mdocml">TODO</a>
list, to avoid having the same minor issues reported again and again -
but in case of doubt, it is always better to report dupes than to let
problems go unnoticed.

<p>If there are only very few errors, in particular if you get the
impression that mandoc output is just fine all the same, it's your
call to either set <tt>USE_GROFF=Yes</tt> (that's the quicker way out)
or to report it and ask whether it's acceptable to remove
<tt>USE_GROFF</tt> in that particular case.  Reporting it is
often a great help in order to improve mandoc error reporting,
in particular to identify and remove bogus mandoc errors messages.

<p>To speed up the manual checks, in particular if you are often doing
mandoc checks on OpenBSD ports, and to reduce the risk of overlooking
problems, consider using the 
<a href="http://mdocml.bsd.lv/cgi-bin/cvsweb/gmdiff?cvsroot=mdocml">gmdiff</a>
utility script.  It takes the file names of an arbitrary number of manual
source files as arguments, runs both groff and mandoc on all the files
in turn, and compares the output of both programs.  However, bear in mind
that you are still doing manual checks with the ultimate goal to judge
the quality of mandoc output:  All the above points still apply even when
you are using the gmdiff script to help your work.
Also note that gmdiff will usually find minor formatting differences
between both programs, in particular with respect to whitespace.
If mandoc output looks good, even if it's slightly different from
groff output, <tt>USE_GROFF</tt> is not needed.<p>

For ease of use, it's possible to call gmdiff from a custom target in mk.conf:

<pre>gmdiff:
	@make fake; cd ${WRKINST}${TRUEPREFIX}; find man -type f -path 'man/man*' -print0 | xargs -0r gmdiff | less</pre>

<h3>What about warnings?</h3>

<p>You might wonder about mandoc warnings, as opposed to mandoc errors.
In a nutshell, the distinction is that errors may seriously impact the
usefulness of the output, while warnings might at the worst cause minor
formatting glitches, if at all.  If a mandoc warning appears to be
related to seriously garbled output, that's probably a bug in mandoc
and should always be reported.

<p>That said, it is obvious that warnings are irrelevant for the decision
whether to use or not to use mandoc for a given port.  They are for
manual authors, to help improve manual quality, not for porters.

<h3>How can I help upstream?</h3>

<p>In case you are one of the port's upstream developers, or know they care
about good quality of their manuals and gladly accept patches, it may
make sense to use <tt><b>mandoc -Tlint</b></tt>
to identify potential formatting issues and to produce patches to be
submitted upstream.  Usually, there is no need to put such patches into
the ports tree.

<p>As with any kind of linting, before changing your
<a href="http://man.openbsd.org/?query=mdoc&amp;sektion=7">mdoc(7)</a> or
<a href="http://man.openbsd.org/?query=man&amp;sektion=7">man(7)</a>
source code or sending out patches, first make sure you are chasing
real problems in the manuals.  The mandoc utility is not perfect.
It may produce bogus warnings.  We are trying to fix that, but there
will always be room for improvement.  In case of doubt, report
the issue and ask for advice.

<h2 id="RcScripts">3.6 - rc.d(8) scripts</h2>

<p>
This section is intended to provide some information on writing and
installing <i>rc.d(8) scripts</i>.


<p>
Ports that install a daemon benefit greatly from having rc.d(8) scripts.
It allows the user to easily check if the daemon is running, as well as
providing an easy and consistent way to start and stop it.


<h3>Writing rc.d(8) scripts</h3>
<p>
Writing an rc.d(8) script is straightforward and simple due to the clean
and simple design of the
<a href="http://man.openbsd.org/?query=rc.subr&amp;sektion=8">rc.subr(8)</a>
system. Though there are several things to take into account.
<ol>
	<li>The script has to be placed into <tt>${PKGDIR}</tt> with
	a <tt>.rc</tt> extension, like <tt>mpd.rc</tt>.
	This will allow the package tools to pick it up.
	<!-- and it to the PLIST. -->
	<li>Be sure to test all the functions of the script,
	especially the <i>reload</i> function.
	<li>Use <tt>${TRUEPREFIX}</tt> when writing the path to the daemon.
</ol>


<h3>Example script</h3>
<p>
Below is an example of a typical script.

<blockquote><pre>
#!/bin/sh
#
# &#36;OpenBSD: munin_node.rc,v 1.6 2013/01/08 11:14:02 kirby Exp $

daemon="${TRUEPREFIX}/sbin/munin-node"

. /etc/rc.d/rc.subr

pexp="/usr/bin/perl -wT $daemon"

rc_pre() {
	install -d -o _munin /var/run/munin
}

rc_cmd $1
</pre></blockquote>

A
<a href="http://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/ports/infrastructure/templates/rc.template">template
script</a> can also be found in the templates directory of your ports tree.


<p>

<font color= "#0000e0">
<a href="index.html">[Handbook Index]</a>
<a href="guide.html">[To Section 2 - OpenBSD Porting Guide]</a>
<a href="testing.html">[To Section 4 - Port Testing Guide]</a>
</font>
<p>

<hr>

<a href="../index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[back]"></a>
<br>
<small>$OpenBSD: specialtopics.html,v 1.49 2016/03/27 19:52:09 sthen Exp $</small>

</body>
</html>

