<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

<!-- If you make edits to any FAQ documents, please start each sentence
     on a new line, and try to keep the general formatting consistent
     with the rest of the pages -->

<title>OpenBSD FAQ: System Management</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "copyright"     content= "This document copyright 1998-2016
                                      by OpenBSD.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../openbsd.css">
<link rel="canonical" href="http://www.openbsd.org/faq/faq10.html">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<h2>
<a href="../index.html">
<font color="#0000ff"><i>Open</i></font><font color="#000084">BSD</font></a>
<font color="#e00000">FAQ - System Management</font>
<small>
<a href="index.html" style="font-weight:normal; float:right">[FAQ Index]</a>
</small>
</h2>
<hr>

<ul>
<li><a href="#wheel"            >When I try to su to root it says I'm in the
                                 wrong group</a>
<li><a href="#DupFS"            >Duplicating filesystems with dump and
                                 restore</a>
<li><a href="#rc"               >The rc system startup script</a>
<li><a href="#doas"             >OpenBSD's sudo replacement, doas</a>
<li><a href="#vipw"             >Changing a user's password</a>
<li><a href="#AddDelUser"       >Adding and deleting users</a>
<li><a href="#Quotas"           >Setting up user disk quotas</a>
<li><a href="#Dir"              >Directory services</a>
<ul>
  <li><a href="#Dir.available"  >Which directory services are available?</a>
  <li><a href="#YP_secure"      >YP security considerations</a>
  <li><a href="#YP_server"      >Setting up a YP server</a>
  <li><a href="#YP_client"      >Setting up a YP client</a>
</ul>
<li><a href="#locales"          >Character sets and localization</a>
<li><a href="#passwd"           >Converting your Linux password file to
                                 BSD-style</a>
<li><a href="#Patches"          >Keeping OpenBSD up to date</a>
</ul>

<hr>

<h2 id="wheel">When I try to su to root it says I'm in the wrong group</h2>

On OpenBSD, users who are in the <tt>wheel</tt> group are allowed to use
<a href="http://man.openbsd.org/su">su(1)</a>
to become root.
Otherwise, the user will receive an error.

<p>
If you are creating new users with
<a href="http://man.openbsd.org/adduser">adduser(8)</a>,
you can add them to the <tt>wheel</tt> group by answering <tt>wheel</tt> at the
<tt>Invite <i>user</i> into other groups:</tt> prompt.
Existing users must be added to the <tt>wheel</tt> group by hand.
Here is an example of a <tt>/etc/group</tt> entry which has had the user
<tt>ericj</tt> added to the <tt>wheel</tt> group:

<blockquote><pre>
wheel:*:0:root,ericj
</pre></blockquote>

If you want to give access to superuser privileges without adding users to the
<tt>wheel</tt> group, you can use <a href="#doas">doas(1)</a>.

<h2 id="DupFS">Duplicating filesystems with dump and restore</h2>

To duplicate your filesystem, use
<a href="http://man.openbsd.org/dump">dump(8)</a> and
<a href="http://man.openbsd.org/restore">restore(8)</a>.
For example, to duplicate everything under directory <tt>SRC</tt> to directory
<tt>DST</tt>, do:

<blockquote><pre>
# <b>cd /SRC && dump 0f - . | (cd /DST && restore -rf - )</b>
</pre></blockquote>

dump(8) is designed to give you plenty of backup capabilities, and it may be an
overkill if you just want to duplicate part of a (or an entire) filesystem.
The command <a href="http://man.openbsd.org/tar">tar(1)</a> may be faster for
this operation.
The format looks very similar:

<blockquote><pre>
# <b>cd /SRC && tar cf -  . | (cd /DST && tar xpf - )</b>
</pre></blockquote>

<h2 id="rc">The rc system startup script</h2>

OpenBSD itself uses an <a href="http://man.openbsd.org/rc">rc(8)</a> style
startup.
This uses a few key files for startup.

<ul>
  <li><tt>/etc/rc</tt>:
    Main script.
    Should not be edited.
  <li><tt>/etc/rc.conf</tt>:
    Configuration file used by <tt>/etc/rc</tt> to set startup parameters for
    the system.
    Should not be edited.
  <li><tt>/etc/rc.conf.local</tt>:
    Configuration file that overrides settings in <tt>/etc/rc.conf</tt> so you
    don't have to touch <tt>/etc/rc.conf</tt> itself, which is important when
    upgrading your system.
  <li><tt>/etc/netstart</tt>:
    Script used to initialize the network.
    Shouldn't be edited.
  <li><tt>/etc/rc.local</tt>:
    Script used for local administration.
    This is where new daemons or host specific information can be set.
  <li><tt>/etc/rc.securelevel</tt>:
    Script which runs commands that must be run before the security level
    changes.
    See <a href="http://man.openbsd.org/init">init(8)</a>
  <li><tt>/etc/rc.shutdown</tt>:
    Script run on shutdown.
    Put anything you want done before shutdown in this file.
    See <a href="http://man.openbsd.org/rc.shutdown">rc.shutdown(8)</a>
</ul>

<h3>How does rc(8) work?</h3>

The main files a system administrator should concentrate on are
<tt>/etc/rc.conf</tt> (for guidance), <tt>/etc/rc.conf.local</tt> (for changes),
<tt>/etc/rc.local</tt> and <tt>/etc/rc.shutdown</tt>.
To get a look of how the rc(8) procedure works, here is the flow:

<p>
After the kernel is booted, <tt>/etc/rc</tt> is started:
<ul>
  <li>Filesystems are checked
  <li>Default configuration variables are read in from
      <tt>/etc/rc.conf</tt>, then local changes to those variables are read from
      <tt>/etc/rc.conf.local</tt>.
      Settings in <tt>rc.conf.local</tt> will override those in
      <tt>rc.conf</tt>.
  <li>Filesystems are mounted
  <li><tt>/tmp</tt> is cleared out and any editor files are preserved
  <li>The network is configured via <tt>/etc/netstart</tt>
  <ul>
    <li>Network interfaces are put up
    <li>Your hostname, domain name, etc are set
  </ul>
  <li>System daemons are started
  <li>Various other checks (quotas, savecore, etc) are performed
  <li><tt>/etc/rc.firsttime</tt> runs, followed by <tt>/etc/rc.local</tt>
  <li>Local and package scripts in <tt>/etc/rc.d</tt> are processed and run
</ul>

<h3>Starting daemons and services that come with OpenBSD</h3>

Most daemons and services that come with OpenBSD are controlled on boot
by variables defined in
<a href="http://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/etc/rc.conf?content-type=text/plain">/etc/rc.conf</a>.
You'll see lines similar to this:

<blockquote><pre>
httpd_flags=NO
</pre></blockquote>

This shows that <a href="http://man.openbsd.org/httpd">httpd(8)</a> is not to
be started from <a href="http://man.openbsd.org/rc">rc(8)</a> at boot time.
Each line has a comment showing you the flags for common usage of that daemon
or service.
This doesn't mean that you must run that daemon or service with those flags.
Read the relevant man page to see how you can have that daemon or service start
up in any way you like.

<p>
We strongly suggest you do not alter <tt>/etc/rc.conf</tt> directly.
Instead, use the <a href="http://man.openbsd.org/rcctl">rcctl(8)</a> utility
to maintain the <tt>/etc/rc.conf.local</tt> file.
This makes future upgrades easier -- all the changes are in the one file that
isn't touched during upgrade.

<p>
For example, to start the <a href="http://man.openbsd.org/apmd">apmd(8)</a>
daemon for CPU scaling, you might do:

<blockquote><pre>
# <b>rcctl enable apmd</b>
# <b>rcctl set apmd flags -A</b>
# <b>rcctl start apmd</b>
</pre></blockquote>

<h3>Starting up local daemons and configuration</h3>

For other daemons which you might install on the system via packages or other
ways, you could use the <tt>/etc/rc.local</tt> file.
For example, say you installed a daemon located at
<tt>/usr/local/sbin/daemonx</tt>.
If you want it to start at boot time, put an entry into <tt>/etc/rc.local</tt>
like this:

<blockquote><pre>
if [ -x /usr/local/sbin/daemonx ]; then
	echo 'Starting daemonx' && /usr/local/sbin/daemonx
fi
</pre></blockquote>

If the daemon does not automatically detach on startup, remember to add "&amp;"
at the end of the command-line.

<p>
From now on, this daemon will be started at boot.
You will be able to see any errors on boot.
A normal boot with no errors would show a line like this:

<blockquote><pre>
Starting daemonx
</pre></blockquote>

<h3>The <tt>/etc/rc.d</tt> directory</h3>

OpenBSD's system daemons ("services") are started, stopped and
controlled by
<a href="http://man.openbsd.org/rc.d">rc.d(8)</a>.
All system daemons are handled by these scripts, and most add-on
<a href="faq15.html">packages</a> are as well.

<p>
These scripts, one per daemon, are invoked by <tt>rc</tt>.
The order for system daemons is coded into <tt>rc</tt>, and the order for
add-in packages is managed by the <tt>pkg_scripts</tt> environment variable,
which would be set in <tt>/etc/rc.conf.local</tt>.
Note that simply placing a script in this directory does not cause it to be run
on boot; the name of the script must be specified in the <tt>pkg_scripts</tt>
variable to start on boot.

<p>
The starting of system scripts is determined by entries in the
<tt>/etc/rc.conf.local</tt> file.
For example, <tt>/etc/rc.d/httpd</tt> does not start
<a href="http://man.openbsd.org/httpd">httpd(8)</a> unless <tt>/etc/rc.conf</tt>
or <tt>/etc/rc.conf.local</tt> contains a line defining the <tt>httpd_flags</tt>
variable.
To help make sure your system will come up as expected on the next boot, the
<tt>rc.d</tt> scripts will not run their daemon if the appropriate variable is
not defined.
You can, of course, manually invoke <tt>/usr/sbin/httpd</tt> directly with
whatever options you wish, if you wish to run the program manually.

<p>
Note that rather than having each script in rc.d managing the entire startup,
shutdown, reload, restart, and check operations, most rc.d scripts can be
reduced to specifying very few variables, and invoking the
<a href="http://man.openbsd.org/rc.subr">rc.subr(8)</a> script, which manages
most of the standard way of doing these tasks.

<p>
For example, our above <tt>daemonx</tt> application could be started with a
<tt>/etc/rc.d/daemonx</tt> file consisting of:

<blockquote><pre>
#!/bin/sh

daemon="/usr/local/sbin/daemonx"

. /etc/rc.d/rc.subr

rc_cmd $1
</pre></blockquote>

and adding the daemon name to the <tt>pkg_scripts</tt> variable in
<tt>/etc/rc.conf.local</tt>.

<h3>rc.shutdown</h3>

<tt>/etc/rc.shutdown</tt> is a script that is run at shutdown.
Anything you want done before the system shuts down should be added to this
file.

<h2 id="doas">OpenBSD's sudo replacement, doas</h2>

<h3>What is doas(1)?</h3>

<a href="http://man.openbsd.org/doas">doas(1)</a> allows a user to temporarily
run commands as another user.
For example, if appropriately configured,

<blockquote><pre>
$ <b>doas fdisk sd1</b>
</pre></blockquote>

allows you to run the command
<a href="http://man.openbsd.org/fdisk">fdisk(8)</a> as if you were root.
Key words there are "appropriately configured" of course.
You don't want average users to be able to get root privileges for any command
they wish to run!
Typically, though certainly not required, users in the "wheel" group are given
permission to run commands with doas.

<h3>Why doas(1)?</h3>

One common challenge system administrators face is the contradictory requirement
of multiple people managing machines using logins that shouldn't be shared.
<a href="http://man.openbsd.org/doas">doas(1)</a> solves this problem by
permitting a certain subset of your users (for example, members of the
<tt>wheel</tt> group) to run predetermined (often all) commands as another user
(often root).
Now, anyone can run administrative commands, only needing to authenticate as
themselves.
They do not need to use the root account or know the root password.

<p>
An added advantage of "doas" is all activity is logged.
It is possible to find out who ran an application.

<p>
Using a properly configured doas(1) on OpenBSD, one can completely disable the
root account, eliminating all root password management issues.

<p>
It is also considered good practice by many to use doas when absolutely
necessary to run a command as root, rather than sitting at a root
console prompt.
This way, an erroneously typed command is less likely to have catastrophic
results.
However, this is subject to some debate.
It is possible to cause as much chaos and havoc with a "finger-memory"
(or just incorrect command) invocation of doas as it is when logged in as root.
For this reason, we do not blindly side with those that chant "always
use doas, never use root!" or spend hours making things happen without root.
Notably, if you set doas to not require confirmation of your
password, any script or application running as you can invoke doas(1)
to make any changes to your system as root.
For this reason, for personal systems, it is probably better to either just use
<a href="http://man.openbsd.org/su">su(1)</a> to elevate oneself to root status,
or use doas(1) with the password option.

<h3>"Sounds like sudo!"</h3>

Yes, doas(1) was inspired by <a href="http://www.sudo.ws/">sudo</a>.
It is OpenBSD's replacement for the sudo command.

<p>
The complexity of sudo had prevented the importing of the most current versions,
and the complexity of the sudoers config file has discouraged many users from
doing anything other than uncomment one line in the conf file.
In short, sudo's code is too complicated for the way most users use it,
and its configuration is too difficult for more advanced uses.

<p>
doas(1) is intended to have a simpler, and thus hopefully more secure,
code base and configuration file.
From a user standpoint, the two are very similar.

<p>
For those needing the functionality of sudo, it's available as a
<a href="faq15.html">package</a>.

<h3>Using doas(1) -- basic doas.conf(5)</h3>

A very basic <a href="http://man.openbsd.org/doas.conf">doas.conf(5)</a> might
look like this:

<blockquote><pre>
permit keepenv { PKG_PATH ENV PS1 SSH_AUTH_SOCK } :wheel
</pre></blockquote>

This file gives users in the wheel group root-level access to all commands, with
the environment variables <tt>PKG_PATH</tt>, <tt>ENV</tt>, <tt>PS1</tt> and
<tt>SSH_AUTH_SOCK</tt> passed through to the program they are invoking.
The user will be asked to verify their password before the command is run.

<p>
A more sophisticated doas.conf(5) file which would permit you to build OpenBSD
from source using doas(1) without entering your password every time might be:

<blockquote><pre>
permit nopass keepenv { PKG_PATH ENV PS1 SSH_AUTH_SOCK } :wheel
permit nopass keepenv { \
    FTPMODE PKG_CACHE PKG_PATH SM_PATH SSH_AUTH_SOCK \
    DESTDIR DISTDIR FETCH_CMD FLAVOR GROUP MAKE MAKECONF \
    MULTI_PACKAGES NOMAN OKAY_FILES OWNER PKG_DBDIR \
    PKG_DESTDIR PKG_TMPDIR PORTSDIR RELEASEDIR SHARED_ONLY \
    SUBPACKAGE WRKOBJDIR SUDO_PORT_V1 } :wsrc
</pre></blockquote>

While the <tt>nopass</tt> option makes using doas(1) very easy, it can also be
invoked by any script or program, without the user's knowledge or permission.
For this reason, systems used as general purpose workstations should probably
not use the <tt>nopass</tt> option, if using doas(1) at all.
The alternative is using <a href="#wheel">su(1)</a> and the root password
to use the root account.

<p>
If you don't like the idea of any script or program you run being able to
silently invoke doas(1) to run something as root, but you find typing your
password over and over annoying, you may want to create a user for
administrative tasks, such as "admin," and have a configuration file like this:

<blockquote><pre>
permit :wheel as admin
permit nopass admin
</pre></blockquote>

Now, anyone who is in the wheel group can become "admin" with just one entry
of their password, and then admin can run the commands they wish without a
password until they drop back to their normal user.

<h2 id="vipw">Changing a user's password</h2>

If you edit <tt>/etc/passwd</tt> directly, your changes will be lost.
OpenBSD generates <tt>/etc/passwd</tt> dynamically with
<a href="http://man.openbsd.org/pwd_mkdb">pwd_mkdb(8)</a>.
The main password file in OpenBSD is <tt>/etc/master.passwd</tt>.
According to the man page,

<blockquote><pre>
FILES
     /etc/master.passwd  current password file
     /etc/passwd         a 6th Edition-style password file
     /etc/pwd.db         insecure password database file
     /etc/pwd.db.tmp     temporary file
     /etc/spwd.db        secure password database file
     /etc/spwd.db.tmp    temporary file
</pre></blockquote>

In a traditional Unix password file, such as <tt>/etc/passwd</tt>, everything
including the user's encrypted password is available to anyone on the system
and is a prime target for password cracking programs.
4.4BSD introduced the <tt>master.passwd</tt> file, which has an extended format.
It has additional options beyond those provided by <tt>/etc/passwd</tt>, and is
only readable by root.
For faster access to data, the library calls which access this data normally
read <tt>/etc/pwd.db</tt> and <tt>/etc/spwd.db</tt>.

<p>
OpenBSD does come with a tool with which you should edit your password
file.
It is called <a href="http://man.openbsd.org/vipw">vipw(8)</a>.
vipw will use vi (or your favorite editor defined per $EDITOR) to edit
<tt>/etc/master.passwd</tt>.
After you are done editing, it will re-create <tt>/etc/passwd</tt>,
<tt>/etc/pwd.db</tt> and <tt>/etc/spwd.db</tt> as per your changes.
vipw also takes care of locking these files, so that if anyone else
attempts to change them at the same time, they will be denied access.


<h2 id="AddDelUser">Adding and deleting users</h2>

OpenBSD provides two commands for easily adding users to the system:

<ul>
  <li><a href="#adduser">adduser(8)</a>
  <li><a href="#user">user(8)</a>
</ul>

You can also add users by hand, using
<a href="http://man.openbsd.org/vipw">vipw(8)</a>, but this is more difficult
for most operations.

<p id="adduser">
The easiest way to add a user in OpenBSD is to use the
<a href="http://man.openbsd.org/adduser">adduser(8)</a> script.
You can configure adduser(8) by editing <tt>/etc/adduser.conf</tt>.
adduser(8) allows for consistency checks on <tt>/etc/passwd</tt>,
<tt>/etc/group</tt> and shell databases.
It will create the entries and <tt>$HOME</tt> directories for you.
It can even send a message to the user welcoming them.
Here is an example user, <tt>testuser</tt>, being added to a system.
They will be given the <tt>$HOME</tt> directory <tt>/home/testuser</tt>, made
a member of the group <tt>guest</tt>, and given the shell <tt>/bin/ksh</tt>.

<blockquote><pre>
# <b>adduser</b>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. There will be a chance later to correct any input.
Enter username []: <b>testuser</b>
Enter full name []: <b>Test FAQ User</b>
Enter shell csh ksh nologin sh [ksh]: <b>ksh</b>
Uid [1002]:
Login group testuser [testuser]: <b>guest</b>
Login group is ``guest''. Invite testuser into other groups: guest no
[no]: <b>no</b>
Login class authpf daemon default staff [default]:
Enter password []:
Enter password again []:

Name:        testuser
Password:    ****
Fullname:    Test FAQ User
Uid:         1002
Gid:         31 (guest)
Groups:      guest
Login Class: default
HOME:        /home/testuser
Shell:       /bin/ksh
OK? (y/n) [y]: <b>y</b>
Added user ``testuser''
Copy files from /etc/skel to /home/testuser
Add another user? (y/n) [y]: <b>n</b>
Goodbye!
</pre></blockquote>

To delete users you should use the
<a href="http://man.openbsd.org/rmuser">rmuser(8)</a> utility.
This will remove all existence of a user.
It will remove any <a href="http://man.openbsd.org/crontab">crontab(1)</a>
entries, their $HOME dir (if it is owned by the user), and their mail.
Of course it will also remove their <tt>/etc/passwd</tt> and
<tt>/etc/group</tt> entries.
Next is an example of removing the user that was added above.
Notice you are prompted for the name, and whether or not to remove the user's
home directory.

<blockquote><pre>
# <b>rmuser</b>
Enter login name for user to remove: <b>testuser</b>
Matching password entry:

testuser:$2a$07$ZWnBOsbqMJ.ducQBfsTKUe3PL97Ve1AHWJ0A4uLamniLNXLeYrEie:1002
:31::0:0:Test FAQ User:/home/testuser:/bin/ksh

Is this the entry you wish to remove? <b>y</b>
Remove user's home directory (/home/testuser)? <b>y</b>
Updating password file, updating databases, done.
Updating group file: done.
Removing user's home directory (/home/testuser): done.
</pre></blockquote>

<h3 id="user">Adding users via user(8)</h3>

These tools are less interactive than the
<a href="http://man.openbsd.org/adduser">adduser(8)</a> command, which makes
them easier to use in scripts.

<p>
The full set of tools is:
<ul>
  <li><a href="http://man.openbsd.org/group">group(8)</a>
  <li><a href="http://man.openbsd.org/groupadd">groupadd(8)</a>
  <li><a href="http://man.openbsd.org/groupdel">groupdel(8)</a>
  <li><a href="http://man.openbsd.org/groupinfo">groupinfo(8)</a>
  <li><a href="http://man.openbsd.org/groupmod">groupmod(8)</a>
  <li><a href="http://man.openbsd.org/user">user(8)</a>
  <li><a href="http://man.openbsd.org/useradd">useradd(8)</a>
  <li><a href="http://man.openbsd.org/userdel">userdel(8)</a>
  <li><a href="http://man.openbsd.org/userinfo">userinfo(8)</a>
  <li><a href="http://man.openbsd.org/usermod">usermod(8)</a>
</ul>

<h4>Actually adding users</h4>

The command <tt>/usr/sbin/user</tt> is just a frontend to the rest of the
<tt>/usr/sbin/user*</tt> commands.
Therefore, the following commands can be added by using <tt>user add</tt>
or <tt>useradd</tt>.
Whichever form you chose doesn't change the results at all.
Remember, since user(8) is not interactive, the easiest way to add users
is with adduser(8).

<p>
useradd(8) is less daunting to use if you know the default settings beforehand.
These settings are located in
<a href="http://man.openbsd.org/usermgmt.conf">usermgmt.conf(5)</a>
and can be viewed by doing:

<blockquote><pre>
$ <b>user add -D</b>
group           users
base_dir        /home
skel_dir        /etc/skel
shell           /bin/csh
inactive        0
expire          Null (unset)
range           1000..60000
</pre></blockquote>

These defaults will be used unless you specify alternatives with the
command-line options.
For example, we want the user to be added to the group <tt>guest</tt>, not
<tt>users</tt>.
One more little hurdle with adding users is that passwords must be specified
on the command-line.
Importantly, the passwords must be encrypted, so you need to use the
<a href="http://man.openbsd.org/encrypt">encrypt(1)</a> utility.
For example:
OpenBSD's passwords use the Blowfish algorithm with 8 rounds by default.
Here is an example to create an encrypted password to give to useradd(8).

<blockquote><pre>
$ <b>encrypt -p -b 8</b>
Enter string:
$2b$08$pvin31BFNxR.qiPTAfizFeeCxrlmBhsZLsAajCwAB1rgFFvl8PRXq
</pre></blockquote>

Now that we have an encrypted password, we are ready to add the user.
We will add the same user with the same specifications as the user
we added <a href="#adduser">above</a>, via adduser(8).

<blockquote><pre>
# <b>user add -p '$2b$08$pvin31BFNxR.qiPTAfizFeeCxrlmBhsZLsAajCwAB1rgFFvl8PRXq' \</b>
> <b>-u 1002 -s /bin/ksh -c "Test FAQ User" -m -g guest testuser</b>
</pre></blockquote>

<b>Note:</b> Make sure to use '&nbsp;' (single quotes) around the password
string, not "&nbsp;" (double quotes) as the shell will interpret these before
sending it to user(8).
In addition to that, make sure you specify the <tt>-m</tt> option if you want
the user's home directory created and the files from <tt>/etc/skel</tt>
copied over.

<p>
To see that the user was created correctly, we can use many different utilities.
Below are a few commands you can use to quickly check that everything was
created correctly.

<blockquote><pre>
$ <b>ls -la /home</b>
total 14
drwxr-xr-x   5 root      wheel   512 May 12 14:29 .
drwxr-xr-x  15 root      wheel   512 Apr 25 20:52 ..
drwxr-xr-x  24 ericj     wheel  2560 May 12 13:38 ericj
drwxr-xr-x   2 testuser  guest   512 May 12 14:28 testuser
$ <b>id testuser</b>
uid=1002(testuser) gid=31(guest) groups=31(guest)
$ <b>finger testuser</b>
Login: testuser                         Name: Test FAQ User
Directory: /home/testuser               Shell: /bin/ksh
Last login Sat Apr 22 16:05 (EDT) on ttyC2
No Mail.
No Plan.
</pre></blockquote>

In addition to these commands, user(8) provides its own utility to show user
characteristics, called userinfo(8).

<blockquote><pre>
$ <b>userinfo testuser</b>
login   testuser
passwd  *
uid     1002
groups  guest
change  Wed Dec 31 19:00:00 1969
class
gecos   Test FAQ User
dir     /home/testuser
shell   /bin/ksh
expire  Wed Dec 31 19:00:00 1969
</pre></blockquote>

<h4>Removing users</h4>

To remove users with the user(8) hierarchy of commands, you will use userdel(8).
This is a very simple yet usable command.
To remove the user created in the last example, simply run:

<blockquote><pre>
# <b>userdel -r testuser</b>
</pre></blockquote>

Notice the <tt>-r</tt> option, which must be specified if you want the users
home directory to be deleted as well.
Alternatively, you can specify <tt>-p</tt> rather than <tt>-r</tt> and this will
lock the user's account, but not remove any information.

<h2 id="Quotas">Setting up user disk quotas</h2>

Quotas are used to limit user's space that they have available to them on your
disk drives.
It can be very helpful in situations where you have limited resources.
Quotas can be set by user and/or by group.

<p>
This option is in the GENERIC kernel.
After this, you need to mark in
<a href="http://man.openbsd.org/fstab">fstab(5)</a> the filesystems which will
have quotas enabled.
The keywords <tt>userquota</tt> and <tt>groupquota</tt> should be used to mark
each filesystem that you will be using quotas on.
By default, the files <tt>quota.user</tt> and <tt>quota.group</tt> will be
created at the root of that filesystem to hold the quota information.
This default can be overridden by specifying the file name with the quota
option in <tt>/etc/fstab</tt>, such as
<tt>userquota=/var/quotas/quota.user</tt>.
Here is an example <tt>/etc/fstab</tt> that has one filesystem with userquotas
enabled, and the quota file in a non-standard location:

<blockquote><pre>
/dev/wd0a / ffs rw,userquota=/var/quotas/quota.user 1 1
</pre></blockquote>

Now it's time to set the user's quotas.
To do so, use <a href="http://man.openbsd.org/edquota">edquota(8)</a>, which
will invoke vi(1) or <tt>$EDITOR</tt> to edit the quotas.
For example:

<blockquote><pre>
# <b>edquota ericj</b>
</pre></blockquote>

This will give you output similar to this:

<blockquote><pre>
Quotas for user ericj:
/: KBytes in use: 62, limits (soft = 0, hard = 0)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

To add limits, edit it to give results like this:

<blockquote><pre>
Quotas for user ericj:
/: KBytes in use: 62, limits (soft = 1000, hard = 1050)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

Note that the quota allocation is in 1k blocks.
In this case, the softlimit is set to 1000k, and the hardlimit is set to 1050k.
A softlimit is a limit where the user is just warned when they cross it and
have until their grace period is up to get their disk usage below their limit.
Grace periods can be set by using the <tt>-t</tt> option on edquota(8).
After the grace period is over, the softlimit is handled as a hardlimit.
This usually results in an allocation failure.

<p>
Now that the quotas are set, you need to turn the quotas on.
To do this, use <a href="http://man.openbsd.org/quotaon">quotaon(8)</a>.
For example:

<blockquote><pre>
# <b>quotaon -a</b>
</pre></blockquote>

This will go through <tt>/etc/fstab</tt> to turn on the filesystems with
quota options.
Now that quotas are up and running, you can view them using
<a href="http://man.openbsd.org/quota">quota(1)</a>.
Using a command of "<tt>quota &lt;user&gt;</tt>" will give that user's
information.
When called with no arguments, the quota(1) command will give your quota
statistics.
For example:

<blockquote><pre>
# <b>quota ericj</b>
</pre></blockquote>

Will result in output similar to this:

<blockquote><pre>
Disk quotas for user ericj (uid 1001):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
              /      62    1000    1050              27       0       0
</pre></blockquote>

By default, quotas set in <tt>/etc/fstab</tt> will be started on boot.
To turn them off, use

<blockquote><pre>
# <b>quotaoff -a</b>
</pre></blockquote>

<h2 id="Dir">Directory services</h2>

OpenBSD can be used for both servers and clients of databases containing
user credentials, group information and other network-related data.

<h3 id="Dir.available">Which directory services are available?</h3>

Of course, you could use various directory services on OpenBSD.
But YP is the only one that can be accessed directly using standard
C-library functions like
<a href="http://man.openbsd.org/getpwent">getpwent(3)</a>,
<a href="http://man.openbsd.org/getgrent">getgrent(3)</a>,
<a href="http://man.openbsd.org/gethostbyname">gethostbyname(3)</a>
and so on.
Thus, if you keep your data in a YP database, you do not need to copy it to
local configuration files like
<a href="http://man.openbsd.org/master.passwd">master.passwd(5)</a> before you
can use it, for example to authenticate system users.

<p>
YP is a directory service compatible with Sun Microsystems NIS
(Network Information System).
See <a href="http://man.openbsd.org/yp">yp(8)</a> for an overview of the
available manual pages.
Be careful, some operating systems contain directory services bearing similar
names but all the same being incompatible, for example NIS+.

<p>
To use other directory services except YP, you either need to populate local
configuration files from the directory, or you need a YP frontend to
the directory.
For example, you can use the <tt>sysutils/login_ldap</tt> port when you choose
the former, while the <a href="http://man.openbsd.org/ypldap">ypldap(8)</a>
daemon provides the latter.

<p>
For some applications, simply synchronizing a small number of configuration
files among a group of machines using tools like
<a href="http://man.openbsd.org/cron">cron(8)</a>,
<a href="http://man.openbsd.org/scp">scp(1)</a> or
<tt>rsync</tt> (available from ports) constitutes an easy and robust alternative
to a full-blown directory service.

<h3 id="YP_secure">YP security considerations</h3>

For compatibility reasons, all security features built into the OpenBSD
implementation of YP are switched <i>off</i> by default.
Even when they are all switched on, the NIS protocol is still inherently
insecure for two reasons:
All data, including sensitive data like password hashes, is transmitted
unencrypted across the network, and neither the client nor the server can
reliably verify each other's identity.

<p>
Thus, before setting up any YP server, you should consider whether these
inherent security flaws are acceptable in your context.
In particular, YP is inadequate if potential attackers have physical access
to your network.
Anybody gaining root access to any computer connected to your network segments
carrying YP traffic can bind your YP domain and retrieve its data.
In some cases, passing YP traffic through SSL or IPSec tunnels might be
an option.

<h3 id="YP_server">Setting up a YP server</h3>

<ol>
  <li>
    A YP server serves a group of clients called a "domain."
    You should first select a domain name; it can be an arbitrary string and
    need not be related in any way to DNS domain names.
    Choosing a random name like "Eepoo5vi" can marginally improve security,
    though the effect is mostly in security by obscurity.
    In case you need to maintain several distinct YP domains, it's probably
    better to choose descriptive names like "sales," "marketing" and "research"
    in order to forestall system administration errors caused by obscurity.
    Also note that some versions of SunOS require using the host's DNS domain
    name, so your choice might be restricted in a network including such hosts.

    <p>
    Use the <a href="http://man.openbsd.org/domainname">domainname(1)</a>
    utility to set the domain name, and put it into the
    <a href="http://man.openbsd.org/defaultdomain">defaultdomain(5)</a>
    file to have it automatically set at system startup time.

    <blockquote><pre>
    # <b>echo "puffynet" > /etc/defaultdomain</b>
    # <b>domainname `cat /etc/defaultdomain`</b>
    </pre></blockquote>

  <li>
    Initialise the YP server using the interactive command

    <blockquote><pre>
    # <b>ypinit -m</b>
    </pre></blockquote>

    At this point, it is not necessary to specify slave servers yet.
    To add slave servers, you can rerun
    <a href="http://man.openbsd.org/ypinit">ypinit(8)</a>
    later, using the <tt>-u</tt> option.

    Setting up at least one slave server for each domain is useful to avoid
    service interruptions.
    For example, should the master server ever go down or lose network
    connectivity, client processes trying to access YP maps block indefinitely
    until they receive the requested information.
    Thus, YP service interruptions typically render the client hosts completely
    unusable until YP is back to service.

  <li>
    Decide where to store the source files to generate your YP maps from.
    Keeping the server configuration separate from the served configuration
    helps to control which information will be served and which won't, so the
    default <tt>/etc</tt> often isn't the best choice.

    <p>
    The only inconvenience caused by changing the source directory is that you
    will not be able to add, remove and modify users and groups in the
    YP domain using utilities like
    <a href="http://man.openbsd.org/user">user(8)</a> and
    <a href="http://man.openbsd.org/group">group(8)</a>.
    Instead, you will have to edit the configuration files with a text editor.

    <p>
    To define the source directory, edit the file
    <tt>/var/yp/`domainname`/Makefile</tt>
    and change the <tt>DIR</tt> variable, e.g.

    <blockquote><pre>
    DIR=/etc/yp/src/puffynet
    </pre></blockquote>

  <li>
    Consider customizing other variables in
    <tt>/var/yp/`domainname`/Makefile</tt>.
    See <a href="http://man.openbsd.org/Makefile.yp">Makefile.yp(8)</a>
    for details.

    <p>
    For example, even in case you use the default source directory
    <tt>/etc</tt>, you do not usually need all accounts and groups existing
    on the server on all your client hosts.
    In particular, not serving the root account and thus keeping root's password
    hash confidential is often beneficial to security.
    Review the values of <tt>MINUID</tt>, <tt>MAXUID</tt>, <tt>MINGID</tt>
    and <tt>MAXGID</tt> and adjust them to you needs.

    <p>
    If all your YP clients run OpenBSD or FreeBSD, exclude the encrypted
    passwords from the <tt>passwd</tt> maps by setting <tt>UNSECURE=""</tt> in
    <tt>/var/yp/`domainname`/Makefile</tt>.

    <p>
    The former practice of editing the template file
    <tt>/var/yp/Makefile.yp</tt> is no longer recommended.
    Changes to that file affect all domains initialized after the change, but
    do not affect domains initialized before the change, so this is error-prone
    either way:
    You both risk that the intended changes do not take effect, and you risk to
    forget about them and have them affect other domains later which they were
    never intended for.

  <li>
    Create the source directory and populate it with the configuration files
    you need.
    See <a href="http://man.openbsd.org/Makefile.yp">Makefile.yp(8)</a>
    to learn which YP maps require which source files.
    For the format of the individual configuration files, refer to
    <a href="http://man.openbsd.org/passwd.5">passwd(5)</a>,
    <a href="http://man.openbsd.org/group.5">group(5)</a>,
    <a href="http://man.openbsd.org/hosts">hosts(5)</a>
    and so on, and look at the examples in <tt>/etc</tt>.

  <li>
    Create the initial version of your YP maps using the commands

    <blockquote><pre>
    # <b>cd /var/yp</b>
    # <b>make</b>
    </pre></blockquote>

    Do not worry about error messages from
    <a href="http://man.openbsd.org/yppush">yppush(8)</a> right now.
    The YP server is not yet running.

  <li>
    YP uses <a href="http://man.openbsd.org/rpc">rpc(3)</a>
    (remote procedure calls) to communicate with clients, so it is necessary
    to enable <a href="http://man.openbsd.org/portmap">portmap(8)</a>.
    To do so, use <a href="http://man.openbsd.org/rcctl">rcctl(8)</a>.

    <blockquote><pre>
    # <b>rcctl enable portmap</b>
    # <b>portmap</b>
    </pre></blockquote>

  <li>
    Consider using either the
    <a href="http://man.openbsd.org/securenet">securenet(5)</a> or the
    <a href="http://man.openbsd.org/ypserv.acl">ypserv.acl(5)</a>
    security feature of the YP server daemon.
    But be aware that both of these only provide IP based access control.
    Thus, they only help as long as potential attackers have neither physical
    access to the hardware of the network segments carrying your YP traffic
    nor root access to any host connected to those network segments.

  <li>
    Finally, start the YP server daemon:

    <blockquote><pre>
    # <b>ypserv</b>
    </pre></blockquote>

    It will automatically be restarted at boot time as long as the directory
    <tt>/var/yp/`domainname`</tt> continues to exist.

  <li>
    To test the new server, consider making it its own client,
    following the instructions in the first part of the next section.
    In case you don't want the server to use its own maps, you can
    disable the client part after the test with the following commands:

    <blockquote><pre>
    # <b>pkill ypbind</b>
    # <b>rm -rf /var/yp/binding</b>
    </pre></blockquote>

  <li>
    If you wish to allow users to change their passwords from client machines,
    then you must enable
    <a href="http://man.openbsd.org/yppasswdd">yppasswdd(8)</a>:

    <blockquote><pre>
    # <b>rcctl set yppasswdd flags -d /etc/yp/src/puffynet</b>
    # <b>rpc.yppasswdd</b>
    </pre></blockquote>

    If you left the source directory at the default <tt>/etc</tt>,
    just use <tt>rcctl enable yppasswdd</tt>.

  <li>
    Remember that each time you change a file sourced by a YP map,
    you must regenerate your YP maps.

    <blockquote><pre>
    # <b>cd /var/yp</b>
    # <b>make</b>
    </pre></blockquote>

    This updates all database files in <tt>/var/yp/`domainname`</tt>, with
    one exception:  The file <tt>ypservers.db</tt>, listing all YP master
    and slave servers associated with the domain, is created directly
    from <tt>ypinit -m</tt> and modified exclusively by <tt>ypinit -u</tt>.
    In case you accidentally delete it, run <tt>ypinit -u</tt> to recreate
    it from scratch.
</ol>

<h3 id="YP_client">Setting up a YP client</h3>

Setting up a YP client involves two distinct parts.
First, you must get the YP client daemon running,
binding your client host to a YP server.
Completing the following steps will allow you to retrieve data
from the YP server, but that data will not yet be used by the system:

<ol>
  <li>
    Like on the server, you must set the domain name and enable the portmapper:

    <blockquote><pre>
    # <b>echo "puffynet" > /etc/defaultdomain</b>
    # <b>domainname `cat /etc/defaultdomain`</b>
    # <b>rcctl enable portmap</b>
    # <b>portmap</b>
    </pre></blockquote>

  <li>
    It is recommended to provide a list of YP servers in the configuration
    file <tt>/etc/yp/`domainname`</tt>.
    Otherwise, the YP client daemon will use network broadcasts to find
    YP servers for its domain.
    Explicitly specifying the servers is both more robust and marginally
    less open to attack.
    If you have not set up any slave servers, just put the host name
    of the master server into <tt>/etc/yp/`domainname`</tt>.

  <li>
    The YP client daemon is called
    <a href="http://man.openbsd.org/ypbind">ypbind(8)</a>.
    Starting it manually will create the directory <tt>/var/yp/binding</tt>,
    such that it will be automatically restarted at boot time.

    <blockquote><pre>
    # <b>ypbind</b>
    </pre></blockquote>

  <li>
    If all went well you should be able to query the YP server using
    <a href="http://man.openbsd.org/ypcat">ypcat(1)</a>
    and see your passwd map returned.

    <blockquote><pre>
    # <b>ypcat passwd</b>
    bob:*:5001:5000:Bob Nuggets:/home/bob:/usr/local/bin/zsh
    ...
    </pre></blockquote>

    Other useful tools for debugging your YP setup include
    <a href="http://man.openbsd.org/ypmatch">ypmatch(1)</a> and
    <a href="http://man.openbsd.org/yptest">yptest(8)</a>.
</ol>

The second part of configuring a YP client involves editing local configuration
files such that certain YP maps get used by various system facilities.
Not all servers serve all standard maps supported by the operating system, some
servers serve additional non-standard maps, and you are by no means compelled to
use all those maps.
Which of the available maps shall or shall not be used, and for which purposes
they shall be used, is fully at the discretion of the client host's system
administrator.

<p>
For a list of standard YP maps and their standard usage, see
<a href="http://man.openbsd.org/Makefile.yp">Makefile.yp(8)</a>.
The most common use cases include:

<ul>
  <li>
    If you want to include all user accounts from the YP domain, append the
    default YP marker to the master password file and rebuild the password
    database:

    <blockquote><pre>
    # <b>echo '+:*::::::::' >> /etc/master.passwd</b>
    # <b>pwd_mkdb -p /etc/master.passwd</b>
    </pre></blockquote>

    For details on selective inclusion and exclusion of user accounts, see
    <a href="http://man.openbsd.org/passwd.5">passwd(5)</a>.
    To test whether inclusion actually works, use the
    <a href="http://man.openbsd.org/id">id(1)</a> utility.

  <li>
    If you want to include all groups from the YP domain, append the default YP
    marker to the group file:

    <blockquote><pre>
    # <b>echo '+:*::' >> /etc/group</b>
    </pre></blockquote>

    For details on selective group inclusion, see
    <a href="http://man.openbsd.org/group">group(5)</a>.
</ul>

<h2 id="locales">Character sets and localization</h2>

The OpenBSD base system fully supports the ASCII character set and encoding, and
partially supports the UTF-8 encoding of the Unicode character set.
No other encodings or character sets are supported by the base system, but ports
can be used to handle them.

<p>
The level of UTF-8 support and the default encoding configuration vary greatly
with the program or library.
For example, <a href="http://man.openbsd.org/xterm">xterm(1)</a> has full UTF-8
support enabled by default, while the
<a href="http://man.openbsd.org/re_format">regular expression library</a>
does not have any UTF-8 support yet.

<p>
To use the Unicode character set in UTF-8 encoding whereever supported, set the
<tt>LC_CTYPE</tt> environment variable to the value <tt>en_US.UTF-8</tt>:

<ul>
  <li>
    If logging in via <a href="http://man.openbsd.org/xdm">xdm(1)</a>, add
    <tt>export LC_CTYPE="en_US.UTF-8"</tt> to your <tt>~/.xsession</tt> before
    starting the window manager.
    See <a href="faq11.html#CustomizingX">customizing X</a> for more details.
  <li>
    If logging in via the text console, add
    <tt>export LC_CTYPE="en_US.UTF-8"</tt> to your <tt>~/.profile</tt>.
    The text console's UTF-8 support is a work in progress, and some non-ASCII
    characters may not display properly.
</ul>

When logging into remote systems with
<a href="http://man.openbsd.org/ssh">ssh(1)</a>, the <tt>LC_CTYPE</tt>
environment variable is not propagated, and you have to make sure that the local
terminal is set to the character encoding used by the remote server before
starting the ssh(1) client program.
If that encoding is unknown or unsupported by OpenBSD, make sure you use the
default <a href="http://man.openbsd.org/xterm">xterm(1)</a> configuration and
set <tt>LC_CTYPE=en_US.UTF-8</tt> in the remote shell after connecting.

<p>
The OpenBSD base system completely ignores all locale-related environment
variables except <tt>LC_CTYPE</tt>; even <tt>LC_ALL</tt> and <tt>LANG</tt> only
affect the character encoding.
Some ports may respect other <tt>LC_*</tt> variables, but using them or setting
<tt>LC_CTYPE</tt> to any value other than <tt>C</tt>, <tt>POSIX</tt> or
<tt>en_US.UTF-8</tt> is not recommended.

<h2 id="passwd">Converting your Linux password file to BSD-style</h2>

First, figure out if your Linux password file is shadowed or not.
If it is, install <a href="http://www.openwall.com/john/">John the Ripper</a>
from <a href="faq15.html">packages or ports</a> (<tt>security/john</tt>) and
use the "unshadow" utility that comes with it to merge your <tt>passwd</tt>
and <tt>shadow</tt> files into one Sixth Edition-style file.

<p>
Using your Linux password file, we'll call it <tt>linux_passwd</tt>, you
need to add in ::0:0 between fields four and seven.
<a href="http://man.openbsd.org/awk">awk(1)</a> does this for you.

<blockquote><pre>
# <b>awk -F : '{printf("%s:%s:%s:%s::0:0:%s:%s:%s\n", \</b>
> <b>$1,$2,$3,$4,$5,$6,$7); }' linux_passwd > new_passwd</b>
</pre></blockquote>

At this point, you want to edit the <tt>new_passwd</tt> file and remove
the root and other system entries that are already present in your
OpenBSD password file or aren't applicable with OpenBSD (all of them).
Also, make sure there are no duplicate usernames or user IDs between
<tt>new_passwd</tt> and your OpenBSD box's <tt>/etc/passwd</tt>.
The easiest way to do this is to start with a fresh <tt>/etc/passwd</tt>.

<blockquote><pre>
# <b>cat new_passwd >> /etc/master.passwd</b>
# <b>pwd_mkdb -p /etc/master.passwd</b>
</pre></blockquote>

The last step, <tt>pwd_mkdb</tt> is necessary to rebuild the
<tt>/etc/spwd.db</tt> and <tt>/etc/pwd.db</tt> files.
It also creates a Sixth Edition-style password file (minus encrypted passwords)
at <tt>/etc/passwd</tt> for programs which use it.
OpenBSD uses a stronger encryption for passwords, blowfish, which is very
unlikely to be found on any system which uses full Sixth Edition-style
password files.
To switch over to this stronger encryption, simply have the users run
<tt>passwd</tt> and change their password.
The new password they enter will be encrypted with your default setting
(usually blowfish unless you've edited <tt>/etc/login.conf</tt>).
Or, as root, you can run <tt>passwd <i>username</i></tt>.

<h2 id="Patches">Keeping OpenBSD up to date</h2>

When a critical bug is found, the fix will be committed to the -current tree
as soon as possible.
From that point on, things are handled differently depending on whether the
problem was in the OpenBSD base system or a third party package.
This section details how to keep your system up to date with all the latest
fixes.

<p>
For the OpenBSD base system, there are three options:

<ul>
  <li><b><a href="faq5.html#Snapshots">Upgrade your system to -current</a></b>
    <br>
    As all fixes are applied to the -current code base, updating your system
    to the latest snapshot is a good way to get all the fixes at once.
    However, running -current is not for everyone.
  <li><b><a href="../stable.html">Update your system to -stable</a></b>
    <br>
    This is done by fetching or updating your source tree using the appropriate
    -stable branch, then <a href="faq5.html">recompiling</a> the kernel and
    userland files.
    Overall, this is probably the easiest way, though it takes longer since
    the entire system gets rebuilt.
  <li><b><a href="#Errata">Patch the affected files individually</a></b>
    <br>
    While this typically requires less time than a CVS checkout/update and
    rebuild, there is no one universal set of instructions to follow.
    Sometimes you must patch and recompile one application, sometimes more.
    All patches posted to the <a href="../errata.html">errata web page</a> are
    made directly against the indicated release's source tree.
    This method is explained in more detail <a href="#Errata">below</a>.
</ul>

<p>
For third party software installed via <a href="faq15.html">packages</a>,
there are two options:

<ul>
  <li><b>Upgrade your system to -current and use binary packages</b>
    <br>
    Binary packages for -current snapshots are rebuilt on a regular basis,
    and these new packages will include any security fixes that were committed.
    Simply call <a href="http://man.openbsd.org/pkg_add">pkg_add(1)</a> with
    the <tt>-u</tt> flag after <a href="faq15.html#Easy">picking a mirror</a>
    to get the new files.
    Remember to use the <tt>/snapshots/</tt> directory!
  <li><b>Update via the -stable ports tree</b>
    <br>
    If you choose to stay on the -release or -stable branch, you will have to
    rebuild affected packages when security issues are found.
    Check out (or update to) the -stable ports branch with
    <a href="../anoncvs.html">CVS</a>, run the
    <tt>/usr/ports/infrastructure/bin/out-of-date</tt> script to list any
    packages that need rebuilding, and finally issue <tt>make update</tt>
    in the affected port directory.
    To be alerted of -stable port updates, consider following the
    "ports-changes" <a href="../mail.html">mailing list</a>.
</ul>

<h3 id="Errata">Applying errata patches</h3>

Patches for the OpenBSD base system are distributed as unified diffs, which
are text files that hold differences to the original source code.
This means that, to apply a patch, you must have the source code from the
-release version of your system available.

<p>
Whether you download and untar the source trees or fetch them from CVS,
it's best to <a href="faq5.html#wsrc">avoid using root</a> where possible.
Installing the new binaries will be the only step that requires it.

<p>
For our example here, we will look at patch 011 for OpenBSD 5.6, dealing with
<a href="http://man.openbsd.org/pppoe">pppoe(4)</a> connections.
Each patch is cryptographically signed with the
<a href="http://man.openbsd.org/signify">signify(1)</a> tool and contains
instructions on how to apply it properly.
We will assume you have put this patch into your current working directory.

<blockquote><pre>
$ <b>signify -Vep /etc/signify/openbsd-56-base.pub -x 011_pppoe.patch.sig \</b>
  <b>-m - | (cd /usr/src && patch -p0)</b>

Hmm...  Looks like a unified diff to me...
The text leading up to this was:
--------------------------
|
|OpenBSD 5.6 errata 11, Dec 5, 2014:
|
|An incorrect memcpy call would result in corrupted MAC addresses when
|using PPPOE.
|
|Apply patch using:
|
|    signify -Vep /etc/signify/openbsd-56-base.pub -x 011_pppoe.patch.sig \
|        -m - | (cd /usr/src && patch -p0)
|
|Then build and install a new kernel.
|
|Index: sys/net/if_ethersubr.c
|===================================================================
|RCS file: /cvs/src/sys/net/if_ethersubr.c,v
|retrieving revision 1.174
|diff -u -p -r1.174 if_ethersubr.c
|--- sys/net/if_ethersubr.c     12 Jul 2014 18:44:22 -0000      1.174
|+++ sys/net/if_ethersubr.c     1 Dec 2014 17:48:55 -0000
--------------------------
Patching file sys/net/if_ethersubr.c using Plan A...
Hunk #1 succeeded at 673.              <i>&lt;-- Look for this message!</i>
done
</pre></blockquote>

Note the "<tt>Hunk #1 succeeded</tt>" message above - this indicates the patch
was applied successfully.
Many patches are more complex than this and will involve multiple hunks and
multiple files, in which case you should verify that all hunks succeeded on
all the files.
Patches are very sensitive to "white space" - copying and pasting from your
browser will often change tab characters into spaces or otherwise alter the
white space of a file, making it not apply.

<p>
At this point, you would <a href="faq5.html#Bld">build and install</a> the
new kernel and reboot the system.

<p>
Not all patches are for the kernel.
In some cases, you will have to rebuild individual utilities.
At other times, will require recompiling all utilities statically linked to a
patched library.

<p>
</body>
</html>
