<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

<!-- If you make edits to any FAQ documents, please start each sentence
     on a new line, and try to keep the general formatting consistent
     with the rest of the pages -->

<title>15 - The OpenBSD packages and ports system</title>
<meta name= "description"   content= "OpenBSD FAQ 15 - The packages and ports
                                      system">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="canonical" href="http://www.openbsd.org/faq/faq15.html">
</head>

<!--
Copyright (c) 2005-2009 Steven Mestdagh <steven@openbsd.org>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif" border="
0">
</a>
<p>
<a href= "index.html">[FAQ Index]</a>
<a href= "faq14.html">[To Section 14 - Disk Setup]</a>

<h1><font color="#e00000">15 - The OpenBSD packages and ports system</font></h1>
<hr>

<h3>Table of Contents</h3>
<ul>
<li><a href="#Intro"          >15.1 - Introduction</a>
<li><a href="#PkgMgmt"        >15.2 - Package management</a>
  <ul>
  <li><a href="#PkgHow"       >15.2.1 - How does it work?</a>
  <li><a href="#Easy"         >15.2.2 - Making things easy</a>
  <li><a href="#PkgFind"      >15.2.3 - Finding packages</a>
  <li><a href="#PkgInstall"   >15.2.4 - Installing new packages</a>
  <li><a href="#PkgList"      >15.2.5 - Listing installed packages</a>
  <li><a href="#PkgUpdate"    >15.2.6 - Updating installed packages</a>
  <li><a href="#PkgRemove"    >15.2.7 - Removing installed packages</a>
  <li><a href="#PkgPartial"   >15.2.8 - Incomplete package installation or
                               removal</a>
  </ul>
<li><a href="#Ports"          >15.3 - Working with ports</a>
  <ul>
  <li><a href="#PortsHow"     >15.3.1 - How does it work?</a>
  <li><a href="#PortsFetch"   >15.3.2 - Fetching the ports tree</a>
  <li><a href="#PortsConfig"  >15.3.3 - Configuration of the ports system</a>
  <li><a href="#PortsSearch"  >15.3.4 - Searching the ports tree</a>
  <li><a href="#PortsInstall" >15.3.5 - Straightforward installation:
                               a simple example</a>
  <li><a href="#PortsClean"   >15.3.6 - Cleaning up after a build</a>
  <li><a href="#PortsDelete"  >15.3.7 - Uninstalling a port's package</a>
  <li><a href="#PortsFlavors" >15.3.8 - Using flavors and subpackages</a>
  <li><a href="#dpb"          >15.3.9 - Using dpb to build multiple ports</a>
  <li><a href="#PortsSecurity">15.3.10 - Security updates (<i>-stable</i>)</a>
  <li><a href="#PkgSig"       >15.3.11 - Package signatures</a>
  </ul>
<li><a href="#PkgFAQ"         >15.4 - FAQ</a>
  <ul>
  <li><a href="#NoFun"        >15.4.1 - I'm getting all kinds of crazy errors.
                               I just can't seem to get this ports stuff
                               working at all.</a>
  <li><a href="#Latest"       >15.4.2 - The latest version of my
                               Top-Favorite-Software is not available!</a>
  <li><a href="#NoPkg"        >15.4.3 - Why is there no package for my
                               Top-Favorite-Software?</a>
  <li><a href="#NoPort"       >15.4.4 - Why is there no port of my
                               Top-Favorite-Software?</a>
  <li><a href="#NotInBase"    >15.4.5 - Why is my Top-Favorite-Software not
                               part of the base system?</a>
  <li><a href="#PkgVsPorts"   >15.4.6 - What should I use, packages or
                               ports?</a>
  <li><a href="#Knobs"        >15.4.7 - How do I tweak these ports to have
                               maximum performance?</a>
  <li><a href="#Wait"         >15.4.8 - I submitted a new port/an update
                               weeks ago. Why isn't it committed?</a>
  </ul>
  <li><a href="#Problems"     >15.5 - Reporting problems</a>
  <li><a href="#Helping"      >15.6 - Helping us</a>
</ul>

<hr>

<h2 id="Intro">15.1 - Introduction</h2>

<p>
There are a lot of third party applications available which one might
want to use on an OpenBSD system.
To make this software easier to install and manage, plus to help it
comply with OpenBSD's policy and goals, it is <i>ported</i> to OpenBSD.
This porting effort can involve many different things.
Examples are: making the software use the standard OpenBSD directory
layout (e.g. configuration files go into <tt>/etc</tt>), conforming
to OpenBSD's shared library specifications, making the software more
secure whenever possible, etc.

<p>
The end result of the porting effort are ready-to-install binary
packages.
The aim of the package system is to keep track of which software gets
installed, so that it may at any time be updated or removed very easily.
This way, no unnecessary files are left behind, and users can keep their
systems clean.
The package system also helps ensure nothing is deleted by accident,
causing software to stop functioning properly.
Another advantage is that <b>users rarely need to compile software from
source</b>, as packages have already been compiled and are available and
ready to be used on an OpenBSD system.
In minutes, a large number of packages can be fetched and installed,
with everything in the right place.

<p>
The packages and ports collection does <b>NOT</b> go through the same thorough
security audit that is performed on the OpenBSD base system.
Although we strive to keep the quality of the packages collection high,
we just do not have enough human resources to ensure the same level of
robustness and security.

Of course <a href="#PortsSecurity">security updates</a> for various
applications are committed to the ports tree as soon as possible, and
corresponding package security updates are made available as snapshots
for <i>-current</i>.

<h2 id="PkgMgmt">15.2 - Package Management</h2>

<h3 id="PkgHow">15.2.1 - How does it work?</h3>

Packages are the pre-compiled binaries of some of the most used
third party software.
Packages can be managed easily with the help of several utilities,
also referred to as the pkg* tools:
<ul>
  <li><a href="http://man.openbsd.org?query=pkg_add">pkg_add(1)</a>
  - a utility for installing and upgrading software packages
  <li><a href="http://man.openbsd.org?query=pkg_delete">pkg_delete(1)</a>
  - a utility for deleting previously installed software packages
  <li><a href="http://man.openbsd.org?query=pkg_info">pkg_info(1)</a>
  - a utility for displaying information about software packages
  <li><a href="http://man.openbsd.org?query=pkg_create">pkg_create(1)</a>
  - a utility for creating software packages
</ul>

<p>
In order to run properly, application X may require that other applications
Y and Z be installed.
Application X is said to be dependent on these other applications,
which is why Y and Z are called <i>dependencies</i> of X.
In turn, Y may require other applications P and Q, and Z may require
application R to function properly.
This way, a whole <i>dependency tree</i> is formed.

<p>
Packages look like simple <tt>.tgz</tt> bundles.
Basically they are just that, but there is one crucial difference:
they contain some extra <i>packing information</i>.
This information is used by
<a href="http://man.openbsd.org?query=pkg_add">pkg_add(1)</a>
for several purposes:

<ul>
<li>Different checks: has the package already been installed, or does it
conflict with other installed packages or file names?
<li>Dependencies which are not yet present on the system are
automatically fetched and installed before proceeding with the
installation of the package.
<li>Information about the package(s) is recorded in a central
repository, by default located in <tt>/var/db/pkg/</tt>.
This will, among other things, prevent the dependencies of a package
from being deleted before the package itself has been deleted.
This helps ensure that an application cannot be accidentally broken
by a careless user.
</ul>

<h3 id="Easy">15.2.2 - Making things easy: PKG_PATH</h3>

You can make things really easy by using the <tt>PKG_PATH</tt> environment
variable.
Just point it to your favorite location and pkg_add(1) will automatically
look there for any package you specify.
It will even fetch and install the necessary dependencies of this package
automatically.

<p>
A list of possible locations to fetch packages from is given in the
<a href="#PkgFind">following section</a>.

<p>
Example 1: fetching from your <a href="../orders.html">CD-ROM</a>,
assuming you mounted it on <tt>/mnt/cdrom</tt>

<blockquote><pre>
# <b>export PKG_PATH=/mnt/cdrom/$(uname -r)/packages/$(machine -a)/</b>
</pre></blockquote>

Example 2: fetching from a nearby <a href="../ftp.html">mirror</a>

<blockquote><pre>
# <b>export PKG_PATH=http://your.local.mirror/pub/OpenBSD/$(uname -r)/packages/$(machine -a)/</b>
</pre></blockquote>

It's usually a good idea to add a line similar to the above examples to
your <tt>~/.profile</tt>.
As with the classic <tt>PATH</tt> variable, you can specify multiple
locations, separated by colons.
That way, pkg_add(1) can split the path correctly even if it holds URL
schemes containing colons.
If the first entry in <tt>PKG_PATH</tt> fails, the next one will be
tried, and so on, until the package is found.
If all entries fail, an error is produced.

<p>
Notice the use of
<a href="http://man.openbsd.org?query=machine">machine(1)</a>
in the above command lines.
This automatically substitutes your installed OpenBSD application
architecture, which is usually, but not always, your platform name.
Of course, if you are using snapshots, you will replace "$(uname -r)" with
"snapshots" instead.

<h3 id="PkgFind">15.2.3 - Finding packages</h3>

A large collection of pre-compiled packages is available for the most common
architectures.
Just look for your package in one of these places:

<ul>
<li>On one of the three <a href="../orders.html">CD-ROMs</a>, depending on
your architecture.
The CD-ROMs carry only the most commonly used, freely distributable packages
for the most commonly used platforms.
<li>On the <a href="../ftp.html">mirror servers</a>.
Packages are located in the <tt>/pub/OpenBSD/(version)/packages</tt> directory.
From there, packages are broken down depending on architecture.
<!-- Note that OpenBSD also includes a list of package mirrors in the
<tt>/etc/examples/pkg.conf</tt> file. XXXrelease -->
</ul>

<p>
If you have the ports tree on your system, you can quickly find the package
you are looking for by <a href="#PortsSearch">searching the ports tree</a>.

<p>
If you're looking for a specific filename, install the <tt>pkglocatedb</tt>
package, then use the <tt>pkg_locate</tt> command to find which package(s)
contain that file.

<p>
You will notice that certain packages are available in a few different
varieties, formally called <b>flavors</b>.
Others are pieces of the same application which may be installed separately.
These are called <b>subpackages</b>.
This will be detailed further in <a href="#PortsFlavors">using flavors and
subpackages</a>, but flavor basically means they are configured with
different sets of options.
Many packages have flavors.
For example: database support, support for systems without X or network
additions like SSL and IPv6.
Every flavor of a package will have a different suffix in its package name.
For detailed information about package names, please refer to
<a href="http://man.openbsd.org?query=packages-specs">packages-specs(7)</a>.

<p>
<b>Note:</b>
Not all possible packages are necessarily available on the mirror servers!
Some applications simply don't work on all architectures.
Some applications cannot be distributed via mirrors (or CD-ROM) for licensing
reasons.
There may also be many possible combinations of flavors of a port, and the
OpenBSD project just does not have the resources to build them all.
If you need a combination which is not available, you will have to build
the port from source.
For more information on how to do that, read
<a href="#PortsFlavors">using flavors and subpackages</a> in the ports
section of this document.

<h3 id="PkgInstall">15.2.4 - Installing new packages</h3>

The
<a href="http://man.openbsd.org?query=pkg_add">pkg_add(1)</a>
utility is used to install packages.
If you have <a href="#Easy">made things easy</a> for yourself by setting
the <tt>PKG_PATH</tt> environment variable, you can just call pkg_add(1)
with the package name, as is shown in the following basic example.

<blockquote><pre>
# <b>pkg_add -v screen-4.0.3p3</b>
parsing screen-4.0.3p3
installed /etc/screenrc from /usr/local/share/examples/screen/screenrc | 71%
screen-4.0.3p3: complete
</pre></blockquote>

In this example, the <tt>-v</tt> flag was used to give a more verbose output.
This option is not needed, but it is helpful for debugging and was used here
to give a little more insight into what pkg_add(1) is actually doing.
Notice the message mentioning <tt>/etc/screenrc</tt>.
Specifying multiple <tt>-v</tt> flags will produce even more verbose output.

<p>
pkg_add(1) will ask you questions when it cannot decide which version of
a package you might want to install.
For example, if you don't know the version number of a package beforehand,
you can try something like:

<blockquote><pre>
# <b>pkg_add screen</b>
Ambiguous: screen could be screen-4.0.3p3 screen-4.0.3p3-shm
Choose one package
         0: &lt;None&gt;
         1: screen-4.0.3p3
         2: screen-4.0.3p3-shm
Your choice: <b>1</b>
screen-4.0.3p3: complete
</pre></blockquote>

For some packages, some important additional information will be given
about the configuration or use of the application on an OpenBSD system.
Since it is important, it will be displayed whether or not you use the
<tt>-v</tt> flag.
Consider the following example:

<blockquote><pre>
# <b>pkg_add ghostscript-fonts-8.11</b>
ghostscript-fonts-8.11: complete
You may wish to update your font path for /usr/local/share/ghostscript/fonts
--- ghostscript-fonts-8.11 -------------------
To install these fonts for X11, just make sure that the fontpath
lists the 75dpi or 100dpi bitmap fonts before the ghostscript fonts,
and make sure you have the string ":unscaled" appended to the bitmap
font's fontpath. This way, the bitmap fonts will be used if they
match, and the Type 1 versions will be used if the font needs to be
scaled. Below is the relevant section from a typical xorg.conf file.

   FontPath   "/usr/X11R6/lib/X11/fonts/misc/"
   FontPath   "/usr/X11R6/lib/X11/fonts/75dpi/:unscaled"
   FontPath   "/usr/X11R6/lib/X11/fonts/100dpi/:unscaled"
   FontPath   "/usr/local/lib/X11/fonts/ghostscript/"
   FontPath   "/usr/X11R6/lib/X11/fonts/Type1/"
</pre></blockquote>

Additionally, some packages provide configuration and other information
in a file located in <tt>/usr/local/share/doc/pkg-readmes</tt>.

<p>
Let us now continue with an example of a package which has dependencies:

<blockquote><pre>
# <b>pkg_add -v tin-1.8.2p0</b>
parsing tin-1.8.2p0
Dependencies for tin-1.6.2 resolve to: gettext-0.14.6, libutf8-0.8, pcre-6.4p1,
libiconv-1.9.2p3 (todo: libiconv-1.9.2p3,gettext-0.14.6,pcre-6.4p1,libutf8-0.8)
tin-1.8.2p0:parsing libiconv-1.9.2p3
tin-1.8.2p0:libiconv-1.9.2p3: complete
tin-1.8.2p0:parsing gettext-0.14.6
Dependencies for gettext-0.14.6 resolve to: expat-2.0.0, libiconv-1.9.2p3 (todo:
expat-2.0.0)
tin-1.8.2p0:parsing expat-2.0.0
tin-1.8.2p0:expat-2.0.0: complete
tin-1.8.2p0:gettext-0.14.6: complete
tin-1.8.2p0:parsing pcre-6.4p1
tin-1.8.2p0:pcre-6.4p1: complete
tin-1.8.2p0:parsing libutf8-0.8
tin-1.8.2p0:libutf8-0.8: complete
tin-1.8.2p0: complete
</pre></blockquote>

Again, we added the <tt>-v</tt> flag to see more of what is happening.
Upon investigating the packing information, dependencies are found and
get installed first.
Somewhere in the middle you can see the gettext package being installed,
which depends on libiconv.
Before installing gettext, its packing information is examined and it
is verified whether libiconv has already been installed.

<p>
It is possible to specify multiple package names on one line, which
then all get installed at once, along with possible dependencies.

<p>
If, for some reason, you decide not to use <tt>PKG_PATH</tt>, it is also
possible to specify the absolute location of a package on the command line.
This absolute location may be a path to a local file or a remote URL.
Supported prefixes are http, https, ftp and scp.
Let's consider installation via HTTP in the next example:

<blockquote><pre>
# <b>pkg_add http://your.local.mirror/pub/OpenBSD/$(uname -r)/packages/$(machine -a)/screen-4.0.3p3.tgz</b>
screen-4.0.3p3: complete
</pre></blockquote>

In this example, the <tt>-v</tt> flag wasn't used, so only needed messages
are shown.
Notice the complete filename was entered by adding a <tt>.tgz</tt> suffix.
You can also skip this suffix, as in the previous examples, since it is
auto-completed by pkg_add(1).

<p>
<b>Note:</b>
Not all architectures have the same packages available.
Some ports do not work on certain architectures, and performance limits
the number of packages that can be built on others.

<p>
For your safety, if you are installing a package which you had installed
earlier and removed, pkg_add(1) will <b>not</b> overwrite configuration
files which have been modified.
The same is true for when you upgrade a package.
Instead, it will inform you about this as follows (only when using the
<tt>-v</tt> flag, however):

<blockquote><pre>
# <b>pkg_add -v screen-4.0.3p3</b>
parsing screen-4.0.3p3
The existing file /etc/screenrc has NOT been changed
It does NOT match the sample file /usr/local/share/examples/screen/screenrc
You may wish to update it manually
screen-4.0.3p3: complete
</pre></blockquote>

Sometimes you may encounter an error like the one in the following
example:

<blockquote><pre>
# <b>pkg_add xv-3.10ap4</b>
xv-3.10ap4:jpeg-6bp3: complete
xv-3.10ap4:png-1.2.14p0: complete
xv-3.10ap4:tiff-3.8.2p0: complete
Can't install xv-3.10ap4: lib not found X11.9.0
Even by looking in the dependency tree:
        tiff-3.8.2p0, jpeg-6bp3, png-1.2.14p0
Maybe it's in a dependent package, but not tagged with @lib ?
(check with pkg_info -K -L)
</pre></blockquote>

There is pkg_add, nicely installing dependencies, when all of a sudden
it aborts the installation of xv.
This is another safety precaution.
The packing information bundled in the package includes information
about shared libraries that the package expects to be installed,
both system libraries as well as third party libraries.
If one of the required libraries can't be found, the package is not
installed because it would not function anyway.
To solve this type of conflict, you must find out what to install
in order to get the required libraries on your system.

<p>
There are several things to check:
<ul>
<li>You may have older packages installed: an older version of the
required library is present.
In this case, upgrade these packages.
<li>Your system may be incomplete: you did not install one of the
file sets that contains the required library.
Just <a href="faq4.html#AddFileSet">add the required file set</a>.
<li>Your system may be out of date: you have an older version of the
required library.
Boot the installer (as detailed in <a href="faq4.html">FAQ 4</a>),
and choose to (U)pgrade your complete system.
</ul>

<h3 id="PkgList">15.2.5 - Listing installed packages</h3>

You can see a list of installed packages by using the
<a href="http://man.openbsd.org?query=pkg_info">pkg_info(1)</a>
utility.

<blockquote><pre>
$ <b>pkg_info</b>
aterm-0.4.2p1       color vt102 terminal emulator with transparency support
bzip2-1.0.4         block-sorting file compressor, unencumbered
expat-2.0.0         XML 1.0 parser written in C
fluxbox-0.9.15.1p0  window manager based on the original Blackbox code
gettext-0.14.6      GNU gettext
imlib2-1.3.0        image manipulation library
jpeg-6bp3           IJG's JPEG compression utilities
libiconv-1.9.2p3    character set conversion library
libltdl-1.5.22p1    GNU libtool system independent dlopen wrapper
libungif-4.1.4p0    tools and library routines for working with GIF images
libutf8-0.8         provides UTF-8 locale support
mutt-1.4.2.2i       tty-based e-mail client
pcre-6.4p1          perl-compatible regular expression library
png-1.2.14p0        library for manipulating PNG images
screen-4.0.3p3      multi-screen window manager
tcsh-6.14.00p1      extended C-shell with many useful features
tiff-3.8.2p0        tools and library routines for working with TIFF images
tin-1.8.2p0         threaded NNTP and spool based UseNet newsreader
</pre></blockquote>

When given an installed package name (or a location of a package which is to
be installed), pkg_info(1) will show more detailed information about that
specific package.

<h3 id="PkgUpdate">15.2.6 - Updating installed packages</h3>

Let's say you had an older version of unzip installed before upgrading this
box to the latest OpenBSD release.
You can easily upgrade the package to the newer version like this:

<blockquote><pre>
# <b>pkg_add -u unzip</b>
unzip-5.52p0 (extracting): complete
unzip-5.52 (deleting): complete
unzip-5.52p0 (installing): complete
Clean shared items: complete
</pre></blockquote>

When a package has dependencies, they are also examined for updates.
Invoking pkg_add(1) with the <tt>-u</tt> flag and no package name will
try to update all installed packages.

<p>
<b>Note:</b>
The <tt>-u</tt> switch relies on either the <tt>PKG_PATH</tt> environment
variable to be set or <tt>/etc/pkg.conf</tt> to be populated with a mirror.
If neither of those conditions are met, pkg_add(1) will not be able to find
updates.

<p>
Having several entries in <tt>PKG_PATH</tt> does not mean all entries will
be tried for update operations.
Instead, pkg_add(1) will stop at the first path with matching candidates.

<p>
If you had a configuration file belonging to the old version that you
modified, it will be left untouched by default.
You can, however, replace it with the default configuration file of
the new version, by calling pkg_add(1) with the <tt>-c</tt> flag.

<h3 id="PkgRemove">15.2.7 - Removing installed packages</h3>

To delete a package, simply take the proper name of the package as shown
by pkg_info(1) (see <a href="#PkgList">listing installed packages</a>
above) and use
<a href="http://man.openbsd.org?query=pkg_delete">pkg_delete(1)</a>
to remove the package.
In the example below, the screen package is being removed.
Notice that there are sometimes instructions about extra items which need
to be removed manually.
As with the pkg_add(1) utility, you can use the <tt>-v</tt> flag to get
more verbose output.

<blockquote><pre>
# <b>pkg_delete screen</b>
screen-4.0.3p3: complete
Clean shared items: complete
</pre></blockquote>

<b>Note:</b>
Often, it is not necessary to specify the version numbers and flavors with
the package name, since pkg_delete(1) will usually be able to find the full
name by itself.
You need to specify the complete package name (in the example, that is
<tt>screen-4.0.3p3</tt>) only if ambiguity is possible due to multiple
installed packages with the specified name. In that case, pkg_delete(1)
cannot know which package to delete.

<p>
For safety, pkg_delete(1) will not remove configuration files if they
have been modified.
Instead it will inform you about this.

<blockquote><pre>
# <b>pkg_delete screen</b>
screen-4.0.3p3: complete
Clean shared items: complete
--- screen-4.0.3p3 -------------------
You should also remove /etc/screenrc (which was modified)
</pre></blockquote>

If you prefer to have those configuration files removed automatically,
you can do so by using the <tt>-c</tt> flag.

<h3 id="PkgPartial">15.2.8 - Incomplete package installation or removal</h3>

In some odd cases, you may find that a package was not added or deleted
completely, due to conflicts with other files.
The incomplete installation is usually marked with "partial-" prepended
to the package name.
This can, for instance, happen when you coincidentally press CTRL+C
during installation:

<blockquote><pre>
# <b>pkg_add screen-4.0.3p3</b>
screen-4.0.3p3: complete
Adjusting md5 for /usr/local/info/screen.info-3 from 49fb3fe1cc3a3b0057518459811b6dac to 3b9c7811244fb9f8d83bb27d3a0f60d8
/usr/sbin/pkg_add: Installation of screen-4.0.3p3 failed, partial installation recorded as partial-screen-4.0.3p3
</pre></blockquote>

It is always a good idea to remove partial packages from your system, and to
fix potential problems that lead to this failure.
It is often an indication that you do not have a clean system with everything
installed from packages, but possibly packages mixed up with other software
installed straight from source.

<h2 id="Ports">15.3 - Working with ports</h2>

As mentioned in the introduction, packages are compiled from the ports tree.
In this section we will explain how the ports tree works, as well as when
you should or shouldn't use it.

<p>
<b>IMPORTANT NOTE</b>:
The ports tree is meant for advanced users.
<b>Everyone is encouraged to use the pre-compiled <a href="#PkgMgmt">
binary packages</a></b>.
Do NOT ask beginner questions on the mailing lists like "How can I get the
ports tree working?"
If you have questions about the ports tree, it is assumed that you have
read the manual pages and this FAQ, and that you are able to work with it.

<h3 id="PortsHow">15.3.1 - How does it work?</h3>

The ports tree is a set of Makefiles, one for each third party application,
that controls:

<ul>
<li>Where and how to fetch the source of the software
<li>Which other software it depends upon
<li>How to alter the sources (if necessary)
<li>How to configure and build it
<li>How to test it (optional)
<li>How to install it
</ul>

<p>
Apart from the Makefile, each port also contains at least the following:

<ul>
<li><tt>PLIST</tt> - instructions for package creation once the application
    has been built
<li><tt>DESCR</tt> - description of the application
<li><tt>distinfo</tt> - distribution file checksums and size
</ul>

<p>
All this information is kept in a directory hierarchy under <tt>/usr/ports</tt>.
This hierarchy contains three special subdirectories:

<ul>
<li><tt>distfiles/</tt>
 - where the ports system stores software distribution sets after downloading
<li><tt>infrastructure/</tt>
 - the main directory of the ports infrastructure, containing all necessary
   scripts and makefiles
<li><tt>packages/</tt>
 - contains all binary packages built by the ports system
</ul>

The other subdirectories all form different application categories,
which contain the subdirectories of the actual ports.
Complex ports may be organized to an even deeper level, for example if
they have a core part and a set of extensions, or a stable and a snapshot
version of the application.
Every port directory must contain a <tt>pkg/</tt> subdirectory with
packing list(s) and description file(s).
There may also be <tt>patches/</tt> and <tt>files/</tt> subdirectories,
for source patches and additional files, respectively.

<p>
When a user issues
<a href="http://man.openbsd.org?query=make">make(1)</a>
in the subdirectory of a specific port, the system will recursively
walk its dependency tree, check whether the required dependencies are
installed, build and install any missing dependencies, and then
continue the build of the desired port.
All of the building happens inside the <i>working directory</i> that
the port creates.
Normally this is under <tt>${WRKOBJDIR}</tt>, defaulting to
<tt>/usr/ports/pobj</tt>, but you may override this (see
<a href="#PortsConfig">configuration of the ports system</a>).
If <tt>WRKOBJDIR</tt> has been explicitly unset, a subdirectory
of the port's main directory (package name prefixed by "w-") will be
used instead.

<p>
<b>Note:</b>
Ports are never directly installed on your system.
They use a <i>fake installation directory</i>.
Everything that gets installed there is bundled together into a package
that gets stored in the <tt>packages/</tt> subdirectory of the ports tree,
as mentioned earlier.
Installing a port really means "creating a package and then installing
that package."

<p>
More information about the ports system may be found in these man pages:

<ul>
  <li><a href="http://man.openbsd.org?query=ports">ports(7)</a>
  - describes the different stages (make targets) of port installation,
  the use of flavors and subpackages and some other options.
  <li><a href="http://man.openbsd.org?query=bsd.port.mk">bsd.port.mk(5)</a>
  - in-depth information about all the make targets, variables, the fake
  (installation directory) framework, etc.
</ul>

<h3 id="PortsFetch">15.3.2 - Fetching the ports tree</h3>

Before continuing, you must read the section about NOT <a href="#NoFun">
mixing up your OpenBSD system and ports tree</a>.
Once you have decided which flavor of the ports tree you want, you can
get it from different sources.
The table below gives an overview of where you can find the different
flavors, and in which form.
An 'x' marks availability and '-' means it is not available through
that specific source.

<p>
<table border="1" align="center" style="empty-cells: show;">
<tr align="center">
<td align="left">Source</td>
<td>Form</td>
<td colspan="4">Flavor</td>
</tr>
<tr align="center">
<td colspan="2"></td>
<td>-release</td>
<td>-stable</td>
<td>snapshots</td>
<td>-current</td>
</tr>
<tr align="center">
<td align="left"><a href="../orders.html">CD-ROM</a></td>
<td>.tar.gz</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr align="center">
<td align="left"><a href="../ftp.html">HTTP mirrors</a></td>
<td>.tar.gz</td>
<td>x</td>
<td>-</td>
<td>x</td>
<td>-</td>
</tr>
<tr align="center">
<td align="left"><a href="../anoncvs.html">AnonCVS</a></td>
<td>cvs checkout</td>
<td>x</td>
<td>x</td>
<td>-</td>
<td>x</td>
</tr>
</table>

<p>
On the CD-ROM and HTTP mirrors, look for a file named <tt>ports.tar.gz</tt>.

<blockquote><pre>
$ <b>cd /tmp</b>
$ <b>ftp http://ftp.openbsd.org/pub/OpenBSD/$(uname -r)/ports.tar.gz</b>
$ <b>ftp http://ftp.openbsd.org/pub/OpenBSD/$(uname -r)/SHA256.sig</b>
$ <b>signify -Cp /etc/signify/openbsd-$(uname -r | cut -c 1,3)-base.pub -x SHA256.sig ports.tar.gz</b>
</pre></blockquote>

You want to untar this file in the <tt>/usr</tt> directory, which will
create <tt>/usr/ports</tt> and all the directories under it.
For example:

<blockquote><pre>
# <b>cd /usr</b>
# <b>tar xzf /tmp/ports.tar.gz</b>
</pre></blockquote>

If you'd like to be able to write to <tt>/usr/ports</tt> as a regular user,
see <a href="#PortsConfig">the next section</a>.

<p>
The snapshots available on the mirrors are generated daily from the -current
ports tree.
You will find the snapshots in the <tt>pub/OpenBSD/snapshots/</tt> directory.
If you are using a snapshot of the ports tree, you should have installed
a matching snapshot of OpenBSD.
Make sure you keep your ports tree and your OpenBSD system in sync!

<p>
For more information about obtaining the ports tree via CVS, read the
<a href="../anoncvs.html">AnonCVS page</a>, which contains a list of
available servers and a number of examples.

<h3 id="PortsConfig">15.3.3 - Configuration of the ports system</h3>

<b>NOTE:</b>
This section introduces some additional global settings for building
applications from ports.
You can skip this section, but then you will be required to perform many
of the make(1) statements in later examples as root.

<p>
Because the OpenBSD project does not have the resources to fully review
the source code of all software in the ports tree, you can configure the
ports system to take a few safety precautions.
The ports infrastructure is able to perform all building as a regular user,
and perform only those steps that require superuser privileges as root
(for example, the <tt>install</tt> make target).
However, because root privileges are always required at some point,
the ports system will not save you when you decide to build a malicious
application.

<p>
<ul>
<li>You can set up
<a href="http://man.openbsd.org?query=doas">doas(1)</a>
and have the ports system use it for tasks requiring superuser permissions.
This requires granting three permissions:

<ul>
  <li>The user who is going to build ports needs permission
  to run arbitrary commands as the superuser.
  <li>The user who is going to build ports needs permission
  to pass certain environment variables used by the ports system
  from the shell calling doas to the privileged shell,
  see the <tt>keepenv</tt> option in
  <a href="http://man.openbsd.org?query=doas.conf">doas.conf(5)</a>.
  <li>The ports system needs permission to invoke doas(1).
  This can be granted by setting the <tt>SUDO</tt> variable defined in
  <a href="http://man.openbsd.org?query=bsd.port.mk">bsd.port.mk(5)</a>
  in the environment, which can be made permanent
  by adding the following line to
  <a href="http://man.openbsd.org?query=mk.conf">mk.conf(5)</a>:

  <blockquote><pre>
  SUDO=/usr/bin/doas
  </pre></blockquote>
</ul>

<li>You can modify the ownership of the ports tree so that you can write
there as a regular user.
In this case, an example user has been added to the <tt>wsrc</tt> group
and the underlying directories are made group-writable.

<blockquote><pre>
# <b>user mod -G wsrc exampleuser</b>
# <b>chgrp -R wsrc /usr/ports</b>
# <b>find /usr/ports -type d -exec chmod g+w {} \;</b>
</pre></blockquote>
</ul>

<p>
It is possible to use a read-only ports tree by separating directories
that are written to during port building:

<ul>
  <li>The working directory of ports.
  This is controlled by the <tt>WRKOBJDIR</tt> variable, which specifies
  the directory which will contain the working directories.
  <li>The directory containing distribution files.
  This is controlled by the <tt>DISTDIR</tt> variable.
  <li>The directory containing newly built binary packages.
  This is controlled by the <tt>PACKAGE_REPOSITORY</tt> variable.
</ul>

For example, you could add the following lines to <tt>/etc/mk.conf</tt>:

<blockquote><pre>
WRKOBJDIR=/usr/obj/ports
DISTDIR=/usr/distfiles
PACKAGE_REPOSITORY=/usr/packages
</pre></blockquote>

If desired, you can also change the ownership of these directories to your
local username and group, so that the ports system can create the underlying
working directories as a regular user.
Again, ports can be <i>built</i> as a user, but must be <i>installed</i>
by root or with doas(1).

<h3 id="PortsSearch">15.3.4 - Searching the ports tree</h3>

Once you have the ports tree in place on your system, it becomes very easy
to search for software.
Just use <tt>make search key="searchkey"</tt> as shown in this example:

<blockquote><pre>
$ <b>cd /usr/ports</b>
$ <b>make search key=rsnapshot</b>
Port:   rsnapshot-1.3.1p0
Path:   net/rsnapshot
Info:   remote filesystem snapshot utility
Maint:  Antoine Jacoutot &lt;ajacoutot@openbsd.org&gt;
Index:  net sysutils
L-deps:
B-deps: :net/rsync
R-deps: :devel/p5-Lchown :net/rsync
Archs:  any
</pre></blockquote>

The search result gives a nice overview of each application that is found:
the port name, the path to the port, a one-line description, the port's
maintainer, keywords related to the port, library/build/runtime dependencies,
and architectures on which the port is known to work.

<p>
This mechanism, however, is a very basic one, which just runs awk(1)
on the ports index file.
A port called "sqlports" allows very fine-grained searching using SQL.
It is a SQLite database, but basically just about any database format can be
created using the ports infrastructure.
The <tt>sqlports</tt> port includes the script used to generate the database,
which could be used as a basis to generate databases in different formats.

<p>
Just pkg_add(1) the sqlports package to get started.
A sample session could look like this:

<blockquote><pre>
$ sqlite3 /usr/local/share/sqlports
SQLite version 3.3.12
Enter ".help" for instructions
sqlite> SELECT FULLPKGNAME,COMMENT FROM Ports WHERE COMMENT LIKE '%statistics%';
Guppi-0.40.3p1|GNOME-based plot program with statistics capabilities
mailgraph-1.12|a RRDtool frontend for Postfix statistics
R-2.4.1|clone of S, a powerful math/statistics/graphics language
py-probstat-0.912p0|probability and statistics utilities for Python
darkstat-3.0.540p1|network statistics gatherer with graphs
pfstat-2.2p0|packet filter statistics visualization
tcpstat-1.4|report network interface statistics
wmwave-0.4p2|Window Maker dockapp to display wavelan statistics
diffstat-1.43p0|accumulates and displays statistics from a diff file
sqlite>
</pre></blockquote>

The above is still a very basic search.
With SQL, just about anything can be searched for, including dependencies,
configure flags, shared libraries, etc.

<h3 id="PortsInstall">15.3.5 - Straightforward installation: a simple
example</h3>

For clarity's sake, let's consider a simple example: rsnapshot.
This application has one dependency: rsync.
The following commands assume you've configured the <tt>SUDO</tt>
varable in <tt>/etc/mk.conf</tt> as mentioned above.

<blockquote><pre>
$ <b>cd /usr/ports/net/rsnapshot</b>
$ <b>make install</b>
===>  Checking files for rsnapshot-1.2.9
&gt;&gt; rsnapshot-1.2.9.tar.gz doesn't seem to exist on this system.
&gt;&gt; Fetch http://www.rsnapshot.org/downloads/rsnapshot-1.2.9.tar.gz.
100% |**************************************************|   173 KB    00:02
&gt;&gt; Size matches for /usr/ports/distfiles/rsnapshot-1.2.9.tar.gz
&gt;&gt; Checksum OK for rsnapshot-1.2.9.tar.gz. (sha1)
===&gt;  rsnapshot-1.2.9 depends on: rsync-2.6.9 - not found
===&gt;  Verifying install for rsync-2.6.9 in net/rsync
===&gt;  Checking files for rsync-2.6.9
&gt;&gt; rsync-2.6.9.tar.gz doesn't seem to exist on this system.
&gt;&gt; Fetch ftp://ftp.samba.org/pub/rsync/old-versions/rsync-2.6.9.tar.gz.
100% |**************************************************|   792 KB    00:31
&gt;&gt; Size matches for /usr/ports/distfiles/rsync-2.6.9.tar.gz
&gt;&gt; Checksum OK for rsync-2.6.9.tar.gz. (sha1)
===&gt;  Verifying specs:  c
===&gt;  found c.40.3
===&gt;  Extracting for rsync-2.6.9
===&gt;  Patching for rsync-2.6.9
===&gt;  Configuring for rsync-2.6.9
  [...]
===&gt;  Building for rsync-2.6.9
  [...]
===&gt;  Faking installation for rsync-2.6.9
  [...]
===&gt;  Building package for rsync-2.6.9
Link to /usr/ports/packages/i386/ftp/rsync-2.6.9.tgz
Link to /usr/ports/packages/i386/cdrom/rsync-2.6.9.tgz
===&gt;  Installing rsync-2.6.9 from /usr/ports/packages/i386/all/rsync-2.6.9.tgz
rsync-2.6.9: complete
===&gt; Returning to build of rsnapshot-1.2.9
===&gt;  rsnapshot-1.2.9 depends on: rsync-2.6.9 - found
===&gt;  Extracting for rsnapshot-1.2.9
===&gt;  Patching for rsnapshot-1.2.9
===&gt;  Configuring for rsnapshot-1.2.9
  [...]
===>  Building for rsnapshot-1.2.9
  [...]
===&gt;  Faking installation for rsnapshot-1.2.9
  [...]
===&gt;  Building package for rsnapshot-1.2.9
Link to /usr/ports/packages/i386/ftp/rsnapshot-1.2.9.tgz
Link to /usr/ports/packages/i386/cdrom/rsnapshot-1.2.9.tgz
===&gt;  rsnapshot-1.2.9 depends on: rsync-2.6.9 - found
===&gt;  Installing rsnapshot-1.2.9 from /usr/ports/packages/i386/all/rsnapshot-1.2.9.tgz
rsnapshot-1.2.9: complete
</pre></blockquote>

<p>
As you can see, the ports system is doing many things automatically.
It will fetch, extract, and patch the source code, configure and build
(compile) the source, install the files into a fake directory, create
a package (corresponding to the packing list) and install this package
onto your system (usually under <tt>/usr/local/</tt>).
And it does this recursively <b>for all dependencies</b> of the port.
Notice the
"<tt>===&gt; Verifying install for ...</tt>" and
"<tt>===&gt; Returning to build of ...</tt>" lines in the above output,
indicating the walk through the dependency tree.

<p>
If a previous version of the application you want to install was already
installed on your system, you can use <tt>make update</tt> instead of
<tt>make install</tt>.
This will call pkg_add(1) with the <tt>-r</tt> flag.

<p>
<b>Note:</b>
Large applications will require a lot of system resources to build.
Good examples are compilers like GCC and the Java Software Development Kit.
If you get "out of memory" type of errors when building such a port,
this usually has one of two causes:

<ul>
  <li>Your resource limits are too restrictive.
  Adjust them with ksh's ulimit or csh's limit command.
  <li>You simply don't have enough RAM in your machine.
</ul>

<h3 id="PortsClean">15.3.6 - Cleaning up after a build</h3>

You probably want to clean the port's default working directory after
you have built the package and installed it.

<blockquote><pre>
$ <b>make clean</b>
===&gt;  Cleaning for rsnapshot-1.2.9
</pre></blockquote>

In addition, you can also clean the working directories of all
dependencies of the port with this make target:

<blockquote><pre>
$ <b>make clean=depends</b>
===&gt;  Cleaning for rsync-2.6.9
===&gt;  Cleaning for rsnapshot-1.2.9
</pre></blockquote>

If you wish to remove the source distribution set(s) of the port, you
would use:

<blockquote><pre>
$ <b>make clean=dist</b>
===&gt;  Cleaning for rsnapshot-1.2.9
===&gt;  Dist cleaning for rsnapshot-1.2.9
</pre></blockquote>

In case you have been compiling multiple flavors of the same port,
you can clear the working directories of all these flavors at once using:

<blockquote><pre>
$ <b>make clean=flavors</b>
</pre></blockquote>

You can also clean things up as they get built by setting a special variable.
Work directories will automatically be cleaned after packages have been
created.

<blockquote><pre>
$ <b>make package BULK=Yes</b>
</pre></blockquote>

<h3 id="PortsDelete">15.3.7 - Uninstalling a port's package</h3>

It is very easy to uninstall a port:

<blockquote><pre>
$ <b>make uninstall</b>
===&gt; Deinstalling for rsnapshot-1.2.9
rsnapshot-1.2.9: complete
Clean shared items: complete
</pre></blockquote>

This will call pkg_delete(1) to have the corresponding package removed
from your system.
If desired, you can also uninstall and reinstall a port's package by using:

<blockquote><pre>
$ <b>make reinstall</b>
===&gt;  Cleaning for rsnapshot-1.2.9
/usr/sbin/pkg_delete rsnapshot-1.2.9
rsnapshot-1.2.9: complete
Clean shared items: complete
===&gt;  Installing rsnapshot-1.2.9 from /usr/ports/packages/i386/all/rsnapshot-1.2.9.tgz
rsnapshot-1.2.9: complete
</pre></blockquote>

If you would like to get rid of the packages you just built, you can do so
as follows:

<blockquote><pre>
$ <b>make clean=packages</b>
===&gt;  Cleaning for rsnapshot-1.2.9
rm -f /usr/ports/packages/i386/all/rsnapshot-1.2.9.tgz
</pre></blockquote>

<h3 id="PortsFlavors">15.3.8 - Using flavors and subpackages</h3>

Please read the
<a href="http://man.openbsd.org?query=ports">ports(7)</a>
man page, which gives a good overview of this topic.
There are two mechanisms to control the packaging of software according
to different needs.

<p>
The first mechanism is called <b>flavors</b>.
A flavor usually indicates a certain set of compilation options.
For instance, some applications have a "no_x11" flavor which can be used on
systems without X.
Some shells have a "static" flavor that will build a statically linked
version.
There are ports which have different flavors for building them with
different graphical toolkits.
Other examples include support for different database formats,
different networking options (SSL, IPv6, ...), different paper sizes, etc.

<p>
<b>Summary:</b>
You will most likely use flavors when a package has not been made available
for the flavor you are looking for.
In this case, you can specify the desired flavor and build the port yourself.

<p>
Most port flavors have their own working directory during compilation,
and every flavor will be packaged into a correspondingly-named package to
avoid any confusion.
To see the different flavors of a certain port, you would change to its
subdirectory and issue:

<blockquote><pre>
$ <b>make show=FLAVORS</b>
</pre></blockquote>

You can also look at the port's <tt>DESCR</tt> files, which explain the
available flavors in more detail.

<p>
The second mechanism is called <b>subpackages</b>.
A porter may decide to create subpackages for different pieces of the
same application if they can be logically separated.
You will often see subpackages for the client part and the server part
of a program.
Sometimes extensive documentation is bundled in a separate subpackage
because it takes up a lot of disk space.
Extra functionality that pulls in heavy dependencies will often be
packaged separately.
The porter will also decide which subpackage is the main subpackage,
to be installed as a default.
Other examples are extensive test suites which come with the software,
separate modules with support for different things, etc.

<p>
<b>Summary:</b>
Some ports are split into several packages. <tt>make install</tt> will only
install the main subpackage.

<p>
To list the different packages built by a port, use:

<blockquote><pre>
$ <b>make show=PKGNAMES</b>
</pre></blockquote>

<tt>make install</tt> will only install the main subpackage.
To install them all, use:

<blockquote><pre>
$ <b>make install-all</b>
</pre></blockquote>

To list the different subpackages available for a port, use:

<blockquote><pre>
$ <b>make show=MULTI_PACKAGES</b>
</pre></blockquote>

It is possible to select which subpackage(s) to install from within the
ports tree.
After some tests, this procedure will just call
<a href="http://man.openbsd.org?query=pkg_add">pkg_add(1)</a>
to install the desired subpackage(s).

<blockquote><pre>
# <b>env SUBPACKAGE="-server" make install</b>
</pre></blockquote>

<b>Note:</b>
The subpackages mechanism only handles packages.
It does not modify any configuration options before building the port.
You must use flavors for that purpose.

<h3 id="dpb">15.3.9 - Using dpb to build multiple ports</h3>

When you need to build more than one or two ports at a time, you can
use the <tt>/usr/ports/infrastructure/bin/dpb</tt> tool.

<a href="http://man.openbsd.org?query=dpb">dpb(1)</a>
takes a list of ports to build and automatically builds them all in an
optimal order, making use of as much parallelism as possible.
It can also use multiple machines to perform the building, and produces
detailed logs of the build process for troubleshooting, placed in
<tt>/usr/ports/log</tt> by default.

<blockquote><pre>
# <b>/usr/ports/infrastructure/bin/dpb -P ~/localports</b>
</pre></blockquote>

This command will read the list of
<a href="http://man.openbsd.org?query=pkgpath">pkgpaths</a>
in <tt>~/localports</tt> and build all the packages.
It can also install the packages after they have been built.
The <tt>~/localports</tt> file would look something like this:

<blockquote><pre>
net/cvsync
www/mozilla-firefox
net/rsync
net/nfsen
textproc/mupdf
misc/magicpoint
lang/sbcl
editors/emacs
</pre></blockquote>

If you do not provide a list of ports to build on the command line or
via <tt>-P</tt> or <tt>-I</tt>,
<a href="http://man.openbsd.org?query=dpb">dpb(1)</a>
will build all the ports in the ports tree.
If run as root, dpb will automatically drop privileges to dedicated users
for fetching distfiles and building ports.
This is the recommended way to use it, but it can also run as a regular user.

<h3 id="PortsSecurity">15.3.10 - Security updates</h3>

When serious bugs or security flaws are discovered in third party software,
they are fixed in the <i>-stable</i> branch of the ports tree.
Note that <b>binary packages for -release and -stable are not updated</b>.
In contrast to the base system, the -stable ports tree only gets security
backports for the latest release.

<p>
This means that all you need to do is make sure you check out the correct
branch of the ports tree, and build the desired software from it.
You can keep your tree up to date with <a href="../anoncvs.html">CVS</a>
and subscribe to the ports-changes <a href="../mail.html">mailing list</a>
to receive security announcements related to software in the ports tree.

<p>
Of course, security updates reach the <i>-current</i> ports tree before
being taken up in the <i>-stable</i> branch.

<h3 id="PkgSig">15.3.11 - Package signatures</h3>

Signatures are a good way to make sure packages are legitimate and not
corrupted.
OpenBSD offers official signed packages using
<a href="http://man.openbsd.org?query=signify">signify(1)</a>.
No extra effort is needed on the user's part to ensure packages haven't
been tampered with -- pkg_add does this silently and automatically.

<p>
If you want to build <i>your own</i> signed packages, you'll first need
to create keys for signing.

<blockquote><pre>
# <b>signify -Gns /etc/signify/toto-pkg.sec -p /etc/signify/toto-pkg.pub</b>
</pre></blockquote>

Note the names: keys for signing packages should end in <tt>pkg</tt>.

<p>
Then we may sign existing packages after building them with
<a href="http://man.openbsd.org?query=pkg_sign">pkg_sign(1)</a>.

<blockquote><pre>
# <b>cd /usr/ports/packages/$(uname -m)</b>
# <b>pkg_sign -s signify -s /etc/signify/toto-pkg.sec -o signed -S all</b>
</pre></blockquote>

Alternately, we may add the following line to <tt>/etc/mk.conf</tt> to
directly build signed packages by default:

<blockquote><pre>
SIGNING_PARAMETERS=-s signify -s /etc/signify/toto-pkg.sec
</pre></blockquote>

In order to install the package on another machine, the public key
<tt>toto-pkg.pub</tt> should be put into the <tt>/etc/signify</tt> directory
on that machine.

<p>
By default, pkg_add will only allow signed packages, and it will always
look for keys matching <tt>/etc/signify/*pkg.pub</tt>.

<h2 id="PkgFAQ">15.4 - FAQ</h2>

<h3 id="NoFun">15.4.1 - I'm getting all kinds of crazy errors.
I just can't seem to get this ports stuff working at all.</h3>

It is very likely that you are using a system and ports tree which are
not in sync.

<ul>
  <li>Read EVERYTHING about <a href="faq5.html#Flavors">OpenBSD's flavors</a>:
  -release, -stable and -current.
  The short summary is as follows, but please do read the document mentioned
  above to get an idea about which one it is you want to use.
<ul>
  <li><a href="../orders.html">-release</a>: What is on the CD
  <li><a href="../stable.html">-stable</a>: -release plus security fixes and
      reliability enhancements
  <li><a href="current.html">-current</a>: The development version of OpenBSD
</ul>

<li>Do NOT check out a -current ports tree and expect it to work on
a -release or -stable system.
This is one of the most common errors, and you will irritate people when
you ask for help about why nothing seems to work.
<b>If you follow -current, you need both a -current base system
and a -current ports tree</b>.
Yes, this really does mean a wonderful new port will typically not work on
your "older" system, even if that system was -current just a few weeks ago.
Keep in mind that if you use X11 as part of your system, it must also
follow the corresponding branch!
<li>Because no intrusive changes are made in -stable, it is possible to
use a -stable ports tree on a -release system and vice versa.
There is no need to update all your installed packages after applying
a few errata patches to your system.
</ul>

<p>
Another common failure is a missing X11 installation.
Even if the port you try to build has no direct dependency on X11, a
subpackage of it or its dependencies may require X11 headers and libraries.
<b>Building ports on systems without X11 is not supported</b>.
If you insist on doing so, you are on your own to figure it out.
There are, however, "no_x11" flavored packages available for many ports,
which you can install without needing X11 on your system.

<h3 id="Latest">15.4.2 - The latest version of my Top-Favorite-Software
is not available!</h3>

If you are using a release or stable version of OpenBSD, you will not
find any package updates until the next release.
For serious problems which are fixed in ports, updates are also made to
the most recent -stable branch.
You can build your own updates in this case, but, again, <b>the OpenBSD
project does not provide pre-built packages for these updates</b>.

<p>
DO NOT mix versions of ports and OpenBSD!
Doing so will sooner or later (probably very soon, in fact) cause you
headaches trying to solve <a href="#NoFun">all kinds of errors</a>!

<p>
<i>But hey, I'm all -current here!</i>

<p>
The ports collection is a volunteer project.
Sometimes the project simply doesn't have the developer resources to keep
everything up-to-date.
Developers pretty much pick up what they consider interesting and can test
in their environment.
Some individual ports may lag behind the mainstream versions because of this.
Importantly, not updating to the latest version is often a conscious decision.
The newer version may have problems that the maintainer is trying to solve,
or that have simply made the application worse than the old version.
Also, OpenBSD may have different <a href="../goals.html">goals</a> than the
developers in other projects, which sometimes results in features and design
or implementation choices that are undesirable from OpenBSD developers'
point of view.
The update may also be postponed because the new version is not considered
a crucial update.

<p>
If you really need a newer version of a port, you should ask the maintainer
to update it.
See <a href="#Problems">below</a> to find out who the port maintainer is.
If you can <a href="#Helping">help</a>, all the better.

<h3 id="NoPkg">15.4.3 - Why is there no package for my
Top-Favorite-Software?</h3>

There are several possible reasons for this:

<ul>
  <li>Some software must simply not be redistributed in binary package
  form at all, according to its license.
  Other software is encumbered by patents and therefore cannot be
  redistributed.
  If your Top-Favorite-Software falls into this category, you will need
  to use the port and compile from source.
  <li>Obvious, but sometimes forgotten: there is
  <a href="#NoPort">no port of your Top-Favorite-Software</a>.
  You can verify this by <a href="#PortsSearch">searching the ports tree</a>.
  If there is indeed no port of your Top-Favorite-Software, then you
  are welcome to <a href="#Helping">help</a>.
</ul>

<h3 id="NoPort">15.4.4 - Why is there no port of my Top-Favorite-Software?</h3>

The ports collection is a volunteer project.
Active port development is done by a limited number of people, in their
spare time.
These people usually make new ports only for software they use directly
or are interested in.

<p>
You can <a href="#Helping">help</a>.
Consider creating your own port.
There is some documentation available on this: the <a href="ports/index.html">
OpenBSD Porter's Handbook</a>.
Read it, then read it again, especially the part about <i>maintaining</i>
your port.
Then try making a new port and test it carefully, step by step.
If finally it works OK for you, submit it to the ports mailing list
at <a href="mailto:ports@openbsd.org">ports@openbsd.org</a>.
Chances are good you will get some feedback and testing from other people.
If the testing is successful, your port will be considered to be taken up
in the ports tree.

<h3 id="NotInBase">15.4.5 - Why is my Top-Favorite-Software not part of the
base system?</h3>

Because OpenBSD is supposed to be a small stand-alone UNIX-like operating
system, we need to draw a line as to what to include.
Generally, for an application to be included in the base system:

<ul>
  <li>It must meet the high quality standards, laid out in the
  <a href="../goals.html">goals</a> of the OpenBSD project.
  <li>Its license must not be too restrictive and must be compatible
  with the BSD license.
  <li>It must not be too large, in order to keep the size of the base
  system acceptable.
</ul>

<p>
Further answers to this question can be found in <a href="faq1.html#HowAbout">
FAQ 1</a>.

<h3 id="PkgVsPorts">15.4.6 - What should I use: packages or ports?</h3>

In general, you are <b>highly advised</b> to use packages over building
an application from ports.
The OpenBSD ports team considers packages to be the goal of their porting
work, not the ports themselves.

<p>
Building a complex application from source is not trivial.
Not only must the application be compiled, but the tools used to build it
must be built as well.
Unfortunately, OpenBSD, the tools, and the application are all evolving,
and getting all the pieces working together is often a challenge.
Once everything works, a revision in any of the pieces the next day could
render it broken.
Every <a href="faq1.html#Next">six months</a>, as a
<a href="faq5.html#Flavors">new release</a> of OpenBSD is made,
an effort is made to test the building of every port on every platform.
During the development cycle, however, it's likely that some ports will break.

<p>
In addition to having all the pieces work together, there is just the matter
of time and resources required to compile some applications from source.
Applications such as <a href="http://www.mozilla.org">Mozilla products</a>
or <a href="http://www.kde.org">KDE</a> may take hours and huge amounts
of disk space and RAM/swap to build.
Why go through this much time and effort when the programs are already
compiled and sitting on your <a href="../orders.html">CD-ROM</a> or
<a href="../ftp.html">mirror</a>, waiting to be used?

<p>
Of course, there are a few good reasons to use ports over packages
in some cases:

<ul>
  <li>Distribution rules prohibit OpenBSD from distributing a package
  <li>You wish to modify or debug the application or study its source code
  <li>You need a flavor of a port that is not built by the OpenBSD ports team
  <li>You wish to alter the directory layout (i.e. modifying <tt>PREFIX</tt>
  or <tt>SYSCONFDIR</tt>)
</ul>

However, for most people and most applications, using packages is a much
easier, and definitely the recommended way of adding applications to an
OpenBSD system.

<h3 id="Knobs">15.4.7 - How do I tweak these ports to have maximum
performance?</h3>

OpenBSD is about stability and security.
Just like the GENERIC kernel is the default and the only supported kernel,
the ports team makes sure the ports work and are stable.
If you want to switch on all kinds of compiler options, you are on your own.
Please do not ask questions on the mailing lists such as why it does not
work when you tried to switch on a few hidden knobs to make it work faster.
In general, all this tweaking is not necessary for 99% of users,
and it is very likely to be a complete waste of time, for you, the user, as
well as for the developers who read about your "problems" when in reality
there are none.

<h3 id="Wait">15.4.8 - I submitted a new port/an update weeks ago. Why isn't
it committed?</h3>

The ports team has very limited resources and no committer was able
to look at your port/update in time.
As frustrating as it may be, just ignore this fact.
Take care of your port, send updates and eventually someone might take care
of it.
It has happened before that people suddenly have some free time to spend on
committing ports, or their interests shift to new areas and suddenly your
old submission becomes interesting, if it is remembered.

<h2 id="Problems">15.5 - Reporting problems</h2>

If you have trouble with an existing port, please send an email to the
port maintainer.
To see who is the maintainer of the port, type, for example:

<blockquote><pre>
$ <b>cd /usr/ports/archivers/unzip</b>
$ <b>make show=MAINTAINER</b>
</pre></blockquote>

Alternatively, if there is no maintainer, or you can't reach them, send an
email to the <a href="mailto:ports@openbsd.org">ports@openbsd.org</a>
mailing list.
Please do NOT use the misc@openbsd.org mailing list for questions
about ports.

<p>
In any case, please provide:

<ul>
  <li>Your OpenBSD version, including any patches you may have applied.
  The kernel version is given by: <tt>sysctl -n kern.version</tt>
  <li>The version of your ports tree: if the file <tt>/usr/ports/CVS/Tag</tt>
  exists, provide its contents.
  If this file is absent, you are using the -current ports tree.
  <li>A complete description of the problem.
  Don't be afraid to provide details.
  Mention all the steps you followed before the problem occurred.
  Is the problem reproducible?
  The more information you provide, the more likely you will get help.
</ul>

For ports which do not build correctly, a complete build transcript is
almost always required.
You can use the <tt>portslogger</tt> script, found in
<tt>/usr/ports/infrastructure/bin</tt>, for this.
A sample run might look like this:

<blockquote><pre>
$ <b>mkdir ~/portlog</b>
$ <b>cd /usr/ports/archivers/unzip</b>
$ <b>make 2&gt;&amp;1 | /usr/ports/infrastructure/bin/portslogger ~/portlog</b>
</pre></blockquote>

After this, you should have a logfile of the build in your <tt>~/portlog</tt>
directory that you can send to the port maintainer.
Also, make sure you are not using any special options in your build,
for example in <tt>/etc/mk.conf</tt>.

<p>
Alternatively, you can:

<ul>
  <li>Use
  <a href="http://man.openbsd.org?query=script">script(1)</a>
  to create a complete build transcript.
  Do not remove the configure information.
  <li>Attach the output of
  <a href="http://man.openbsd.org?query=pkg_info">pkg_info(1)</a>
  if it seems even remotely relevant.
  <li><a href="http://man.openbsd.org?query=gcc">gcc(1)</a>
  internal compiler errors ask you to report the bug to the gcc
  mailing list.
  It does save time if you follow their direction, and provide at least
  the various files produced by <tt>gcc -save-temps</tt>.
</ul>

<h2 id="Helping">15.6 - Helping us</h2>

There are many ways you can help.
They are listed below, by increasing order of difficulty.

<ul>
  <li><a href="#Problems">Report problems</a> as you experience them.
  <li>You can systematically test ports and report breakages, or suggest
  improvements.
  Just have a look at the <a href="ports/testing.html">Port Testing Guide</a>.
  <li>Test the updates to ports which are posted to the ports mailing list.
  <li>Send updates or patches to a port's maintainer, or to the ports
  mailing list if the port has no maintainer.
  Generally this is highly appreciated, unless your patches will cause
  developers to waste time rather than save time.
  <li>Create new ports.
  If you are really eager and want to know everything about porting
  applications to OpenBSD, a good starting point is the
  <a href="ports/index.html">OpenBSD Porter's Handbook</a>.
</ul>

<p>
<a href="../want.html">Hardware</a> donations can assist
testing ports on the various <a href="../plat.html">platforms</a>
OpenBSD runs on.

<p>
<b>Note:</b>
For all creation of new ports and subsequent testing, or for testing port
updates, you <b>must run a -current system!</b>
In general, this is not a desirable environment because of its continuously
evolving nature, so proceed only if you are sure about committing yourself
to following -current.

<p>
<hr>
<p>
<a href= "index.html">[FAQ Index]</a>
<a href= "faq14.html">[To Section 14 - Disk Setup]</a>
</body>
</html>
